import React, { useState, useEffect, useLayoutEffect, useRef } from 'react';
import { useParams, useLocation } from 'react-router-dom';
import Picker from 'emoji-picker-react';
import { Timeline, DataSet } from 'vis-timeline/standalone';
import 'vis-timeline/styles/vis-timeline-graph2d.min.css';
import moment from 'moment';

// DnD Kit
import { DndContext, closestCenter, useDroppable } from '@dnd-kit/core';
import { SortableContext, useSortable, arrayMove, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

// Icons
import Edit from '../../icons/edit.svg';
import leftBtn from '../../icons/left.svg';
import rightBtn from '../../icons/righ.svg';
import rechange from '../../icons/rechange.svg';
import EditIcon from '../../icons/pencil.svg'; 
import DeleteIcon from '../../icons/trash.svg'; 

// Components
import TodoEditModal from './popups/todoEdit';
import TodoMorePopup from './popups/todoMore';
import FeedbackPopup from './popups/feedback';
import pencilIcon from '../../icons/pencilIcon.png';
import sendIcon from '../../icons/sendIcon.png';
/* timeline */ 
import { Timeline,DataSet } from 'vis-timeline/standalone'
import 'vis-timeline/styles/vis-timeline-graph2d.min.css';

// CSS
import '../../css/feedbackpopup.css';

const ProjectContent = () => {
    const { Pg_id } = useParams(); 


    const location = useLocation();
    const { username } = location.state || {};

    // ‚≠ê Ïä§ÌÅ¨Î°§ Ï¥àÍ∏∞Ìôî - Ïª¥Ìè¨ÎÑåÌä∏ ÏµúÏÉÅÏúÑÏóêÏÑú Ìò∏Ï∂ú
    useLayoutEffect(() => {
        const scrollToTop = () => {
            window.scrollTo({ top: 0, behavior: 'auto' });
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
        };
        
        scrollToTop();
        
        // Ïó¨Îü¨ Î≤à ÏãúÎèÑÌïòÏó¨ ÌôïÏã§Ìûà Ï¥àÍ∏∞Ìôî
        const timeouts = [0, 50, 150, 300, 500].map(delay => 
            setTimeout(scrollToTop, delay)
        );
        
        return () => timeouts.forEach(clearTimeout);
    }, [Pg_id, location.pathname]);

    /* ========================================================= */
    /* =============    ÌîÑÎ°úÏ†ùÌä∏ Í∏∞Î≥∏ Ï†ïÎ≥¥ Í¥ÄÎ¶¨    ================ */
    /* ========================================================= */
    const [projectName, setProjectName] = useState(null);
    const [projectInfo, setProjectInfo] = useState(null);
    const [projectData, setProjectData] = useState(null);
    const [projectInfoId, setProjectInfoId] = useState(null);

    // ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥ Î∂àÎü¨Ïò§Í∏∞
    useEffect(() => {
        if (!Pg_id) return;

        const fetchProjectData = async () => {
            try {
                const [infoResponse, dataResponse, projectsResponse] = await Promise.all([
                    fetch(`http://localhost:8008/project/name/${Pg_id}`),
                    fetch(`http://127.0.0.1:8008/project/${Pg_id}`, {
                        headers: { Authorization: `Bearer ${localStorage.getItem('access_token')}` }
                    }),
                    fetch("http://localhost:8008/getProjects")
                ]);

                const [infoData, dataData, projectsData] = await Promise.all([
                    infoResponse.json(),
                    dataResponse.json(),
                    projectsResponse.json()
                ]);

                setProjectInfo(infoData);
                setProjectData(dataData);
                setProjectName(dataData?.project?.name || '');

                // ÌîÑÎ°úÏ†ùÌä∏ intÌòï ID Ï∂îÏ∂ú
                const match = projectsData.find(p => p.project.id === Pg_id);
                setProjectInfoId(match?.id || null);

            } catch (error) {
                console.error('ÌîÑÎ°úÏ†ùÌä∏ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®:', error);
            }
        };

        fetchProjectData();
        fetchTodos();
        updateTodoCounts();
    }, [Pg_id]);
    // ÌîÑÎ°úÏ†ùÌä∏ ÏïÑÏù¥ÎîîÍ∞Ä ÏóÜÎã§Î©¥


    /* ========================================================= */
    /* =================    Í≥µÏßÄÏÇ¨Ìï≠ Í¥ÄÎ¶¨    ==================== */
    /* ========================================================= */
    const [notice, setNotice] = useState('');
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const [isEditing, setIsEditing] = useState(false);
    const [tempContent, setTempContent] = useState('');

    // Ïù¥Î™®ÏßÄ Í¥ÄÎ¶¨
    const [showEmojiPicker, setShowEmojiPicker] = useState(false);
    const [selectedEmoji, setSelectedEmoji] = useState({ emoji: 'üö©' });

    // Í≥µÏßÄÏÇ¨Ìï≠ Î∂àÎü¨Ïò§Í∏∞
    useEffect(() => {
        if (!Pg_id) return;

        const fetchNotice = async () => {
            setIsLoading(true);
            try {
                const response = await fetch(`http://127.0.0.1:8008/project/${Pg_id}/notice`);
                if (response.ok) {
                    const data = await response.json();
                    setNotice(data.content);
                } else {
                    setNotice('');
                }
                setError(null);
            } catch (err) {
                setError(err.message);
                setNotice('');
            } finally {
                setIsLoading(false);
            }
        };

        fetchNotice();
    }, [Pg_id]);

    const handleEditClick = () => {
        setTempContent(notice || '');
        setIsEditing(true);
    };

    const handleSaveClick = async () => {
        try {
            const response = await fetch(`http://127.0.0.1:8008/project/${Pg_id}/notice`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ content: tempContent }),
            });

            if (response.ok) {
                setNotice(tempContent);
                setIsEditing(false);
                alert("Í≥µÏßÄÏÇ¨Ìï≠Ïù¥ ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.");
            } else {
                throw new Error("Í≥µÏßÄÏÇ¨Ìï≠ ÏàòÏ†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
            }
        } catch (error) {
            console.error(error.message);
            alert("Í≥µÏßÄÏÇ¨Ìï≠ ÏàòÏ†ï Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
        }
    };

    const handleCancelClick = () => {
        setIsEditing(false);
    };

    const handleEmojiSelect = (emojiObject) => {
        setSelectedEmoji(emojiObject);
        setShowEmojiPicker(false);
    };

    /* ========================================================= */
    /* =================    Ï∫òÎ¶∞Îçî Í¥ÄÎ¶¨    ===================== */
    /* ========================================================= */
    const today = new Date();
    const [currentWeek, setCurrentWeek] = useState(getCurrentWeek());
    const [currentMonth, setCurrentMonth] = useState(getCurrentMonth());

    function getCurrentWeek() {
        const today = new Date();
        const firstDayOfWeek = new Date(today.setDate(today.getDate() - today.getDay()));
        const week = [];
        for (let i = 0; i < 7; i++) {
            const date = new Date(firstDayOfWeek);
            date.setDate(firstDayOfWeek.getDate() + i);
            week.push(date);
        }
        return week;
    }

    function getCurrentMonth() {
        return new Date().getMonth();
    }

    const handleLeftWeek = () => {
        const newWeek = [];
        const firstDayOfCurrentWeek = new Date(currentWeek[0]);

        for (let i = 0; i < 7; i++) {
            const prevDay = new Date(firstDayOfCurrentWeek);
            prevDay.setDate(firstDayOfCurrentWeek.getDate() - 7 + i);
            newWeek.push(prevDay);
        }

        setCurrentMonth(newWeek[0].getMonth());
        setCurrentWeek(newWeek);
    };

    const handleRightWeek = () => {
        const newWeek = [];
        const lastDayOfCurrentWeek = new Date(currentWeek[6]);

        for (let i = 0; i < 7; i++) {
            const nextDay = new Date(lastDayOfCurrentWeek);
            nextDay.setDate(lastDayOfCurrentWeek.getDate() + 1 + i);
            newWeek.push(nextDay);
        }

        setCurrentMonth(newWeek[0].getMonth());
        setCurrentWeek(newWeek);
    };

    /* ========================================================= */
    /* =================    Todo ÏÉÅÌÉú Í¥ÄÎ¶¨    ================== */
    /* ========================================================= */
    const [inProgressCount, setInProgressCount] = useState(0);
    const [completedCount, setCompletedCount] = useState(0);
    const [waitingFeedbackCount, setWaitingFeedbackCount] = useState(0);
    const [totalCount, setTotalCount] = useState(0);

    const updateTodoCounts = async () => {
        if (!Pg_id) return;

        try {
            const [inProgressRes, completedRes, feedbackRes] = await Promise.all([
                fetch(`http://127.0.0.1:8008/projects/${Pg_id}/todos/status/in_progress`),
                fetch(`http://127.0.0.1:8008/projects/${Pg_id}/todos/status/completed`),
                fetch(`http://127.0.0.1:8008/projects/${Pg_id}/todos/status/waiting_feedback`)
            ]);

            const [inProgressData, completedData, feedbackData] = await Promise.all([
                inProgressRes.json(),
                completedRes.json(),
                feedbackRes.json()
            ]);

            const inProgressLen = inProgressData.todos.length;
            const completedLen = completedData.todos.length;
            const feedbackLen = feedbackData.todos.length;

            setInProgressCount(inProgressLen);
            setCompletedCount(completedLen);
            setWaitingFeedbackCount(feedbackLen);
            setTotalCount(inProgressLen + completedLen + feedbackLen);
        } catch (err) {
            console.error("Todo Ïπ¥Ïö¥Ìä∏ Ï°∞Ìöå Ïã§Ìå®:", err);
        }
    };

    /* ========================================================= */
    /* =================    Todo Ïπ∏Î∞ò Í¥ÄÎ¶¨    ================== */
    /* ========================================================= */
    const [showDetail, setShowDetail] = useState({ open: false, status: null });
    const [todos, setTodos] = useState({
        inProgress: [],
        completed: [],
        feedbackPending: [],
    });
    const [editingId, setEditingId] = useState(null);
    const [localEditContent, setLocalEditContent] = useState('');
    const [localEditDueDate, setLocalEditDueDate] = useState('');

    const totalTodosCount = todos.inProgress.length + todos.completed.length + todos.feedbackPending.length;

    // Todo Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    const fetchTodos = async () => {
        if (!Pg_id) return;

        try {
            const response = await fetch(`http://127.0.0.1:8008/projects/${Pg_id}/todos`);
            const data = await response.json();

            const categorizedTodos = {
                inProgress: [],
                completed: [],
                feedbackPending: []
            };

            data.forEach(todo => {
                const base = {
                    id: todo.id,
                    content: todo.text,
                    dueDate: todo.deadline,
                    completed: todo.status === 'completed',
                };

                switch (todo.status) {
                    case 'in_progress':
                        categorizedTodos.inProgress.push(base);
                        break;
                    case 'completed':
                        categorizedTodos.completed.push(base);
                        break;
                    case 'waiting_feedback':
                        categorizedTodos.feedbackPending.push(base);
                        break;
                    default:
                        console.warn(`Unknown status "${todo.status}" for todo ID: ${todo.id}`);
                }
            });

            setTodos(categorizedTodos);
            updateTodoCounts();
        } catch (error) {
            console.error("Todo Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞ Ïò§Î•ò:", error);
        }
    };

    const calculateDDay = (dueDate) => {
        const today = new Date();
        const due = new Date(dueDate);
        const diffTime = due - today;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays >= 0 ? `D-${diffDays}` : `D+${Math.abs(diffDays)}`;
    };

    const handleEdit = (id, content, dueDate) => {
        setEditingId(id);
        setLocalEditContent(content);
        setLocalEditDueDate(dueDate);
    };

    const handleDragEnd = async (event) => {
        const { active, over } = event;
        if (!active || !over || active.id === over.id) return;

        const activeId = active.id;
        const overStatus = over?.data?.current?.status || over?.id;

        const newStatusMap = {
            inProgress: "in_progress",
            completed: "completed",
            feedbackPending: "waiting_feedback",
        };

        const newStatus = newStatusMap[overStatus];
        if (!newStatus) return;

        try {
            const res = await fetch(`http://127.0.0.1:8008/todos/${activeId}/status?status=${newStatus}`, {
                method: "POST"
            });
            
            if (res.ok) {
                await fetchTodos();
                updateTodoCounts();
            }
        } catch (err) {
            console.error("Todo ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïã§Ìå®:", err);
        }
    };

    const handleCheck = (id, status) => {
        if (!todos[status]) return;
        
        setTodos((prevTodos) => ({
            ...prevTodos,
            [status]: prevTodos[status].map((item) =>
                item.id === id ? { ...item, completed: !item.completed } : item
            ),
        }));
    };

    const saveEdit = async (id, status) => {
        if (!todos[status]) return;

        const updatedData = {
            text: localEditContent,
            user_id: username,
            deadline: localEditDueDate.includes('.') 
                ? localEditDueDate.replaceAll('.', '-') 
                : localEditDueDate,
            start_day: '2025-04-01',
            project_id: Pg_id,
        };

        try {
            const response = await fetch(`http://127.0.0.1:8008/todos/${id}`, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(updatedData),
            });

            if (response.ok) {
                setTodos((prevTodos) => ({
                    ...prevTodos,
                    [status]: prevTodos[status].map((item) =>
                        item.id === id ? { ...item, content: localEditContent, dueDate: updatedData.deadline } : item
                    ),
                }));
                setEditingId(null);
            }
        } catch (error) {
            console.error("Todo ÏàòÏ†ï Ïã§Ìå®:", error);
        }
    };
    const handleDelete = async (id, status) => {
        if (!todos[status]) return;
    
        try {
            const response = await fetch(`http://127.0.0.1:8008/todos/${id}?project_id=${Pg_id}`, {
                method: "DELETE",
            });
    
            if (response.ok) {
                await fetchTodos();
                updateTodoCounts();
            }
        } catch (error) {
            console.error("Todo ÏÇ≠Ï†ú Ïã§Ìå®:", error);
        }
    };
    const handleDeleteWithModal = (id, status) => {
        setModal_realMsg('Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
        setPendingAction(() => () => handleDelete(id, status));
        setShowCancelModal(true);
    };
    
    // Sortable Item Ïª¥Ìè¨ÎÑåÌä∏
    const SortableItem = ({ id, content, dueDate, status, completed }) => {
        const { attributes, listeners, setNodeRef, transform, transition } = useSortable({
            id, data: { status }, handle: '.drag-handle',
        });
        const inputRef = useRef(null);

        const style = {
            transform: CSS.Transform.toString(transform),
            transition: transform ? 'transform 0.1s ease' : 'transform 0.3s ease-out',
            width: '100%',
            boxSizing: 'border-box',
            opacity: transform ? 0.7 : 1,
        };

        useEffect(() => {
            if (editingId === id && inputRef.current) {
                inputRef.current.focus();
            }
        }, [editingId]);

        return (
            <div ref={setNodeRef} style={style} className="todo-item">
                {editingId === id ? (
                    <div className="edit-form">
                        <input
                            ref={inputRef}
                            type="text"
                            value={localEditContent}
                            onChange={(e) => setLocalEditContent(e.target.value)}
                            placeholder="Ìï† Ïùº ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî"
                        />
                        <input
                            type="date"
                            value={localEditDueDate}
                            onChange={(e) => setLocalEditDueDate(e.target.value)}
                        />
                        <div className="edit-buttons">
                            <button onClick={() => saveEdit(id, status)}>Ï†ÄÏû•</button>
                            <button onClick={() => setEditingId(null)}>Ï∑®ÏÜå</button>
                        </div>
                    </div>
                ) : (
                    <>
                        <div className="todo-content">
                            <span className="drag-handle" {...attributes} {...listeners}>‚â°</span>
                            <div 
                                style={{ textDecoration: completed ? 'line-through' : 'none' }}
                                onClick={() => handleEdit(id, content, dueDate)} // ÌÅ¥Î¶≠ÏúºÎ°ú Ìé∏Ïßë Î™®Îìú ÏßÑÏûÖ
                            >
                                {content}
                            </div>
                            <span className="due-date">{calculateDDay(dueDate)}</span>
                        </div>
                        <div className="todo-meta">
                            <span>{dueDate}ÍπåÏßÄ</span>
                            <div className="icons">
                                <img
                                    src={EditIcon}
                                    alt="edit"
                                    className="icon edit"
                                    onClick={() => handleEdit(id, content, dueDate)}
                                />
                                <img
                                    src={DeleteIcon}
                                    alt="delete"
                                    className="icon trash"
                                    onClick={() => handleDeleteWithModal(id, status)} // Î™®Îã¨Î°ú Î≥ÄÍ≤Ω
                                />
                                <div
                                    className={`checkBox ${completed ? 'checked' : ''}`}
                                    onClick={() => handleCheck(id, status)}
                                />
                            </div>
                        </div>
                    </>
                )}

            </div>
        );
    };

    // Todo Column Ïª¥Ìè¨ÎÑåÌä∏
    const TodoColumn = ({ title, items, status, onDetail }) => {
        const { setNodeRef } = useDroppable({
            id: status,
            data: { status },
        });

        return (
            <div ref={setNodeRef} className={`todo-column ${status}`}>
                <div className="column-header">
                    <h2>{title}</h2>
                    <span>{`${items.length}/${totalTodosCount}`}</span>
                    <img src={EditIcon} alt="edit" className="icon" onClick={onDetail} />
                </div>
                <SortableContext
                    id={status}
                    items={items.map((item) => item.id)}
                    strategy={verticalListSortingStrategy}
                >
                    {items.map((item) => (
                        <SortableItem
                            key={item.id}
                            id={item.id}
                            content={item.content}
                            dueDate={item.dueDate}
                            status={status}
                            completed={item.completed}
                        />
                    ))}
                </SortableContext>
            </div>
        );
    };



    //===================================================================== //
    // ------------------------       ÌÉÄÏûÑÎùºÏù∏       ------------------------//
    //===================================================================== // 
    const [timelineTodos, setTimelineTodos] = useState([]); 
    const [timelineItems, setTimelineItems] = useState(new DataSet([]));
    const [groups, setGroups] = useState(new DataSet([]));
    const [todoProgress, setTodoProgress] = useState({});
    const [modal_realMsg, setModal_realMsg] = useState('');
    const [pendingAction, setPendingAction] = useState(null);
    const [pendingMove, setPendingMove] = useState(null);

    const [todoEditModal, setTodoEditModal] = useState({
        isOpen: false,
        todoId: null
    });
    const [selectedTodoId, setSelectedTodoId] = useState(null);
    const timelineRef = useRef(null);
    const groupColors = {};

    // Í∑∏Î£π Î™®ÎëêÎ≥¥Í∏∞ Ìï∏Îì§Îü¨
    const handleShowAllGroups = () => {
        const updatedGroups = groups.get().map(group => ({
            ...group,
            visible: true
        }));
        groups.update(updatedGroups);
    };

    // Ïª¨Îü¨ ÏÑ§Ï†ï 
    const colorClasses = [
        'color-white'
    ];  
    function getGroupColorClass(groupName) {
        if (!groupColors[groupName]) {
            groupColors[groupName] = colorClasses[colorIndex];
            colorIndex = (colorIndex + 1) % colorClasses.length; 
        }
        return groupColors[groupName];
    }
    let colorIndex = 0;
    //ÌÉÄÏûÑÎùºÏù∏ Î¶¨Î°úÎìú
    const fetchTimelineTodos = async () => {
        try {
          const res = await fetch(`http://localhost:8008/projects/${Pg_id}/todos`);
          const data = await res.json();
          setTimelineTodos(data);
        } catch (err) {
          console.error("ÌÉÄÏûÑÎùºÏù∏ Ìà¨Îëê Î∂àÎü¨Ïò§Í∏∞ ÏóêÎü¨", err);
        }
      };
      
// 1. Pg_id ( ÌîÑÎ°úÏ†ùÌä∏ ÏïÑÏù¥ÎîîÎ°ú ) ÌîÑÎ°úÏ†ùÌä∏ Ìà¨Îëê Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞
    useEffect(() => {
        fetchTimelineTodos();
      }, [Pg_id]);
// 2. Í∞Å Ìà¨ÎëêÏùò user_idÏùò ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ Îß§Ìïë + timeline ÏïÑÏù¥ÌÖú ÏÉùÏÑ±
    useEffect(() => {
        if (!timelineTodos.length) return;
        
        const fetchProfilesAndSetItems = async () => {
            // Î™®Îì† Îã¥ÎãπÏûê ID ÏàòÏßë (Î∞∞Ïó¥ ÌòïÌÉúÎ°ú Ï≤òÎ¶¨)
            const allUserIds = new Set();
            timelineTodos.forEach(todo => {
                if (Array.isArray(todo.user_id)) {
                    todo.user_id.forEach(userId => allUserIds.add(userId));
                } else if (todo.user_id) {
                    allUserIds.add(todo.user_id);
                }
            });
            
            const uniqueUsers = Array.from(allUserIds);
            const userProfileMap = {};
            
            // ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ Î®ºÏ†Ä Í∞ÄÏ†∏Ïò§Í∏∞
            await Promise.all(
                uniqueUsers.map(async (userId) => {
                    try {
                        const res = await fetch(`http://localhost:8008/users/${userId}/profile`);
                        if (!res.ok) {
                            console.error(`Failed to fetch profile for user ${userId}. Status: ${res.status}`);
                            userProfileMap[userId] = '/default_profile.png';
                            return;
                        }
                        const data = await res.json(); 
                        if (data && data.profile_image_url) {
                            userProfileMap[userId] = data.profile_image_url;
                        } else {
                            console.warn(`Profile image URL not found for user ${userId}`);
                            userProfileMap[userId] = '/default_profile.png';
                        }
                    } catch (error) {
                        console.error(`Error fetching profile for user ${userId}:`, error);
                        userProfileMap[userId] = '/default_profile.png';
                    }
                })
            );

            // ÎÇ¥Í∞Ä Ìè¨Ìï®Îêú Ìï† ÏùºÎßå ÌïÑÌÑ∞ÎßÅ
            const myTodos = timelineTodos.filter(todo => {
                const assignees = Array.isArray(todo.user_id) ? todo.user_id : [todo.user_id];
                return assignees.includes(username);
            });

            // Í∑∏Î£π ÏÉùÏÑ± (ÎÇ¥Í∞Ä Ìè¨Ìï®Îêú Ìï† ÏùºÏùò Î™®Îì† Îã¥ÎãπÏûê)
            const groupUsers = new Set();
            myTodos.forEach(todo => {
                const assignees = Array.isArray(todo.user_id) ? todo.user_id : [todo.user_id];
                assignees.forEach(userId => groupUsers.add(userId));
            });

            const groupData = Array.from(groupUsers).map((user, idx) => ({
                id: user,
                content: user,
                value: idx + 1,
                className: 'groupStyle',
            }));
            setGroups(new DataSet(groupData));

            // MODIFIED: Í∞Å Îã¥ÎãπÏûêÎ≥ÑÎ°ú Î≥ÑÎèÑÏùò ÌÉÄÏûÑÎùºÏù∏ ÏïÑÏù¥ÌÖú ÏÉùÏÑ±
            const mappedItems = [];
            myTodos
                .filter(todo => todo.deadline)
                .forEach(todo => {
                    const start = new Date(todo.start_day || todo.deadline);
                    const end = new Date(todo.deadline);
                    end.setDate(end.getDate());
                    
                    // Îã¥ÎãπÏûê Î∞∞Ïó¥ Ï≤òÎ¶¨
                    const assignees = Array.isArray(todo.user_id) ? todo.user_id : [todo.user_id];
                    
                    // Î™®Îì† Îã¥ÎãπÏûêÏùò ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ ÏàòÏßë
                    const assigneeProfiles = assignees.map(userId => ({
                        userId,
                        profileUrl: userProfileMap[userId] || '/default_profile.png'
                    }));

                    // Í∞Å Îã¥ÎãπÏûêÎ≥ÑÎ°ú Î≥ÑÎèÑÏùò ÏïÑÏù¥ÌÖú ÏÉùÏÑ±
                    assignees.forEach((assignee, index) => {
                        mappedItems.push({
                            id: `${todo.id}_${assignee}`, // Í≥†Ïú† ID ÏÉùÏÑ±
                            original_id: todo.id, // ÏõêÎ≥∏ Ìï† Ïùº ID Î≥¥Ï°¥
                            start,
                            end,
                            group: assignee, // Í∞Å Îã¥ÎãπÏûêÎ•º Í∑∏Î£πÏúºÎ°ú ÏÑ§Ï†ï
                            content: todo.text,
                            className: `item-common ${getGroupColorClass(assignee)}`,
                            editable: true,
                            assignee_profiles: assigneeProfiles, // Î™®Îì† Îã¥ÎãπÏûê ÌîÑÎ°úÌïÑ Ï†ïÎ≥¥
                            assignees: assignees, // Îã¥ÎãπÏûê ID Î™©Î°ù
                            todo_data: todo // ÏõêÎ≥∏ Ìï† Ïùº Îç∞Ïù¥ÌÑ∞ Î≥¥Ï°¥
                        });
                    });
                });
            
            setTimelineItems(new DataSet(mappedItems));
        };
        
        fetchProfilesAndSetItems();
    }, [timelineTodos, username]);
// 3. ÏßÑÌñâÎèÑ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (Ï∂îÍ∞Ä)
    useEffect(() => {
        const fetchProgress = async () => {
            const progressData = {};
            for (const todo of timelineTodos) {
                try {
                    const res = await fetch(`http://localhost:8008/todos/${todo.id}/progress`);
                    if (res.ok) {
                        const data = await res.json();
                        progressData[todo.id] = data.progress || 0;
                    }
                } catch (error) {
                    console.error(`ÏßÑÌñâÎèÑ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå® (${todo.id}):`, error);
                    progressData[todo.id] = 0;
                }
            }
            setTodoProgress(progressData);
        };

        if (timelineTodos.length > 0) {
            fetchProgress();
        }
    }, [timelineTodos]);

// 4. ÌÉÄÏûÑÎùºÏù∏ ÏòµÏÖò Î†åÎçîÎßÅ (ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ)
    useEffect(() => {
        if (!timelineRef.current) return;
        if (timelineItems.length === 0 || groups.length === 0) return;
        
        const today = new Date();
        const options = {
            groupOrder: 'content',
            editable: {
                updateTime: true,
                updateGroup: false,
                overrideItems: false,
                add: false,
            },
            orientation: 'top',
            margin: { item: 30, axis: 50 },
            zoomable: true,
            zoomKey: 'ctrlKey',
            itemsAlwaysDraggable: false,
            stack: true,
            groupHeightMode: 'auto',
            start: new Date(today.getTime() - 1000 * 60 * 60 * 24 * 2), 
            end: new Date(today.getTime() + 1000 * 60 * 60 * 24 * 2),   
            groupTemplate: (group) => {
                if (!group) return null;
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.alignItems = 'center';
                container.style.justifyContent = 'space-between';
                container.style.padding = '5px';
                container.style.minHeight = group.minHeight || '180px'; 
                
                const label = document.createElement('span');
                label.innerHTML = group.content;
                container.appendChild(label);

                const toggleButton = document.createElement('button');
                toggleButton.innerHTML = group.visible !== false ? 'x' : 'ÌéºÏπòÍ∏∞';
                toggleButton.style.fontSize = '1rem';
                toggleButton.style.fontFamily = 'pretendard-bold';
                toggleButton.style.cursor = 'pointer';
                toggleButton.style.backgroundColor = 'transparent';
                toggleButton.style.color = 'black';  
                toggleButton.style.border = 'none';
                toggleButton.style.position = 'absolute';
                toggleButton.style.marginBottom = '170px';
                toggleButton.style.transform = 'translateX(65px)';
                toggleButton.style.zIndex = '111';
                toggleButton.addEventListener('click', () => {
                    groups.update({ id: group.id, visible: group.visible !== false ? false : true });
                });
                container.appendChild(toggleButton);
                return container;
            },
            timeAxis: { scale: 'day', step: 1 },
            format: {
                minorLabels: { day: 'MÏõî DÏùº' },
                majorLabels: { day: '' },
            },
            zoomMin: 1000 * 60 * 60 * 24 * 5, 
            zoomMax: 1000 * 60 * 60 * 24 * 30,  
            dataAttributes: ['id'],
            
            // ÌÉÄÏûÑÎùºÏù∏ ÏïÑÏù¥ÌÖú ÌÖúÌîåÎ¶ø
            template: function (item) {
                // FIXED: original_idÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏßÑÌñâÎèÑ Í∞ÄÏ†∏Ïò§Í∏∞
                const progress = todoProgress[item.original_id] || 0;
                
                // Îã¥ÎãπÏûê ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄÎì§ ÏÉùÏÑ±
                let profileImagesHtml = '';
                if (item.assignee_profiles && item.assignee_profiles.length > 0) {
                    profileImagesHtml = item.assignee_profiles.map(profile => 
                        `<img src="${profile.profileUrl}" class="timeline-avatar" data-user="${profile.userId}" title="${profile.userId}"/>`
                    ).join('');
                }
                
                const html = '<div class="timeline-card">' +
                    '<div class="timeline-divider" data-progress="' + progress + '"></div>' +
                    '<div class="timeline-title">' + item.content + '</div>' +
                    '<div class="timeline-avatars">' + profileImagesHtml + '</div>' +
                    '</div>';
                return html;
            },

            onMove: (item, callback) => {
                const dontShowExpire = localStorage.getItem('dontShowMoveModal');
                if (dontShowExpire && Date.now() < Number(dontShowExpire)) {
                    handleMoveConfirm(item, callback);
                    return;
                }
                setPendingMove({ item, callback });
                setShowCancelModal(true);
            },
        };
        console.log('todoProgress', todoProgress);

        const timeline = new Timeline(timelineRef.current, timelineItems, groups, options);          
        
        timeline.on('doubleClick', (properties) => {
            if (properties.item) {
                const item = timelineItems.get(properties.item);
                setTodoEditModal({
                    isOpen: true,
                    todoId: item.original_id || item.id // ÏõêÎ≥∏ ID ÏÇ¨Ïö©
                });
            }
        });

        // ÌÉÄÏûÑÎùºÏù∏ Î†åÎçîÎßÅ ÌõÑ Ïä§ÌÉÄÏùº Ï†ÅÏö©
        setTimeout(() => {
            const itemContents = timelineRef.current.querySelectorAll('.vis-item-content');
            itemContents.forEach(content => {
                const divider = content.querySelector('.timeline-divider');
                if (divider) {
                    // Í∏∞Ï°¥Ïóê progressContainerÍ∞Ä ÏûàÏúºÎ©¥ Ï†úÍ±∞
                    const existing = divider.querySelector('.progress-bar-fill');
                    if (existing) divider.removeChild(existing.parentElement);
        
                    const progress = parseInt(divider.getAttribute('data-progress')) || 0;
                    divider.style.cssText = `
                        width: 100px;
                        height: 50.5px;
                        background: #f0f0f0;
                        margin-bottom: 4px;
                        margin-top: 2px;
                        border-radius: 4px;
                        position: relative;
                        overflow: hidden;
                        border: 1px solid #ddd;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    // ÏßÑÌñâÎèÑ Î∞î ÏÑ§Ï†ï
                    const progressContainer = document.createElement('div');
                    progressContainer.style.cssText = `
                        width: 100%;
                        height: 100%;
                        position: relative;
                        display: flex;
                        flex-direction: row;
                        align-items: center;
                        justify-content: flex-start;
                    `;
        
                    const progressFill = document.createElement('div');
                    progressFill.className = 'progress-bar-fill';
                    progressFill.style.cssText = `
                        height: 100%;
                        width: ${progress}%;
                        background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
                        transition: width 0.3s ease-in-out;
                        border-radius: 3px 0 0 3px;
                        position: relative;
                    `;
        
                    const progressText = document.createElement('span');
                    progressText.className = 'progress-text';
                    progressText.textContent = `${progress}%`;
                    progressText.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 10px;
                        font-weight: bold;
                        font-family: "Pretendard-SemiBold";
                        color: #333;
                        text-shadow: 1px 1px 1px rgba(255,255,255,0.8);
                        z-index: 2;
                        pointer-events: none;
                    `;
        
                    progressContainer.appendChild(progressFill);
                    divider.appendChild(progressContainer);
                    divider.appendChild(progressText);
                }
            });
        }, 100);
        
        
        // ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ Ïò§Î•ò Ï≤òÎ¶¨
        setTimeout(() => {
            const images = timelineRef.current.querySelectorAll('.timeline-avatar');
            images.forEach(img => {
                img.onerror = async function(e) {
                    const userId = e.target.dataset.user;
                    try {
                        const res = await fetch(`http://localhost:8008/users/${userId}/profile`);
                        if (res.ok) {
                            const data = await res.json();
                            e.target.src = data.profile_image_url || '/default_profile.png';
                        } else {
                            e.target.src = '/default_profile.png';
                        }
                    } catch {
                        e.target.src = '/default_profile.png';
                    }
                };
            });
        }, 200);

        timeline.on('ready', () => {
            setTimeout(() => {
                window.scrollTo(0, 0);
                document.documentElement.scrollTop = 0;
                document.body.scrollTop = 0;
            }, 100);
        });

        return () => timeline.destroy();
    }, [timelineItems, groups, todoProgress, username]);




//ÏòÆÍ∏∏Îïå Í≤ΩÍ≥† Î™®Îã¨
    const [showCancelModal, setShowCancelModal] = useState(false);
    const [dontShowAgain, setDontShowAgain] = useState(false);
    const handleDontShowAgainChange = (e) => {
        setDontShowAgain(e.target.checked);
        if (e.target.checked) {
            const expireAt = Date.now() + 24 * 60 * 60 * 1000;
            localStorage.setItem('dontShowMoveModal', expireAt);
        } else {
            localStorage.removeItem('dontShowMoveModal');
        }
    };
    
    const handleConfirm = async () => {
        setShowCancelModal(false);
        if (pendingAction) {
            await pendingAction();
            setPendingAction(null);
        }
        if (!pendingMove) return;
        await handleMoveConfirm(pendingMove.item, pendingMove.callback);
        setPendingMove(null);
    };
    const handleCancel = () => {
        setShowCancelModal(false);
        setPendingAction(null);
        if (pendingMove && pendingMove.callback) {
            pendingMove.callback(null); 
        }
        setPendingMove(null);
    };
    const handleMoveConfirm = async (item, callback) => {
        try {
            const startDate = new Date(item.start);
            const endDate = new Date(item.end);
            endDate.setDate(endDate.getDate());
    
            const updates = {
                start_day: startDate.toISOString().split("T")[0],
                deadline: endDate.toISOString().split("T")[0]
            };
    
            // FIXED: original_id ÏÇ¨Ïö©
            const todoId = item.original_id || item.id;
            const res = await fetch(`http://localhost:8008/todos/${todoId}/schedule`, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(updates)
            });
    
            if (!res.ok) {
                const errorText = await res.text();
                console.error("DB Ï†ÄÏû• Ïã§Ìå®:", errorText);
                callback(null);
            } else {
                timelineItems.update(item);
                callback(item);
                handleShowAllGroups()
            }
        } catch (err) {
            console.error("ÏÑúÎ≤Ñ ÏóêÎü¨:", err);
            callback(null);
        }
    };
    const handleTodoEditClose = () => {
        setTodoEditModal({
            isOpen: false,
            todoId: null
        });
    };
    const handleTodoUpdate = () => {
        fetchTodos();
        fetchTimelineTodos();
    };

    /* ========================================================= */
    /* =================    ÌîºÎìúÎ∞± Í¥ÄÎ¶¨    ===================== */
    /* ========================================================= */
    const [folders, setFolders] = useState([]);
    const [showFeedbackPopup, setShowFeedbackPopup] = useState(false);
    const [shouldRefresh, setShouldRefresh] = useState(false);

    useEffect(() => {
        if (!projectInfoId) return;

        const fetchFiles = async () => {
            try {
                const response = await fetch(`http://localhost:8008/projects/${projectInfoId}/files`);
                if (response.ok) {
                    const data = await response.json();
                    const mappedFiles = data.map(file => ({
                        name: file.name,
                        createdAt: new Date(file.uploaded_at).toLocaleString(),
                        type: 'file',
                        image: 'fileIcon.png',
                        s3Url: file.s3_url,
                        size: file.size ?? 0
                    }));
                    setFolders(mappedFiles);
                }
            } catch (err) {
                console.error("ÏûëÏóÖÎ¨º ÌååÏùº Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:", err);
            }
        };

        fetchFiles();
        setShouldRefresh(false);
    }, [projectInfoId, shouldRefresh]);

    const handleMoreClick = () => {
        setShowFeedbackPopup(true);
    };

    const handleClosePopup = () => {
        setShowFeedbackPopup(false);
        setShouldRefresh(true);
    };


   //=====================================================================//
    // ------------------------   Ï±ó WebSocket ÏïàÏ†ïÌôî  ------------------------ //
    //=====================================================================//
    const [messages, setMessages] = useState([]);
    const [input, setInput] = useState('');
    const wsRef = useRef(null);
    const messagesEndRef = useRef(null);

    // ÌååÏùºÎ™Ö ÌÜ†Í∏Ä ÌëúÏãú Ïª¥Ìè¨ÎÑåÌä∏
    const ToggleNameDisplay = ({ name }) => {
        const [expanded, setExpanded] = useState(false);


    const [loginUserId, setLoginUserId] = useState(null);
    const [loginUserName, setLoginUserName] = useState(null);

    // JWT ÌååÏã± Ìï®Ïàò (ÏµúÏ¥à 1Ìöå ÌååÏã±)
    const decodeJWT = (token) => {
        if (!token) return {};
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            return {
                userId: payload.sub,
                userName: payload.name || payload.sub
            };
        } catch {
            return {};
        }
    };

    useEffect(() => {
        const token = localStorage.getItem("access_token");
        const { userId, userName } = decodeJWT(token);
        setLoginUserId(userId);
        setLoginUserName(userName);
    }, []);

    // ÏµúÏ¥à RedisÏóê Ï†ÄÏû•Îêú Ïù¥Ï†Ñ Î©îÏãúÏßÄ Î∂àÎü¨Ïò§Í∏∞
    useEffect(() => {
        if (!Pg_id || !loginUserId) return;

        const fetchPreviousMessages = async () => {
            try {
                const res = await fetch(`http://localhost:8008/livechat/${Pg_id}`);
                if (!res.ok) throw new Error("Ïù¥Ï†Ñ Ï±ÑÌåÖ Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®");


                const data = await res.json();
                const loadedMessages = data.map(msg => ({
                    ...msg,
                    sender: msg.sender_id === loginUserId ? "me" : "other",
                    name: msg.sender_name,
                    time: new Date(msg.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true })
                }));
                setMessages(loadedMessages);
            } catch (err) {
                console.error("Ïù¥Ï†Ñ Î©îÏãúÏßÄ Î∂àÎü¨Ïò§Í∏∞ ÏóêÎü¨:", err);
            }
        };

        fetchPreviousMessages();
    }, [Pg_id, loginUserId]);

    //  WebSocket Ïó∞Í≤∞ (loginUserId Ï§ÄÎπÑÎêú Ïù¥ÌõÑ Ïó∞Í≤∞)
    useEffect(() => {
        if (!Pg_id || !loginUserId) return;

        const ws = new WebSocket(`ws://localhost:8008/ws/livechat/${Pg_id}`);
        wsRef.current = ws;

        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            const newMessage = {
                ...msg,
                sender: msg.sender_id === loginUserId ? "me" : "other",
                name: msg.sender_name,
                time: new Date(msg.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true })
            };
            setMessages(prev => [...prev, newMessage]);
        };

        ws.onclose = () => console.log("WebSocket Closed");
        ws.onerror = (err) => console.error("WebSocket Error:", err);

        return () => {
            ws.close();
        };
    }, [Pg_id, loginUserId]);

    useEffect(() => {
        const ws = new WebSocket("ws://localhost:8008/ws/livechat/notification");

        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            console.log("üì¢ ÏïåÎ¶º ÎèÑÏ∞©:", msg);

            // Ïó¨Í∏∞Îäî ÏùºÎã® ÏΩòÏÜî Ï∞çÌûàÎäîÏßÄÎßå ÌôïÏù∏Ìï† Í≤É
            // Ïù¥ÌõÑ Ïó¨Í∏∞ÏÑú ÌåùÏóÖ ÎùÑÏö∞Îäî Î°úÏßÅ Ï∂îÍ∞Ä Í∞ÄÎä•
            alert(`üîî ÏÉà ÏïåÎ¶º: ${msg.type === "chat" ? "ÏÉàÎ°úÏö¥ Ï±ÑÌåÖÏù¥ ÎèÑÏ∞©ÌñàÏäµÎãàÎã§!" : "ÌååÏùºÏù¥ ÏóÖÎ°úÎìú ÎêòÏóàÏäµÎãàÎã§!"}`);
        };

        ws.onclose = () => console.log("ÏïåÎ¶º WebSocket Closed");

        return () => ws.close();
    }, []);



    //  Î©îÏãúÏßÄ Ï†ÑÏÜ°
    const sendMessage = () => {
        if (!input.trim() || !loginUserId || !loginUserName) return;

        const wsMessage = {
            sender_id: loginUserId,
            sender_name: loginUserName,
            text: input,
        };

        console.log("Î©îÏãúÏßÄ Ï†ÑÏÜ°:", wsMessage);
        wsRef.current?.send(JSON.stringify(wsMessage));
        setInput('');
    };

    //  Ïä§ÌÅ¨Î°§ ÏûêÎèô ÎÇ¥Î†§Í∞ÄÍ∏∞
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    //  Ïù¥Î¶Ñ ÌÜ†Í∏Ä
    const ToggleNameDisplay = ({ name }) => {
        const [expanded, setExpanded] = useState(false);
        return (
            <div className={`folderName ${expanded ? 'expanded' : ''}`}
                onClick={() => setExpanded(!expanded)}
                title={name}
            >
                {name}
            </div>
        );
    };


    //ÌîåÏ†ùÏïÑÏù¥ÎîîÏóÜÏùÑÎïå
    if (!Pg_id) {
        return (
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                height: '60vh',
                textAlign: 'center',
                color: '#666'
            }}>
                <h2 style={{ marginBottom: '20px', color: '#333' }}>
                    üìã ÌîÑÎ°úÏ†ùÌä∏Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî
                </h2>
                <p style={{ fontSize: '16px', lineHeight: '1.5' }}>
                    ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú ÌîÑÎ°úÏ†ùÌä∏Î•º ÏÑ†ÌÉùÌïòÎ©¥<br />
                    ÌîÑÎ°úÏ†ùÌä∏ Í¥ÄÎ¶¨ Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.
                </p>
            </div>
        );
    }





    /* ========================================================= */
    /* =================    Î©îÏù∏ Î†åÎçîÎßÅ    ==================== */
    /* ========================================================= */
    return (
        <div className="content">
            <div className="contentTitle">{projectName}</div>
            <div className="projectContent">
                {/* Í≥µÏßÄÏÇ¨Ìï≠ */}
                <div className="gonji box1">
                    <div className="gonjiIcon" onClick={() => setShowEmojiPicker(!showEmojiPicker)}>
                        {selectedEmoji.emoji}
                    </div>
                    {showEmojiPicker && <Picker onEmojiClick={handleEmojiSelect} />}
                    
                    {isLoading ? (
                        <div className="gonjiText">Î∂àÎü¨Ïò§Îäî Ï§ë...</div>
                    ) : error ? (
                        <div className="gonjiText" style={{ color: 'red' }}>{error}</div>
                    ) : isEditing ? (
                        <div className="editMode">
                            <input 
                                className="editInput"
                                value={tempContent}
                                onChange={(e) => setTempContent(e.target.value)}
                                placeholder='ÌòÑÏû¨ ÏàòÏ†ïÌïòÎäî Í≥µÏßÄÎäî Î™®ÎëêÍ∞Ä Î≥º Ïàò ÏûàÏäµÎãàÎã§.'
                            />
                            <div>
                            <button className="saveBtn" onClick={handleSaveClick}>Ï†ÄÏû•</button>
                            <button className="cancelBtn" onClick={handleCancelClick}>Ï∑®ÏÜå</button></div>
                        </div>
                    ) : (
                        <>

                        <div className="gonjiText">{notice}</div>

                        <div className="gonjiEdit">
                        <img 
                            src={Edit} 
                            alt="edit" 
                            onClick={handleEditClick} 
                            style={{ cursor: 'pointer', opacity: 0.8 }}
                        />
                    </div>

                    </>
                    )}


                </div>

                {/* Ï∫òÎ¶∞Îçî */}
                <div className="calendar box1">
                    <div className="calendarTop">
                        <div className="date">{currentMonth + 1}Ïõî</div>
                        <div className="temp">
                            <div className="moveBtn left" onClick={handleLeftWeek}>
                                <img src={leftBtn} alt="leftBtn" />
                            </div>
                            <div className="moveBtn right" onClick={handleRightWeek}>
                                <img src={rightBtn} alt="rightBtn" />
                            </div>
                        </div>
                    </div>
                    <div className="calendarMid">
                        {['ÏùºÏöîÏùº', 'ÏõîÏöîÏùº', 'ÌôîÏöîÏùº', 'ÏàòÏöîÏùº', 'Î™©ÏöîÏùº', 'Í∏àÏöîÏùº', 'ÌÜ†ÏöîÏùº'].map((day, index) => (
                            <div
                                key={index}
                                className={`day ${
                                    currentWeek[index] instanceof Date && currentWeek[index].toDateString() === today.toDateString() 
                                        ? 'activeCal' 
                                        : ''
                                }`}
                            >
                                {day}
                            </div>
                        ))}
                    </div>
                    <div className="calendarBot">
                        {currentWeek.map((date, index) => (
                            <div
                                key={index}
                                className={`day ${
                                    date instanceof Date && date.toDateString() === today.toDateString() 
                                        ? 'activeCal' 
                                        : ''
                                }`}
                            >
                                {date !== '_' ? date.getDate() : ''}
                                {date !== '_' && date.toDateString() === today.toDateString() && 
                                    <div className="calendarTodayDot">‚óè</div>
                                }
                            </div>
                        ))}
                    </div>
                </div>

                {/* Todo ÏÉÅÌÉú */}
                <div className="todoStatus box1">
                    <div className="object">
                        <div className="objectCount">{inProgressCount}</div>
                        <div className="objectTitle">ÏßÑÌñâÏ§ë</div>
                    </div>
                    <div className="object">
                        <div className="objectCount">{completedCount}</div>
                        <div className="objectTitle">ÏôÑÎ£å</div>
                    </div>
                    <div className="object">
                        <div className="objectCount">{waitingFeedbackCount}</div>
                        <div className="objectTitle">ÌîºÎìúÎ∞± ÎåÄÍ∏∞</div>
                    </div>
                    <div className="object">
                        <div className="objectCount">{totalCount}</div>
                        <div className="objectTitle">Ï†ÑÏ≤¥ Ìï† Ïùº</div>
                    </div>
                </div>

                {/* ÌÉÄÏûÑÎùºÏù∏ */}
                <div className="timeLine">
                    <div className="title">
                        ÌÉÄÏûÑÎùºÏù∏ 
                        <img onClick={handleShowAllGroups} id="showAllGroup" src={rechange} alt="Î™®ÎëêÎ≥¥Í∏∞" />
                    </div>
                    <div style={{ height: '475px', overflowY: 'auto' }}>
                        <div ref={timelineRef} className="vis-timeline-container" />
                    </div>
                </div>

                {/* Todo Ïπ∏Î∞ò */}
                <div className="todoList">
                    <div className="top">
                        <div className="title">Ìï† Ïùº Î™©Î°ù</div>
                    </div>
                    <div className="content-todo">
                        <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                            <div className="todo-board">
                                <TodoColumn 
                                    title="ÏßÑÌñâÏ§ë" 
                                    items={todos.inProgress} 
                                    status="inProgress"
                                    onDetail={() => setShowDetail({ open: true, status: "inProgress" })}
                                />
                                <TodoColumn 
                                    title="ÏôÑÎ£å" 
                                    items={todos.completed} 
                                    status="completed" 
                                    onDetail={() => setShowDetail({ open: true, status: "completed" })}
                                />
                                <TodoColumn 
                                    title="ÌîºÎìúÎ∞± ÎåÄÍ∏∞Ï§ë" 
                                    items={todos.feedbackPending} 
                                    status="feedbackPending"
                                    onDetail={() => setShowDetail({ open: true, status: "feedbackPending" })}
                                />
                            </div>
                        </DndContext>
                    </div>
                </div>

                {/* Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ */}
                <div className="liveChat">
                    <div className="title">Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ</div>
                    <div className="content box1">
                        <div className="chatMessages">
                            {messages.map((msg, idx) => (
                                <div key={idx} className={`chatMessageWrapper ${msg.sender}`}>
                                    {msg.sender === 'other' && (
                                        <div className="chatRow">
                                            <div className="chatProfileDot other" />
                                            <div>
                                                <div className="chatMeta">
                                                    <span className="chatName">{msg.name}</span>
                                                    <span className="chatTimeLeft">{msg.time}</span>
                                                </div>
                                                <div className="chatBubble other">{msg.text}</div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    {msg.sender === 'me' && (
                                        <div className="chatRow me">
                                            <div className="chatBubbleTimeGroup">
                                                <div className="chatBubble me">{msg.text}</div>
                                                <div className="chatTimeRight">{msg.time}</div>
                                            </div>
                                            <div className="chatProfileDot me" />
                                        </div>
                                    )}
                                </div>
                            ))}
                            <div ref={messagesEndRef} />
                        </div>

                        <div className="chatInputArea">
                            <img src={pencilIcon} alt="ÏûÖÎ†•" className="pencilIcon" />
                            <input 
                                type="text" 
                                value={input} 
                                onChange={(e) => setInput(e.target.value)} 
                                onKeyDown={(e) => e.key === "Enter" && sendMessage()}
                                placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
                            />
                            <button onClick={sendMessage}>
                                <img src={sendIcon} alt="Ï†ÑÏÜ°" />
                            </button>
                        </div>
                    </div>
                </div>

                {/* ÏûëÏóÖÎ¨º ÌîºÎìúÎ∞± */}
                <div className="feedback">
                    <div className="top">
                        <div className="title">ÏûëÏóÖÎ¨º ÌîºÎìúÎ∞±</div>
                        <div className="more" onClick={handleMoreClick}>ÎçîÎ≥¥Í∏∞</div>
                    </div>
                    <div className="content-feedback box1">
                        <div className="folderPreview">
                            {folders.slice(0, 6).map((folder, index) => (
                                <div key={index} className={`folderPreSee ${folder.type}PreSee`}>
                                    <div className="folderDate">{folder.createdAt}</div>
                                    <div className="fileItem">
                                        <img src="/fileIcon.png" className="folderIcon" alt="File Icon" />
                                        <ToggleNameDisplay name={folder.name} />
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>

            {/* Î™®Îã¨Îì§ */}
            {showCancelModal && (
                <>
                    <div className="modal_overlay"></div>
                    <div className="modal_Pc">
                        <div className="modal_emoji">üò∂</div>
                        <div className="modal_realMsg">
                            {modal_realMsg || 'Ï†ïÎßê ÏùºÏ†ïÏùÑ ÏòÆÍ∏∞ÏãúÍ≤†ÏäµÎãàÍπå?'}
                        </div>
                        <div className="modal-buttons_Pc">
                            <button onClick={handleCancel}>Ï∑®ÏÜå</button>
                            <button onClick={handleConfirm}>ÎÑ§</button>
                        </div>
                        <label className="modal_dontShow">
                            <input
                                type="checkbox"
                                checked={dontShowAgain}
                                onChange={handleDontShowAgainChange}
                            />
                            Îã§Ïãú Î≥¥ÏßÄ ÏïäÍ∏∞ (24ÏãúÍ∞Ñ)
                        </label>
                    </div>
                </>
            )}

            <TodoEditModal
                isOpen={todoEditModal.isOpen}
                onClose={handleTodoEditClose}
                todoId={todoEditModal.todoId}
                onUpdate={handleTodoUpdate}
                projectId={Pg_id}
            />

            {showDetail.open && (
                <TodoMorePopup
                    status={showDetail.status}
                    projectId={Pg_id}
                    todos={todos}
                    onClose={() => setShowDetail({ open: false, status: null })}
                    onUpdate={handleTodoUpdate}
                />
            )}

            {showFeedbackPopup && (
                <FeedbackPopup 
                    onClose={handleClosePopup} 
                    username={username} 
                    projectId={projectInfoId}
                    onUpdate={handleTodoUpdate}
                />
            )}
        </div>
    );
};

export default ProjectContent;
