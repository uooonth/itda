import { jsx as U, jsxs as Ve } from "react/jsx-runtime";
import se, { createElement as Rt, useContext as wi, Component as xe, createRef as Si, PureComponent as ws } from "react";
function Hn(s) {
  let i = 0, a = 0, u = !0;
  for (; s; )
    !s.offsetParent && s.tagName === "BODY" && s.scrollLeft === 0 && s.scrollTop === 0 && (s = document.scrollingElement || s), i += s.offsetLeft - (u ? 0 : s.scrollLeft) + s.clientLeft, a += s.offsetTop - (u ? 0 : s.scrollTop) + s.clientTop, s = s.offsetParent, u = !1;
  return { x: i, y: a };
}
function jt(s) {
  if (s === document.body)
    return { scrollLeft: 0, scrollTop: 0 };
  {
    const i = jt(s.parentNode);
    return {
      scrollLeft: s.scrollLeft + i.scrollLeft,
      scrollTop: s.scrollTop + i.scrollTop
    };
  }
}
function At(s) {
  if (s === document.body || !s.offsetParent)
    return { offsetLeft: 0, offsetTop: 0 };
  {
    const i = At(s.offsetParent);
    return {
      offsetLeft: s.offsetLeft + i.offsetLeft,
      offsetTop: s.offsetTop + i.offsetTop
    };
  }
}
var We = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ze(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var Lt = { exports: {} };
Lt.exports;
(function(s, i) {
  (function(a, u) {
    s.exports = u();
  })(We, function() {
    function a(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(o) {
          return Object.getOwnPropertyDescriptor(t, o).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function u(t) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? a(Object(r), !0).forEach(function(n) {
          x(t, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : a(Object(r)).forEach(function(n) {
          Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return t;
    }
    function f(t) {
      return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e;
      } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      }, f(t);
    }
    function v(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }
    function m(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, C(n.key), n);
      }
    }
    function y(t, e, r) {
      return e && m(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
    }
    function x(t, e, r) {
      return (e = C(e)) in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
    }
    function O(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && P(t, e);
    }
    function $(t) {
      return $ = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      }, $(t);
    }
    function P(t, e) {
      return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
        return r.__proto__ = n, r;
      }, P(t, e);
    }
    function T(t) {
      if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t;
    }
    function _(t) {
      var e = function() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), !0;
        } catch {
          return !1;
        }
      }();
      return function() {
        var r, n = $(t);
        if (e) {
          var o = $(this).constructor;
          r = Reflect.construct(n, arguments, o);
        } else r = n.apply(this, arguments);
        return function(l, c) {
          if (c && (typeof c == "object" || typeof c == "function")) return c;
          if (c !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
          return T(l);
        }(this, r);
      };
    }
    function M() {
      return M = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(t, e, r) {
        var n = function(l, c) {
          for (; !Object.prototype.hasOwnProperty.call(l, c) && (l = $(l)) !== null; ) ;
          return l;
        }(t, e);
        if (n) {
          var o = Object.getOwnPropertyDescriptor(n, e);
          return o.get ? o.get.call(arguments.length < 3 ? t : r) : o.value;
        }
      }, M.apply(this, arguments);
    }
    function C(t) {
      var e = function(r, n) {
        if (typeof r != "object" || r === null) return r;
        var o = r[Symbol.toPrimitive];
        if (o !== void 0) {
          var l = o.call(r, n);
          if (typeof l != "object") return l;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(r);
      }(t, "string");
      return typeof e == "symbol" ? e : e + "";
    }
    var z = function(t) {
      return !(!t || !t.Window) && t instanceof t.Window;
    }, N = void 0, G = void 0;
    function Q(t) {
      N = t;
      var e = t.document.createTextNode("");
      e.ownerDocument !== t.document && typeof t.wrap == "function" && t.wrap(e) === e && (t = t.wrap(t)), G = t;
    }
    function te(t) {
      return z(t) ? t : (t.ownerDocument || t).defaultView || G.window;
    }
    typeof window < "u" && window && Q(window);
    var re = function(t) {
      return !!t && f(t) === "object";
    }, ue = function(t) {
      return typeof t == "function";
    }, S = { window: function(t) {
      return t === G || z(t);
    }, docFrag: function(t) {
      return re(t) && t.nodeType === 11;
    }, object: re, func: ue, number: function(t) {
      return typeof t == "number";
    }, bool: function(t) {
      return typeof t == "boolean";
    }, string: function(t) {
      return typeof t == "string";
    }, element: function(t) {
      if (!t || f(t) !== "object") return !1;
      var e = te(t) || G;
      return /object|function/.test(typeof Element > "u" ? "undefined" : f(Element)) ? t instanceof Element || t instanceof e.Element : t.nodeType === 1 && typeof t.nodeName == "string";
    }, plainObject: function(t) {
      return re(t) && !!t.constructor && /function Object\b/.test(t.constructor.toString());
    }, array: function(t) {
      return re(t) && t.length !== void 0 && ue(t.splice);
    } };
    function be(t) {
      var e = t.interaction;
      if (e.prepared.name === "drag") {
        var r = e.prepared.axis;
        r === "x" ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : r === "y" && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0);
      }
    }
    function we(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "drag") {
        var n = r.prepared.axis;
        if (n === "x" || n === "y") {
          var o = n === "x" ? "y" : "x";
          e.page[o] = r.coords.start.page[o], e.client[o] = r.coords.start.client[o], e.delta[o] = 0;
        }
      }
    }
    var ce = { id: "actions/drag", install: function(t) {
      var e = t.actions, r = t.Interactable, n = t.defaults;
      r.prototype.draggable = ce.draggable, e.map.drag = ce, e.methodDict.drag = "draggable", n.actions.drag = ce.defaults;
    }, listeners: { "interactions:before-action-move": be, "interactions:action-resume": be, "interactions:action-move": we, "auto-start:check": function(t) {
      var e = t.interaction, r = t.interactable, n = t.buttons, o = r.options.drag;
      if (o && o.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || n & r.options.drag.mouseButtons)) return t.action = { name: "drag", axis: o.lockAxis === "start" ? o.startAxis : o.lockAxis }, !1;
    } }, draggable: function(t) {
      return S.object(t) ? (this.options.drag.enabled = t.enabled !== !1, this.setPerAction("drag", t), this.setOnEvents("drag", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : S.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag;
    }, beforeMove: be, move: we, defaults: { startAxis: "xy", lockAxis: "xy" }, getCursor: function() {
      return "move";
    }, filterEventType: function(t) {
      return t.search("drag") === 0;
    } }, ne = ce, de = { init: function(t) {
      var e = t;
      de.document = e.document, de.DocumentFragment = e.DocumentFragment || Ee, de.SVGElement = e.SVGElement || Ee, de.SVGSVGElement = e.SVGSVGElement || Ee, de.SVGElementInstance = e.SVGElementInstance || Ee, de.Element = e.Element || Ee, de.HTMLElement = e.HTMLElement || de.Element, de.Event = e.Event, de.Touch = e.Touch || Ee, de.PointerEvent = e.PointerEvent || e.MSPointerEvent;
    }, document: null, DocumentFragment: null, SVGElement: null, SVGSVGElement: null, SVGElementInstance: null, Element: null, HTMLElement: null, Event: null, Touch: null, PointerEvent: null };
    function Ee() {
    }
    var W = de, k = { init: function(t) {
      var e = W.Element, r = t.navigator || {};
      k.supportsTouch = "ontouchstart" in t || S.func(t.DocumentTouch) && W.document instanceof t.DocumentTouch, k.supportsPointerEvent = r.pointerEnabled !== !1 && !!W.PointerEvent, k.isIOS = /iP(hone|od|ad)/.test(r.platform), k.isIOS7 = /iP(hone|od|ad)/.test(r.platform) && /OS 7[^\d]/.test(r.appVersion), k.isIe9 = /MSIE 9/.test(r.userAgent), k.isOperaMobile = r.appName === "Opera" && k.supportsTouch && /Presto/.test(r.userAgent), k.prefixedMatchesSelector = "matches" in e.prototype ? "matches" : "webkitMatchesSelector" in e.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in e.prototype ? "mozMatchesSelector" : "oMatchesSelector" in e.prototype ? "oMatchesSelector" : "msMatchesSelector", k.pEventTypes = k.supportsPointerEvent ? W.PointerEvent === t.MSPointerEvent ? { up: "MSPointerUp", down: "MSPointerDown", over: "mouseover", out: "mouseout", move: "MSPointerMove", cancel: "MSPointerCancel" } : { up: "pointerup", down: "pointerdown", over: "pointerover", out: "pointerout", move: "pointermove", cancel: "pointercancel" } : null, k.wheelEvent = W.document && "onmousewheel" in W.document ? "mousewheel" : "wheel";
    }, supportsTouch: null, supportsPointerEvent: null, isIOS7: null, isIOS: null, isIe9: null, isOperaMobile: null, prefixedMatchesSelector: null, pEventTypes: null, wheelEvent: null }, R = k;
    function F(t, e) {
      if (t.contains) return t.contains(e);
      for (; e; ) {
        if (e === t) return !0;
        e = e.parentNode;
      }
      return !1;
    }
    function A(t, e) {
      for (; S.element(t); ) {
        if (X(t, e)) return t;
        t = K(t);
      }
      return null;
    }
    function K(t) {
      var e = t.parentNode;
      if (S.docFrag(e)) {
        for (; (e = e.host) && S.docFrag(e); ) ;
        return e;
      }
      return e;
    }
    function X(t, e) {
      return G !== N && (e = e.replace(/\/deep\//g, " ")), t[R.prefixedMatchesSelector](e);
    }
    var ie = function(t) {
      return t.parentNode || t.host;
    };
    function ae(t, e) {
      for (var r, n = [], o = t; (r = ie(o)) && o !== e && r !== o.ownerDocument; ) n.unshift(o), o = r;
      return n;
    }
    function pe(t, e, r) {
      for (; S.element(t); ) {
        if (X(t, e)) return !0;
        if ((t = K(t)) === r) return X(t, e);
      }
      return !1;
    }
    function he(t) {
      return t.correspondingUseElement || t;
    }
    function ve(t) {
      var e = t instanceof W.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0];
      return e && { left: e.left, right: e.right, top: e.top, bottom: e.bottom, width: e.width || e.right - e.left, height: e.height || e.bottom - e.top };
    }
    function Oe(t) {
      var e, r = ve(t);
      if (!R.isIOS7 && r) {
        var n = { x: (e = (e = te(t)) || G).scrollX || e.document.documentElement.scrollLeft, y: e.scrollY || e.document.documentElement.scrollTop };
        r.left += n.x, r.right += n.x, r.top += n.y, r.bottom += n.y;
      }
      return r;
    }
    function Ce(t) {
      for (var e = []; t; ) e.push(t), t = K(t);
      return e;
    }
    function ke(t) {
      return !!S.string(t) && (W.document.querySelector(t), !0);
    }
    function H(t, e) {
      for (var r in e) t[r] = e[r];
      return t;
    }
    function fe(t, e, r) {
      return t === "parent" ? K(r) : t === "self" ? e.getRect(r) : A(r, t);
    }
    function ye(t, e, r, n) {
      var o = t;
      return S.string(o) ? o = fe(o, e, r) : S.func(o) && (o = o.apply(void 0, n)), S.element(o) && (o = Oe(o)), o;
    }
    function _e(t) {
      return t && { x: "x" in t ? t.x : t.left, y: "y" in t ? t.y : t.top };
    }
    function ze(t) {
      return !t || "x" in t && "y" in t || ((t = H({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t;
    }
    function mt(t, e, r) {
      t.left && (e.left += r.x), t.right && (e.right += r.x), t.top && (e.top += r.y), t.bottom && (e.bottom += r.y), e.width = e.right - e.left, e.height = e.bottom - e.top;
    }
    function it(t, e, r) {
      var n = r && t.options[r];
      return _e(ye(n && n.origin || t.options.origin, t, e, [t && e])) || { x: 0, y: 0 };
    }
    function Ue(t, e) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(h) {
        return !0;
      }, n = arguments.length > 3 ? arguments[3] : void 0;
      if (n = n || {}, S.string(t) && t.search(" ") !== -1 && (t = Br(t)), S.array(t)) return t.forEach(function(h) {
        return Ue(h, e, r, n);
      }), n;
      if (S.object(t) && (e = t, t = ""), S.func(e) && r(t)) n[t] = n[t] || [], n[t].push(e);
      else if (S.array(e)) for (var o = 0, l = e; o < l.length; o++) {
        var c = l[o];
        Ue(t, c, r, n);
      }
      else if (S.object(e)) for (var p in e)
        Ue(Br(p).map(function(h) {
          return "".concat(t).concat(h);
        }), e[p], r, n);
      return n;
    }
    function Br(t) {
      return t.trim().split(/ +/);
    }
    var ot = function(t, e) {
      return Math.sqrt(t * t + e * e);
    }, ao = ["webkit", "moz"];
    function bt(t, e) {
      t.__set || (t.__set = {});
      var r = function(o) {
        if (ao.some(function(l) {
          return o.indexOf(l) === 0;
        })) return 1;
        typeof t[o] != "function" && o !== "__set" && Object.defineProperty(t, o, { get: function() {
          return o in t.__set ? t.__set[o] : t.__set[o] = e[o];
        }, set: function(l) {
          t.__set[o] = l;
        }, configurable: !0 });
      };
      for (var n in e) r(n);
      return t;
    }
    function yt(t, e) {
      t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp;
    }
    function Vr(t) {
      t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0;
    }
    function qr(t) {
      return t instanceof W.Event || t instanceof W.Touch;
    }
    function Tt(t, e, r) {
      return t = t || "page", (r = r || {}).x = e[t + "X"], r.y = e[t + "Y"], r;
    }
    function Zr(t, e) {
      return e = e || { x: 0, y: 0 }, R.isOperaMobile && qr(t) ? (Tt("screen", t, e), e.x += window.scrollX, e.y += window.scrollY) : Tt("page", t, e), e;
    }
    function st(t) {
      return S.number(t.pointerId) ? t.pointerId : t.identifier;
    }
    function lo(t, e, r) {
      var n = e.length > 1 ? Jr(e) : e[0];
      Zr(n, t.page), function(o, l) {
        l = l || {}, R.isOperaMobile && qr(o) ? Tt("screen", o, l) : Tt("client", o, l);
      }(n, t.client), t.timeStamp = r;
    }
    function Jt(t) {
      var e = [];
      return S.array(t) ? (e[0] = t[0], e[1] = t[1]) : t.type === "touchend" ? t.touches.length === 1 ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : t.touches.length === 0 && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e;
    }
    function Jr(t) {
      for (var e = { pageX: 0, pageY: 0, clientX: 0, clientY: 0, screenX: 0, screenY: 0 }, r = 0; r < t.length; r++) {
        var n = t[r];
        for (var o in e) e[o] += n[o];
      }
      for (var l in e) e[l] /= t.length;
      return e;
    }
    function Qt(t) {
      if (!t.length) return null;
      var e = Jt(t), r = Math.min(e[0].pageX, e[1].pageX), n = Math.min(e[0].pageY, e[1].pageY), o = Math.max(e[0].pageX, e[1].pageX), l = Math.max(e[0].pageY, e[1].pageY);
      return { x: r, y: n, left: r, top: n, right: o, bottom: l, width: o - r, height: l - n };
    }
    function er(t, e) {
      var r = e + "X", n = e + "Y", o = Jt(t), l = o[0][r] - o[1][r], c = o[0][n] - o[1][n];
      return ot(l, c);
    }
    function tr(t, e) {
      var r = e + "X", n = e + "Y", o = Jt(t), l = o[1][r] - o[0][r], c = o[1][n] - o[0][n];
      return 180 * Math.atan2(c, l) / Math.PI;
    }
    function Qr(t) {
      return S.string(t.pointerType) ? t.pointerType : S.number(t.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][t.pointerType] : /touch/.test(t.type || "") || t instanceof W.Touch ? "touch" : "mouse";
    }
    function en(t) {
      var e = S.func(t.composedPath) ? t.composedPath() : t.path;
      return [he(e ? e[0] : t.target), he(t.currentTarget)];
    }
    var wt = function() {
      function t(e) {
        v(this, t), this.immediatePropagationStopped = !1, this.propagationStopped = !1, this._interaction = e;
      }
      return y(t, [{ key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }]), t;
    }();
    Object.defineProperty(wt.prototype, "interaction", { get: function() {
      return this._interaction._proxy;
    }, set: function() {
    } });
    var tn = function(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        t.push(n);
      }
      return t;
    }, rn = function(t) {
      return tn([], t);
    }, at = function(t, e) {
      for (var r = 0; r < t.length; r++) if (e(t[r], r, t)) return r;
      return -1;
    }, lt = function(t, e) {
      return t[at(t, e)];
    }, Xe = function(t) {
      O(r, t);
      var e = _(r);
      function r(n, o, l) {
        var c;
        v(this, r), (c = e.call(this, o._interaction)).dropzone = void 0, c.dragEvent = void 0, c.relatedTarget = void 0, c.draggable = void 0, c.propagationStopped = !1, c.immediatePropagationStopped = !1;
        var p = l === "dragleave" ? n.prev : n.cur, h = p.element, g = p.dropzone;
        return c.type = l, c.target = h, c.currentTarget = h, c.dropzone = g, c.dragEvent = o, c.relatedTarget = o.target, c.draggable = o.interactable, c.timeStamp = o.timeStamp, c;
      }
      return y(r, [{ key: "reject", value: function() {
        var n = this, o = this._interaction.dropState;
        if (this.type === "dropactivate" || this.dropzone && o.cur.dropzone === this.dropzone && o.cur.element === this.target) if (o.prev.dropzone = this.dropzone, o.prev.element = this.target, o.rejected = !0, o.events.enter = null, this.stopImmediatePropagation(), this.type === "dropactivate") {
          var l = o.activeDrops, c = at(l, function(h) {
            var g = h.dropzone, d = h.element;
            return g === n.dropzone && d === n.target;
          });
          o.activeDrops.splice(c, 1);
          var p = new r(o, this.dragEvent, "dropdeactivate");
          p.dropzone = this.dropzone, p.target = this.target, this.dropzone.fire(p);
        } else this.dropzone.fire(new r(o, this.dragEvent, "dragleave"));
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }]), r;
    }(wt);
    function nn(t, e) {
      for (var r = 0, n = t.slice(); r < n.length; r++) {
        var o = n[r], l = o.dropzone, c = o.element;
        e.dropzone = l, e.target = c, l.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1;
      }
    }
    function rr(t, e) {
      for (var r = function(l, c) {
        for (var p = [], h = 0, g = l.interactables.list; h < g.length; h++) {
          var d = g[h];
          if (d.options.drop.enabled) {
            var b = d.options.drop.accept;
            if (!(S.element(b) && b !== c || S.string(b) && !X(c, b) || S.func(b) && !b({ dropzone: d, draggableElement: c }))) for (var w = 0, I = d.getAllElements(); w < I.length; w++) {
              var E = I[w];
              E !== c && p.push({ dropzone: d, element: E, rect: d.getRect(E) });
            }
          }
        }
        return p;
      }(t, e), n = 0; n < r.length; n++) {
        var o = r[n];
        o.rect = o.dropzone.getRect(o.element);
      }
      return r;
    }
    function on(t, e, r) {
      for (var n = t.dropState, o = t.interactable, l = t.element, c = [], p = 0, h = n.activeDrops; p < h.length; p++) {
        var g = h[p], d = g.dropzone, b = g.element, w = g.rect, I = d.dropCheck(e, r, o, l, b, w);
        c.push(I ? b : null);
      }
      var E = function(D) {
        for (var L, j, Y, q = [], ee = 0; ee < D.length; ee++) {
          var B = D[ee], Z = D[L];
          if (B && ee !== L) if (Z) {
            var me = ie(B), le = ie(Z);
            if (me !== B.ownerDocument) if (le !== B.ownerDocument) if (me !== le) {
              q = q.length ? q : ae(Z);
              var Te = void 0;
              if (Z instanceof W.HTMLElement && B instanceof W.SVGElement && !(B instanceof W.SVGSVGElement)) {
                if (B === le) continue;
                Te = B.ownerSVGElement;
              } else Te = B;
              for (var Se = ae(Te, Z.ownerDocument), De = 0; Se[De] && Se[De] === q[De]; ) De++;
              var Pt = [Se[De - 1], Se[De], q[De]];
              if (Pt[0]) for (var ft = Pt[0].lastChild; ft; ) {
                if (ft === Pt[1]) {
                  L = ee, q = Se;
                  break;
                }
                if (ft === Pt[2]) break;
                ft = ft.previousSibling;
              }
            } else Y = Z, (parseInt(te(j = B).getComputedStyle(j).zIndex, 10) || 0) >= (parseInt(te(Y).getComputedStyle(Y).zIndex, 10) || 0) && (L = ee);
            else L = ee;
          } else L = ee;
        }
        return L;
      }(c);
      return n.activeDrops[E] || null;
    }
    function nr(t, e, r) {
      var n = t.dropState, o = { enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null };
      return r.type === "dragstart" && (o.activate = new Xe(n, r, "dropactivate"), o.activate.target = null, o.activate.dropzone = null), r.type === "dragend" && (o.deactivate = new Xe(n, r, "dropdeactivate"), o.deactivate.target = null, o.deactivate.dropzone = null), n.rejected || (n.cur.element !== n.prev.element && (n.prev.dropzone && (o.leave = new Xe(n, r, "dragleave"), r.dragLeave = o.leave.target = n.prev.element, r.prevDropzone = o.leave.dropzone = n.prev.dropzone), n.cur.dropzone && (o.enter = new Xe(n, r, "dragenter"), r.dragEnter = n.cur.element, r.dropzone = n.cur.dropzone)), r.type === "dragend" && n.cur.dropzone && (o.drop = new Xe(n, r, "drop"), r.dropzone = n.cur.dropzone, r.relatedTarget = n.cur.element), r.type === "dragmove" && n.cur.dropzone && (o.move = new Xe(n, r, "dropmove"), r.dropzone = n.cur.dropzone)), o;
    }
    function ir(t, e) {
      var r = t.dropState, n = r.activeDrops, o = r.cur, l = r.prev;
      e.leave && l.dropzone.fire(e.leave), e.enter && o.dropzone.fire(e.enter), e.move && o.dropzone.fire(e.move), e.drop && o.dropzone.fire(e.drop), e.deactivate && nn(n, e.deactivate), r.prev.dropzone = o.dropzone, r.prev.element = o.element;
    }
    function sn(t, e) {
      var r = t.interaction, n = t.iEvent, o = t.event;
      if (n.type === "dragmove" || n.type === "dragend") {
        var l = r.dropState;
        e.dynamicDrop && (l.activeDrops = rr(e, r.element));
        var c = n, p = on(r, c, o);
        l.rejected = l.rejected && !!p && p.dropzone === l.cur.dropzone && p.element === l.cur.element, l.cur.dropzone = p && p.dropzone, l.cur.element = p && p.element, l.events = nr(r, 0, c);
      }
    }
    var an = { id: "actions/drop", install: function(t) {
      var e = t.actions, r = t.interactStatic, n = t.Interactable, o = t.defaults;
      t.usePlugin(ne), n.prototype.dropzone = function(l) {
        return function(c, p) {
          if (S.object(p)) {
            if (c.options.drop.enabled = p.enabled !== !1, p.listeners) {
              var h = Ue(p.listeners), g = Object.keys(h).reduce(function(b, w) {
                return b[/^(enter|leave)/.test(w) ? "drag".concat(w) : /^(activate|deactivate|move)/.test(w) ? "drop".concat(w) : w] = h[w], b;
              }, {}), d = c.options.drop.listeners;
              d && c.off(d), c.on(g), c.options.drop.listeners = g;
            }
            return S.func(p.ondrop) && c.on("drop", p.ondrop), S.func(p.ondropactivate) && c.on("dropactivate", p.ondropactivate), S.func(p.ondropdeactivate) && c.on("dropdeactivate", p.ondropdeactivate), S.func(p.ondragenter) && c.on("dragenter", p.ondragenter), S.func(p.ondragleave) && c.on("dragleave", p.ondragleave), S.func(p.ondropmove) && c.on("dropmove", p.ondropmove), /^(pointer|center)$/.test(p.overlap) ? c.options.drop.overlap = p.overlap : S.number(p.overlap) && (c.options.drop.overlap = Math.max(Math.min(1, p.overlap), 0)), "accept" in p && (c.options.drop.accept = p.accept), "checker" in p && (c.options.drop.checker = p.checker), c;
          }
          return S.bool(p) ? (c.options.drop.enabled = p, c) : c.options.drop;
        }(this, l);
      }, n.prototype.dropCheck = function(l, c, p, h, g, d) {
        return function(b, w, I, E, D, L, j) {
          var Y = !1;
          if (!(j = j || b.getRect(L))) return !!b.options.drop.checker && b.options.drop.checker(w, I, Y, b, L, E, D);
          var q = b.options.drop.overlap;
          if (q === "pointer") {
            var ee = it(E, D, "drag"), B = Zr(w);
            B.x += ee.x, B.y += ee.y;
            var Z = B.x > j.left && B.x < j.right, me = B.y > j.top && B.y < j.bottom;
            Y = Z && me;
          }
          var le = E.getRect(D);
          if (le && q === "center") {
            var Te = le.left + le.width / 2, Se = le.top + le.height / 2;
            Y = Te >= j.left && Te <= j.right && Se >= j.top && Se <= j.bottom;
          }
          return le && S.number(q) && (Y = Math.max(0, Math.min(j.right, le.right) - Math.max(j.left, le.left)) * Math.max(0, Math.min(j.bottom, le.bottom) - Math.max(j.top, le.top)) / (le.width * le.height) >= q), b.options.drop.checker && (Y = b.options.drop.checker(w, I, Y, b, L, E, D)), Y;
        }(this, l, c, p, h, g, d);
      }, r.dynamicDrop = function(l) {
        return S.bool(l) ? (t.dynamicDrop = l, r) : t.dynamicDrop;
      }, H(e.phaselessTypes, { dragenter: !0, dragleave: !0, dropactivate: !0, dropdeactivate: !0, dropmove: !0, drop: !0 }), e.methodDict.drop = "dropzone", t.dynamicDrop = !1, o.actions.drop = an.defaults;
    }, listeners: { "interactions:before-action-start": function(t) {
      var e = t.interaction;
      e.prepared.name === "drag" && (e.dropState = { cur: { dropzone: null, element: null }, prev: { dropzone: null, element: null }, rejected: null, events: null, activeDrops: [] });
    }, "interactions:after-action-start": function(t, e) {
      var r = t.interaction, n = (t.event, t.iEvent);
      if (r.prepared.name === "drag") {
        var o = r.dropState;
        o.activeDrops = [], o.events = {}, o.activeDrops = rr(e, r.element), o.events = nr(r, 0, n), o.events.activate && (nn(o.activeDrops, o.events.activate), e.fire("actions/drop:start", { interaction: r, dragEvent: n }));
      }
    }, "interactions:action-move": sn, "interactions:after-action-move": function(t, e) {
      var r = t.interaction, n = t.iEvent;
      if (r.prepared.name === "drag") {
        var o = r.dropState;
        ir(r, o.events), e.fire("actions/drop:move", { interaction: r, dragEvent: n }), o.events = {};
      }
    }, "interactions:action-end": function(t, e) {
      if (t.interaction.prepared.name === "drag") {
        var r = t.interaction, n = t.iEvent;
        sn(t, e), ir(r, r.dropState.events), e.fire("actions/drop:end", { interaction: r, dragEvent: n });
      }
    }, "interactions:stop": function(t) {
      var e = t.interaction;
      if (e.prepared.name === "drag") {
        var r = e.dropState;
        r && (r.activeDrops = null, r.events = null, r.cur.dropzone = null, r.cur.element = null, r.prev.dropzone = null, r.prev.element = null, r.rejected = !1);
      }
    } }, getActiveDrops: rr, getDrop: on, getDropEvents: nr, fireDropEvents: ir, filterEventType: function(t) {
      return t.search("drag") === 0 || t.search("drop") === 0;
    }, defaults: { enabled: !1, accept: null, overlap: "pointer" } }, co = an;
    function or(t) {
      var e = t.interaction, r = t.iEvent, n = t.phase;
      if (e.prepared.name === "gesture") {
        var o = e.pointers.map(function(g) {
          return g.pointer;
        }), l = n === "start", c = n === "end", p = e.interactable.options.deltaSource;
        if (r.touches = [o[0], o[1]], l) r.distance = er(o, p), r.box = Qt(o), r.scale = 1, r.ds = 0, r.angle = tr(o, p), r.da = 0, e.gesture.startDistance = r.distance, e.gesture.startAngle = r.angle;
        else if (c || e.pointers.length < 2) {
          var h = e.prevEvent;
          r.distance = h.distance, r.box = h.box, r.scale = h.scale, r.ds = 0, r.angle = h.angle, r.da = 0;
        } else r.distance = er(o, p), r.box = Qt(o), r.scale = r.distance / e.gesture.startDistance, r.angle = tr(o, p), r.ds = r.scale - e.gesture.scale, r.da = r.angle - e.gesture.angle;
        e.gesture.distance = r.distance, e.gesture.angle = r.angle, S.number(r.scale) && r.scale !== 1 / 0 && !isNaN(r.scale) && (e.gesture.scale = r.scale);
      }
    }
    var sr = { id: "actions/gesture", before: ["actions/drag", "actions/resize"], install: function(t) {
      var e = t.actions, r = t.Interactable, n = t.defaults;
      r.prototype.gesturable = function(o) {
        return S.object(o) ? (this.options.gesture.enabled = o.enabled !== !1, this.setPerAction("gesture", o), this.setOnEvents("gesture", o), this) : S.bool(o) ? (this.options.gesture.enabled = o, this) : this.options.gesture;
      }, e.map.gesture = sr, e.methodDict.gesture = "gesturable", n.actions.gesture = sr.defaults;
    }, listeners: { "interactions:action-start": or, "interactions:action-move": or, "interactions:action-end": or, "interactions:new": function(t) {
      t.interaction.gesture = { angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0 };
    }, "auto-start:check": function(t) {
      if (!(t.interaction.pointers.length < 2)) {
        var e = t.interactable.options.gesture;
        if (e && e.enabled) return t.action = { name: "gesture" }, !1;
      }
    } }, defaults: {}, getCursor: function() {
      return "";
    }, filterEventType: function(t) {
      return t.search("gesture") === 0;
    } }, uo = sr;
    function po(t, e, r, n, o, l, c) {
      if (!e) return !1;
      if (e === !0) {
        var p = S.number(l.width) ? l.width : l.right - l.left, h = S.number(l.height) ? l.height : l.bottom - l.top;
        if (c = Math.min(c, Math.abs((t === "left" || t === "right" ? p : h) / 2)), p < 0 && (t === "left" ? t = "right" : t === "right" && (t = "left")), h < 0 && (t === "top" ? t = "bottom" : t === "bottom" && (t = "top")), t === "left") {
          var g = p >= 0 ? l.left : l.right;
          return r.x < g + c;
        }
        if (t === "top") {
          var d = h >= 0 ? l.top : l.bottom;
          return r.y < d + c;
        }
        if (t === "right") return r.x > (p >= 0 ? l.right : l.left) - c;
        if (t === "bottom") return r.y > (h >= 0 ? l.bottom : l.top) - c;
      }
      return !!S.element(n) && (S.element(e) ? e === n : pe(n, e, o));
    }
    function ln(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "resize" && r.resizeAxes) {
        var n = e;
        r.interactable.options.resize.square ? (r.resizeAxes === "y" ? n.delta.x = n.delta.y : n.delta.y = n.delta.x, n.axes = "xy") : (n.axes = r.resizeAxes, r.resizeAxes === "x" ? n.delta.y = 0 : r.resizeAxes === "y" && (n.delta.x = 0));
      }
    }
    var Ie, Ne, Pe = { id: "actions/resize", before: ["actions/drag"], install: function(t) {
      var e = t.actions, r = t.browser, n = t.Interactable, o = t.defaults;
      Pe.cursors = function(l) {
        return l.isIe9 ? { x: "e-resize", y: "s-resize", xy: "se-resize", top: "n-resize", left: "w-resize", bottom: "s-resize", right: "e-resize", topleft: "se-resize", bottomright: "se-resize", topright: "ne-resize", bottomleft: "ne-resize" } : { x: "ew-resize", y: "ns-resize", xy: "nwse-resize", top: "ns-resize", left: "ew-resize", bottom: "ns-resize", right: "ew-resize", topleft: "nwse-resize", bottomright: "nwse-resize", topright: "nesw-resize", bottomleft: "nesw-resize" };
      }(r), Pe.defaultMargin = r.supportsTouch || r.supportsPointerEvent ? 20 : 10, n.prototype.resizable = function(l) {
        return function(c, p, h) {
          return S.object(p) ? (c.options.resize.enabled = p.enabled !== !1, c.setPerAction("resize", p), c.setOnEvents("resize", p), S.string(p.axis) && /^x$|^y$|^xy$/.test(p.axis) ? c.options.resize.axis = p.axis : p.axis === null && (c.options.resize.axis = h.defaults.actions.resize.axis), S.bool(p.preserveAspectRatio) ? c.options.resize.preserveAspectRatio = p.preserveAspectRatio : S.bool(p.square) && (c.options.resize.square = p.square), c) : S.bool(p) ? (c.options.resize.enabled = p, c) : c.options.resize;
        }(this, l, t);
      }, e.map.resize = Pe, e.methodDict.resize = "resizable", o.actions.resize = Pe.defaults;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.resizeAxes = "xy";
    }, "interactions:action-start": function(t) {
      (function(e) {
        var r = e.iEvent, n = e.interaction;
        if (n.prepared.name === "resize" && n.prepared.edges) {
          var o = r, l = n.rect;
          n._rects = { start: H({}, l), corrected: H({}, l), previous: H({}, l), delta: { left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0 } }, o.edges = n.prepared.edges, o.rect = n._rects.corrected, o.deltaRect = n._rects.delta;
        }
      })(t), ln(t);
    }, "interactions:action-move": function(t) {
      (function(e) {
        var r = e.iEvent, n = e.interaction;
        if (n.prepared.name === "resize" && n.prepared.edges) {
          var o = r, l = n.interactable.options.resize.invert, c = l === "reposition" || l === "negate", p = n.rect, h = n._rects, g = h.start, d = h.corrected, b = h.delta, w = h.previous;
          if (H(w, d), c) {
            if (H(d, p), l === "reposition") {
              if (d.top > d.bottom) {
                var I = d.top;
                d.top = d.bottom, d.bottom = I;
              }
              if (d.left > d.right) {
                var E = d.left;
                d.left = d.right, d.right = E;
              }
            }
          } else d.top = Math.min(p.top, g.bottom), d.bottom = Math.max(p.bottom, g.top), d.left = Math.min(p.left, g.right), d.right = Math.max(p.right, g.left);
          for (var D in d.width = d.right - d.left, d.height = d.bottom - d.top, d) b[D] = d[D] - w[D];
          o.edges = n.prepared.edges, o.rect = d, o.deltaRect = b;
        }
      })(t), ln(t);
    }, "interactions:action-end": function(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "resize" && r.prepared.edges) {
        var n = e;
        n.edges = r.prepared.edges, n.rect = r._rects.corrected, n.deltaRect = r._rects.delta;
      }
    }, "auto-start:check": function(t) {
      var e = t.interaction, r = t.interactable, n = t.element, o = t.rect, l = t.buttons;
      if (o) {
        var c = H({}, e.coords.cur.page), p = r.options.resize;
        if (p && p.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || l & p.mouseButtons)) {
          if (S.object(p.edges)) {
            var h = { left: !1, right: !1, top: !1, bottom: !1 };
            for (var g in h) h[g] = po(g, p.edges[g], c, e._latestPointer.eventTarget, n, o, p.margin || Pe.defaultMargin);
            h.left = h.left && !h.right, h.top = h.top && !h.bottom, (h.left || h.right || h.top || h.bottom) && (t.action = { name: "resize", edges: h });
          } else {
            var d = p.axis !== "y" && c.x > o.right - Pe.defaultMargin, b = p.axis !== "x" && c.y > o.bottom - Pe.defaultMargin;
            (d || b) && (t.action = { name: "resize", axes: (d ? "x" : "") + (b ? "y" : "") });
          }
          return !t.action && void 0;
        }
      }
    } }, defaults: { square: !1, preserveAspectRatio: !1, axis: "xy", margin: NaN, edges: null, invert: "none" }, cursors: null, getCursor: function(t) {
      var e = t.edges, r = t.axis, n = t.name, o = Pe.cursors, l = null;
      if (r) l = o[n + r];
      else if (e) {
        for (var c = "", p = 0, h = ["top", "bottom", "left", "right"]; p < h.length; p++) {
          var g = h[p];
          e[g] && (c += g);
        }
        l = o[c];
      }
      return l;
    }, filterEventType: function(t) {
      return t.search("resize") === 0;
    }, defaultMargin: null }, ho = Pe, fo = { id: "actions", install: function(t) {
      t.usePlugin(uo), t.usePlugin(ho), t.usePlugin(ne), t.usePlugin(co);
    } }, cn = 0, je = { request: function(t) {
      return Ie(t);
    }, cancel: function(t) {
      return Ne(t);
    }, init: function(t) {
      if (Ie = t.requestAnimationFrame, Ne = t.cancelAnimationFrame, !Ie) for (var e = ["ms", "moz", "webkit", "o"], r = 0; r < e.length; r++) {
        var n = e[r];
        Ie = t["".concat(n, "RequestAnimationFrame")], Ne = t["".concat(n, "CancelAnimationFrame")] || t["".concat(n, "CancelRequestAnimationFrame")];
      }
      Ie = Ie && Ie.bind(t), Ne = Ne && Ne.bind(t), Ie || (Ie = function(o) {
        var l = Date.now(), c = Math.max(0, 16 - (l - cn)), p = t.setTimeout(function() {
          o(l + c);
        }, c);
        return cn = l + c, p;
      }, Ne = function(o) {
        return clearTimeout(o);
      });
    } }, V = { defaults: { enabled: !1, margin: 60, container: null, speed: 300 }, now: Date.now, interaction: null, i: 0, x: 0, y: 0, isScrolling: !1, prevTime: 0, margin: 0, speed: 0, start: function(t) {
      V.isScrolling = !0, je.cancel(V.i), t.autoScroll = V, V.interaction = t, V.prevTime = V.now(), V.i = je.request(V.scroll);
    }, stop: function() {
      V.isScrolling = !1, V.interaction && (V.interaction.autoScroll = null), je.cancel(V.i);
    }, scroll: function() {
      var t = V.interaction, e = t.interactable, r = t.element, n = t.prepared.name, o = e.options[n].autoScroll, l = un(o.container, e, r), c = V.now(), p = (c - V.prevTime) / 1e3, h = o.speed * p;
      if (h >= 1) {
        var g = { x: V.x * h, y: V.y * h };
        if (g.x || g.y) {
          var d = pn(l);
          S.window(l) ? l.scrollBy(g.x, g.y) : l && (l.scrollLeft += g.x, l.scrollTop += g.y);
          var b = pn(l), w = { x: b.x - d.x, y: b.y - d.y };
          (w.x || w.y) && e.fire({ type: "autoscroll", target: r, interactable: e, delta: w, interaction: t, container: l });
        }
        V.prevTime = c;
      }
      V.isScrolling && (je.cancel(V.i), V.i = je.request(V.scroll));
    }, check: function(t, e) {
      var r;
      return (r = t.options[e].autoScroll) == null ? void 0 : r.enabled;
    }, onInteractionMove: function(t) {
      var e = t.interaction, r = t.pointer;
      if (e.interacting() && V.check(e.interactable, e.prepared.name)) if (e.simulation) V.x = V.y = 0;
      else {
        var n, o, l, c, p = e.interactable, h = e.element, g = e.prepared.name, d = p.options[g].autoScroll, b = un(d.container, p, h);
        if (S.window(b)) c = r.clientX < V.margin, n = r.clientY < V.margin, o = r.clientX > b.innerWidth - V.margin, l = r.clientY > b.innerHeight - V.margin;
        else {
          var w = ve(b);
          c = r.clientX < w.left + V.margin, n = r.clientY < w.top + V.margin, o = r.clientX > w.right - V.margin, l = r.clientY > w.bottom - V.margin;
        }
        V.x = o ? 1 : c ? -1 : 0, V.y = l ? 1 : n ? -1 : 0, V.isScrolling || (V.margin = d.margin, V.speed = d.speed, V.start(e));
      }
    } };
    function un(t, e, r) {
      return (S.string(t) ? fe(t, e, r) : t) || te(r);
    }
    function pn(t) {
      return S.window(t) && (t = window.document.body), { x: t.scrollLeft, y: t.scrollTop };
    }
    var vo = { id: "auto-scroll", install: function(t) {
      var e = t.defaults, r = t.actions;
      t.autoScroll = V, V.now = function() {
        return t.now();
      }, r.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = V.defaults;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.autoScroll = null;
    }, "interactions:destroy": function(t) {
      t.interaction.autoScroll = null, V.stop(), V.interaction && (V.interaction = null);
    }, "interactions:stop": V.stop, "interactions:action-move": function(t) {
      return V.onInteractionMove(t);
    } } }, go = vo;
    function ct(t, e) {
      var r = !1;
      return function() {
        return r || (G.console.warn(e), r = !0), t.apply(this, arguments);
      };
    }
    function ar(t, e) {
      return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t;
    }
    function mo(t) {
      return S.bool(t) ? (this.options.styleCursor = t, this) : t === null ? (delete this.options.styleCursor, this) : this.options.styleCursor;
    }
    function bo(t) {
      return S.func(t) ? (this.options.actionChecker = t, this) : t === null ? (delete this.options.actionChecker, this) : this.options.actionChecker;
    }
    var yo = { id: "auto-start/interactableMethods", install: function(t) {
      var e = t.Interactable;
      e.prototype.getAction = function(r, n, o, l) {
        var c = function(p, h, g, d, b) {
          var w = p.getRect(d), I = h.buttons || { 0: 1, 1: 4, 3: 8, 4: 16 }[h.button], E = { action: null, interactable: p, interaction: g, element: d, rect: w, buttons: I };
          return b.fire("auto-start:check", E), E.action;
        }(this, n, o, l, t);
        return this.options.actionChecker ? this.options.actionChecker(r, n, c, this, l, o) : c;
      }, e.prototype.ignoreFrom = ct(function(r) {
        return this._backCompatOption("ignoreFrom", r);
      }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."), e.prototype.allowFrom = ct(function(r) {
        return this._backCompatOption("allowFrom", r);
      }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."), e.prototype.actionChecker = bo, e.prototype.styleCursor = mo;
    } };
    function hn(t, e, r, n, o) {
      return e.testIgnoreAllow(e.options[t.name], r, n) && e.options[t.name].enabled && St(e, r, t, o) ? t : null;
    }
    function To(t, e, r, n, o, l, c) {
      for (var p = 0, h = n.length; p < h; p++) {
        var g = n[p], d = o[p], b = g.getAction(e, r, t, d);
        if (b) {
          var w = hn(b, g, d, l, c);
          if (w) return { action: w, interactable: g, element: d };
        }
      }
      return { action: null, interactable: null, element: null };
    }
    function dn(t, e, r, n, o) {
      var l = [], c = [], p = n;
      function h(d) {
        l.push(d), c.push(p);
      }
      for (; S.element(p); ) {
        l = [], c = [], o.interactables.forEachMatch(p, h);
        var g = To(t, e, r, l, c, n, o);
        if (g.action && !g.interactable.options[g.action.name].manualStart) return g;
        p = K(p);
      }
      return { action: null, interactable: null, element: null };
    }
    function fn(t, e, r) {
      var n = e.action, o = e.interactable, l = e.element;
      n = n || { name: null }, t.interactable = o, t.element = l, ar(t.prepared, n), t.rect = o && n.name ? o.getRect(l) : null, gn(t, r), r.fire("autoStart:prepared", { interaction: t });
    }
    function St(t, e, r, n) {
      var o = t.options, l = o[r.name].max, c = o[r.name].maxPerElement, p = n.autoStart.maxInteractions, h = 0, g = 0, d = 0;
      if (!(l && c && p)) return !1;
      for (var b = 0, w = n.interactions.list; b < w.length; b++) {
        var I = w[b], E = I.prepared.name;
        if (I.interacting() && (++h >= p || I.interactable === t && ((g += E === r.name ? 1 : 0) >= l || I.element === e && (d++, E === r.name && d >= c))))
          return !1;
      }
      return p > 0;
    }
    function vn(t, e) {
      return S.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions;
    }
    function lr(t, e, r) {
      var n = r.autoStart.cursorElement;
      n && n !== t && (n.style.cursor = ""), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, r.autoStart.cursorElement = e ? t : null;
    }
    function gn(t, e) {
      var r = t.interactable, n = t.element, o = t.prepared;
      if (t.pointerType === "mouse" && r && r.options.styleCursor) {
        var l = "";
        if (o.name) {
          var c = r.options[o.name].cursorChecker;
          l = S.func(c) ? c(o, r, n, t._interacting) : e.actions.map[o.name].getCursor(o);
        }
        lr(t.element, l || "", e);
      } else e.autoStart.cursorElement && lr(e.autoStart.cursorElement, "", e);
    }
    var wo = { id: "auto-start/base", before: ["actions"], install: function(t) {
      var e = t.interactStatic, r = t.defaults;
      t.usePlugin(yo), r.base.actionChecker = null, r.base.styleCursor = !0, H(r.perAction, { manualStart: !1, max: 1 / 0, maxPerElement: 1, allowFrom: null, ignoreFrom: null, mouseButtons: 1 }), e.maxInteractions = function(n) {
        return vn(n, t);
      }, t.autoStart = { maxInteractions: 1 / 0, withinInteractionLimit: St, cursorElement: null };
    }, listeners: { "interactions:down": function(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget;
      r.interacting() || fn(r, dn(r, n, o, l, e), e);
    }, "interactions:move": function(t, e) {
      (function(r, n) {
        var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget;
        o.pointerType !== "mouse" || o.pointerIsDown || o.interacting() || fn(o, dn(o, l, c, p, n), n);
      })(t, e), function(r, n) {
        var o = r.interaction;
        if (o.pointerIsDown && !o.interacting() && o.pointerWasMoved && o.prepared.name) {
          n.fire("autoStart:before-start", r);
          var l = o.interactable, c = o.prepared.name;
          c && l && (l.options[c].manualStart || !St(l, o.element, o.prepared, n) ? o.stop() : (o.start(o.prepared, l, o.element), gn(o, n)));
        }
      }(t, e);
    }, "interactions:stop": function(t, e) {
      var r = t.interaction, n = r.interactable;
      n && n.options.styleCursor && lr(r.element, "", e);
    } }, maxInteractions: vn, withinInteractionLimit: St, validateAction: hn }, cr = wo, So = { id: "auto-start/dragAxis", listeners: { "autoStart:before-start": function(t, e) {
      var r = t.interaction, n = t.eventTarget, o = t.dx, l = t.dy;
      if (r.prepared.name === "drag") {
        var c = Math.abs(o), p = Math.abs(l), h = r.interactable.options.drag, g = h.startAxis, d = c > p ? "x" : c < p ? "y" : "xy";
        if (r.prepared.axis = h.lockAxis === "start" ? d[0] : h.lockAxis, d !== "xy" && g !== "xy" && g !== d) {
          r.prepared.name = null;
          for (var b = n, w = function(E) {
            if (E !== r.interactable) {
              var D = r.interactable.options.drag;
              if (!D.manualStart && E.testIgnoreAllow(D, b, n)) {
                var L = E.getAction(r.downPointer, r.downEvent, r, b);
                if (L && L.name === "drag" && function(j, Y) {
                  if (!Y) return !1;
                  var q = Y.options.drag.startAxis;
                  return j === "xy" || q === "xy" || q === j;
                }(d, E) && cr.validateAction(L, E, b, n, e)) return E;
              }
            }
          }; S.element(b); ) {
            var I = e.interactables.forEachMatch(b, w);
            if (I) {
              r.prepared.name = "drag", r.interactable = I, r.element = b;
              break;
            }
            b = K(b);
          }
        }
      }
    } } };
    function ur(t) {
      var e = t.prepared && t.prepared.name;
      if (!e) return null;
      var r = t.interactable.options;
      return r[e].hold || r[e].delay;
    }
    var xo = { id: "auto-start/hold", install: function(t) {
      var e = t.defaults;
      t.usePlugin(cr), e.perAction.hold = 0, e.perAction.delay = 0;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.autoStartHoldTimer = null;
    }, "autoStart:prepared": function(t) {
      var e = t.interaction, r = ur(e);
      r > 0 && (e.autoStartHoldTimer = setTimeout(function() {
        e.start(e.prepared, e.interactable, e.element);
      }, r));
    }, "interactions:move": function(t) {
      var e = t.interaction, r = t.duplicate;
      e.autoStartHoldTimer && e.pointerWasMoved && !r && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null);
    }, "autoStart:before-start": function(t) {
      var e = t.interaction;
      ur(e) > 0 && (e.prepared.name = null);
    } }, getHoldDuration: ur }, Oo = xo, Co = { id: "auto-start", install: function(t) {
      t.usePlugin(cr), t.usePlugin(Oo), t.usePlugin(So);
    } }, _o = function(t) {
      return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : S.bool(t) ? (this.options.preventDefault = t ? "always" : "never", this) : this.options.preventDefault;
    };
    function Mo(t) {
      var e = t.interaction, r = t.event;
      e.interactable && e.interactable.checkAndPreventDefault(r);
    }
    var mn = { id: "core/interactablePreventDefault", install: function(t) {
      var e = t.Interactable;
      e.prototype.preventDefault = _o, e.prototype.checkAndPreventDefault = function(r) {
        return function(n, o, l) {
          var c = n.options.preventDefault;
          if (c !== "never") if (c !== "always") {
            if (o.events.supportsPassive && /^touch(start|move)$/.test(l.type)) {
              var p = te(l.target).document, h = o.getDocOptions(p);
              if (!h || !h.events || h.events.passive !== !1) return;
            }
            /^(mouse|pointer|touch)*(down|start)/i.test(l.type) || S.element(l.target) && X(l.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *") || l.preventDefault();
          } else l.preventDefault();
        }(this, t, r);
      }, t.interactions.docEvents.push({ type: "dragstart", listener: function(r) {
        for (var n = 0, o = t.interactions.list; n < o.length; n++) {
          var l = o[n];
          if (l.element && (l.element === r.target || F(l.element, r.target))) return void l.interactable.checkAndPreventDefault(r);
        }
      } });
    }, listeners: ["down", "move", "up", "cancel"].reduce(function(t, e) {
      return t["interactions:".concat(e)] = Mo, t;
    }, {}) };
    function xt(t, e) {
      if (e.phaselessTypes[t]) return !0;
      for (var r in e.map) if (t.indexOf(r) === 0 && t.substr(r.length) in e.phases) return !0;
      return !1;
    }
    function Be(t) {
      var e = {};
      for (var r in t) {
        var n = t[r];
        S.plainObject(n) ? e[r] = Be(n) : S.array(n) ? e[r] = rn(n) : e[r] = n;
      }
      return e;
    }
    var pr = function() {
      function t(e) {
        v(this, t), this.states = [], this.startOffset = { left: 0, right: 0, top: 0, bottom: 0 }, this.startDelta = void 0, this.result = void 0, this.endResult = void 0, this.startEdges = void 0, this.edges = void 0, this.interaction = void 0, this.interaction = e, this.result = Ot(), this.edges = { left: !1, right: !1, top: !1, bottom: !1 };
      }
      return y(t, [{ key: "start", value: function(e, r) {
        var n, o, l = e.phase, c = this.interaction, p = function(g) {
          var d = g.interactable.options[g.prepared.name], b = d.modifiers;
          return b && b.length ? b : ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map(function(w) {
            var I = d[w];
            return I && I.enabled && { options: I, methods: I._methods };
          }).filter(function(w) {
            return !!w;
          });
        }(c);
        this.prepareStates(p), this.startEdges = H({}, c.edges), this.edges = H({}, this.startEdges), this.startOffset = (n = c.rect, o = r, n ? { left: o.x - n.left, top: o.y - n.top, right: n.right - o.x, bottom: n.bottom - o.y } : { left: 0, top: 0, right: 0, bottom: 0 }), this.startDelta = { x: 0, y: 0 };
        var h = this.fillArg({ phase: l, pageCoords: r, preEnd: !1 });
        return this.result = Ot(), this.startAll(h), this.result = this.setAll(h);
      } }, { key: "fillArg", value: function(e) {
        var r = this.interaction;
        return e.interaction = r, e.interactable = r.interactable, e.element = r.element, e.rect || (e.rect = r.rect), e.edges || (e.edges = this.startEdges), e.startOffset = this.startOffset, e;
      } }, { key: "startAll", value: function(e) {
        for (var r = 0, n = this.states; r < n.length; r++) {
          var o = n[r];
          o.methods.start && (e.state = o, o.methods.start(e));
        }
      } }, { key: "setAll", value: function(e) {
        var r = e.phase, n = e.preEnd, o = e.skipModifiers, l = e.rect, c = e.edges;
        e.coords = H({}, e.pageCoords), e.rect = H({}, l), e.edges = H({}, c);
        for (var p = o ? this.states.slice(o) : this.states, h = Ot(e.coords, e.rect), g = 0; g < p.length; g++) {
          var d, b = p[g], w = b.options, I = H({}, e.coords), E = null;
          (d = b.methods) != null && d.set && this.shouldDo(w, n, r) && (e.state = b, E = b.methods.set(e), mt(e.edges, e.rect, { x: e.coords.x - I.x, y: e.coords.y - I.y })), h.eventProps.push(E);
        }
        H(this.edges, e.edges), h.delta.x = e.coords.x - e.pageCoords.x, h.delta.y = e.coords.y - e.pageCoords.y, h.rectDelta.left = e.rect.left - l.left, h.rectDelta.right = e.rect.right - l.right, h.rectDelta.top = e.rect.top - l.top, h.rectDelta.bottom = e.rect.bottom - l.bottom;
        var D = this.result.coords, L = this.result.rect;
        if (D && L) {
          var j = h.rect.left !== L.left || h.rect.right !== L.right || h.rect.top !== L.top || h.rect.bottom !== L.bottom;
          h.changed = j || D.x !== h.coords.x || D.y !== h.coords.y;
        }
        return h;
      } }, { key: "applyToInteraction", value: function(e) {
        var r = this.interaction, n = e.phase, o = r.coords.cur, l = r.coords.start, c = this.result, p = this.startDelta, h = c.delta;
        n === "start" && H(this.startDelta, c.delta);
        for (var g = 0, d = [[l, p], [o, h]]; g < d.length; g++) {
          var b = d[g], w = b[0], I = b[1];
          w.page.x += I.x, w.page.y += I.y, w.client.x += I.x, w.client.y += I.y;
        }
        var E = this.result.rectDelta, D = e.rect || r.rect;
        D.left += E.left, D.right += E.right, D.top += E.top, D.bottom += E.bottom, D.width = D.right - D.left, D.height = D.bottom - D.top;
      } }, { key: "setAndApply", value: function(e) {
        var r = this.interaction, n = e.phase, o = e.preEnd, l = e.skipModifiers, c = this.setAll(this.fillArg({ preEnd: o, phase: n, pageCoords: e.modifiedCoords || r.coords.cur.page }));
        if (this.result = c, !c.changed && (!l || l < this.states.length) && r.interacting()) return !1;
        if (e.modifiedCoords) {
          var p = r.coords.cur.page, h = { x: e.modifiedCoords.x - p.x, y: e.modifiedCoords.y - p.y };
          c.coords.x += h.x, c.coords.y += h.y, c.delta.x += h.x, c.delta.y += h.y;
        }
        this.applyToInteraction(e);
      } }, { key: "beforeEnd", value: function(e) {
        var r = e.interaction, n = e.event, o = this.states;
        if (o && o.length) {
          for (var l = !1, c = 0; c < o.length; c++) {
            var p = o[c];
            e.state = p;
            var h = p.options, g = p.methods, d = g.beforeEnd && g.beforeEnd(e);
            if (d) return this.endResult = d, !1;
            l = l || !l && this.shouldDo(h, !0, e.phase, !0);
          }
          l && r.move({ event: n, preEnd: !0 });
        }
      } }, { key: "stop", value: function(e) {
        var r = e.interaction;
        if (this.states && this.states.length) {
          var n = H({ states: this.states, interactable: r.interactable, element: r.element, rect: null }, e);
          this.fillArg(n);
          for (var o = 0, l = this.states; o < l.length; o++) {
            var c = l[o];
            n.state = c, c.methods.stop && c.methods.stop(n);
          }
          this.states = null, this.endResult = null;
        }
      } }, { key: "prepareStates", value: function(e) {
        this.states = [];
        for (var r = 0; r < e.length; r++) {
          var n = e[r], o = n.options, l = n.methods, c = n.name;
          this.states.push({ options: o, methods: l, index: r, name: c });
        }
        return this.states;
      } }, { key: "restoreInteractionCoords", value: function(e) {
        var r = e.interaction, n = r.coords, o = r.rect, l = r.modification;
        if (l.result) {
          for (var c = l.startDelta, p = l.result, h = p.delta, g = p.rectDelta, d = 0, b = [[n.start, c], [n.cur, h]]; d < b.length; d++) {
            var w = b[d], I = w[0], E = w[1];
            I.page.x -= E.x, I.page.y -= E.y, I.client.x -= E.x, I.client.y -= E.y;
          }
          o.left -= g.left, o.right -= g.right, o.top -= g.top, o.bottom -= g.bottom;
        }
      } }, { key: "shouldDo", value: function(e, r, n, o) {
        return !(!e || e.enabled === !1 || o && !e.endOnly || e.endOnly && !r || n === "start" && !e.setStart);
      } }, { key: "copyFrom", value: function(e) {
        this.startOffset = e.startOffset, this.startDelta = e.startDelta, this.startEdges = e.startEdges, this.edges = e.edges, this.states = e.states.map(function(r) {
          return Be(r);
        }), this.result = Ot(H({}, e.result.coords), H({}, e.result.rect));
      } }, { key: "destroy", value: function() {
        for (var e in this) this[e] = null;
      } }]), t;
    }();
    function Ot(t, e) {
      return { rect: e, coords: t, delta: { x: 0, y: 0 }, rectDelta: { left: 0, right: 0, top: 0, bottom: 0 }, eventProps: [], changed: !0 };
    }
    function Ae(t, e) {
      var r = t.defaults, n = { start: t.start, set: t.set, beforeEnd: t.beforeEnd, stop: t.stop }, o = function(l) {
        var c = l || {};
        for (var p in c.enabled = c.enabled !== !1, r) p in c || (c[p] = r[p]);
        var h = { options: c, methods: n, name: e, enable: function() {
          return c.enabled = !0, h;
        }, disable: function() {
          return c.enabled = !1, h;
        } };
        return h;
      };
      return e && typeof e == "string" && (o._defaults = r, o._methods = n), o;
    }
    function ut(t) {
      var e = t.iEvent, r = t.interaction.modification.result;
      r && (e.modifiers = r.eventProps);
    }
    var Eo = { id: "modifiers/base", before: ["actions"], install: function(t) {
      t.defaults.perAction.modifiers = [];
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.modification = new pr(e);
    }, "interactions:before-action-start": function(t) {
      var e = t.interaction, r = t.interaction.modification;
      r.start(t, e.coords.start.page), e.edges = r.edges, r.applyToInteraction(t);
    }, "interactions:before-action-move": function(t) {
      var e = t.interaction, r = e.modification, n = r.setAndApply(t);
      return e.edges = r.edges, n;
    }, "interactions:before-action-end": function(t) {
      var e = t.interaction, r = e.modification, n = r.beforeEnd(t);
      return e.edges = r.startEdges, n;
    }, "interactions:action-start": ut, "interactions:action-move": ut, "interactions:action-end": ut, "interactions:after-action-start": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:after-action-move": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:stop": function(t) {
      return t.interaction.modification.stop(t);
    } } }, bn = Eo, yn = { base: { preventDefault: "auto", deltaSource: "page" }, perAction: { enabled: !1, origin: { x: 0, y: 0 } }, actions: {} }, hr = function(t) {
      O(r, t);
      var e = _(r);
      function r(n, o, l, c, p, h, g) {
        var d;
        v(this, r), (d = e.call(this, n)).relatedTarget = null, d.screenX = void 0, d.screenY = void 0, d.button = void 0, d.buttons = void 0, d.ctrlKey = void 0, d.shiftKey = void 0, d.altKey = void 0, d.metaKey = void 0, d.page = void 0, d.client = void 0, d.delta = void 0, d.rect = void 0, d.x0 = void 0, d.y0 = void 0, d.t0 = void 0, d.dt = void 0, d.duration = void 0, d.clientX0 = void 0, d.clientY0 = void 0, d.velocity = void 0, d.speed = void 0, d.swipe = void 0, d.axes = void 0, d.preEnd = void 0, p = p || n.element;
        var b = n.interactable, w = (b && b.options || yn).deltaSource, I = it(b, p, l), E = c === "start", D = c === "end", L = E ? T(d) : n.prevEvent, j = E ? n.coords.start : D ? { page: L.page, client: L.client, timeStamp: n.coords.cur.timeStamp } : n.coords.cur;
        return d.page = H({}, j.page), d.client = H({}, j.client), d.rect = H({}, n.rect), d.timeStamp = j.timeStamp, D || (d.page.x -= I.x, d.page.y -= I.y, d.client.x -= I.x, d.client.y -= I.y), d.ctrlKey = o.ctrlKey, d.altKey = o.altKey, d.shiftKey = o.shiftKey, d.metaKey = o.metaKey, d.button = o.button, d.buttons = o.buttons, d.target = p, d.currentTarget = p, d.preEnd = h, d.type = g || l + (c || ""), d.interactable = b, d.t0 = E ? n.pointers[n.pointers.length - 1].downTime : L.t0, d.x0 = n.coords.start.page.x - I.x, d.y0 = n.coords.start.page.y - I.y, d.clientX0 = n.coords.start.client.x - I.x, d.clientY0 = n.coords.start.client.y - I.y, d.delta = E || D ? { x: 0, y: 0 } : { x: d[w].x - L[w].x, y: d[w].y - L[w].y }, d.dt = n.coords.delta.timeStamp, d.duration = d.timeStamp - d.t0, d.velocity = H({}, n.coords.velocity[w]), d.speed = ot(d.velocity.x, d.velocity.y), d.swipe = D || c === "inertiastart" ? d.getSwipe() : null, d;
      }
      return y(r, [{ key: "getSwipe", value: function() {
        var n = this._interaction;
        if (n.prevEvent.speed < 600 || this.timeStamp - n.prevEvent.timeStamp > 150) return null;
        var o = 180 * Math.atan2(n.prevEvent.velocityY, n.prevEvent.velocityX) / Math.PI;
        o < 0 && (o += 360);
        var l = 112.5 <= o && o < 247.5, c = 202.5 <= o && o < 337.5;
        return { up: c, down: !c && 22.5 <= o && o < 157.5, left: l, right: !l && (292.5 <= o || o < 67.5), angle: o, speed: n.prevEvent.speed, velocity: { x: n.prevEvent.velocityX, y: n.prevEvent.velocityY } };
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }]), r;
    }(wt);
    Object.defineProperties(hr.prototype, { pageX: { get: function() {
      return this.page.x;
    }, set: function(t) {
      this.page.x = t;
    } }, pageY: { get: function() {
      return this.page.y;
    }, set: function(t) {
      this.page.y = t;
    } }, clientX: { get: function() {
      return this.client.x;
    }, set: function(t) {
      this.client.x = t;
    } }, clientY: { get: function() {
      return this.client.y;
    }, set: function(t) {
      this.client.y = t;
    } }, dx: { get: function() {
      return this.delta.x;
    }, set: function(t) {
      this.delta.x = t;
    } }, dy: { get: function() {
      return this.delta.y;
    }, set: function(t) {
      this.delta.y = t;
    } }, velocityX: { get: function() {
      return this.velocity.x;
    }, set: function(t) {
      this.velocity.x = t;
    } }, velocityY: { get: function() {
      return this.velocity.y;
    }, set: function(t) {
      this.velocity.y = t;
    } } });
    var Io = y(function t(e, r, n, o, l) {
      v(this, t), this.id = void 0, this.pointer = void 0, this.event = void 0, this.downTime = void 0, this.downTarget = void 0, this.id = e, this.pointer = r, this.event = n, this.downTime = o, this.downTarget = l;
    }), Po = function(t) {
      return t.interactable = "", t.element = "", t.prepared = "", t.pointerIsDown = "", t.pointerWasMoved = "", t._proxy = "", t;
    }({}), Tn = function(t) {
      return t.start = "", t.move = "", t.end = "", t.stop = "", t.interacting = "", t;
    }({}), Do = 0, Ro = function() {
      function t(e) {
        var r = this, n = e.pointerType, o = e.scopeFire;
        v(this, t), this.interactable = null, this.element = null, this.rect = null, this._rects = void 0, this.edges = null, this._scopeFire = void 0, this.prepared = { name: null, axis: null, edges: null }, this.pointerType = void 0, this.pointers = [], this.downEvent = null, this.downPointer = {}, this._latestPointer = { pointer: null, event: null, eventTarget: null }, this.prevEvent = null, this.pointerIsDown = !1, this.pointerWasMoved = !1, this._interacting = !1, this._ending = !1, this._stopped = !0, this._proxy = void 0, this.simulation = null, this.doMove = ct(function(d) {
          this.move(d);
        }, "The interaction.doMove() method has been renamed to interaction.move()"), this.coords = { start: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, prev: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, cur: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, delta: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, velocity: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 } }, this._id = Do++, this._scopeFire = o, this.pointerType = n;
        var l = this;
        this._proxy = {};
        var c = function(d) {
          Object.defineProperty(r._proxy, d, { get: function() {
            return l[d];
          } });
        };
        for (var p in Po) c(p);
        var h = function(d) {
          Object.defineProperty(r._proxy, d, { value: function() {
            return l[d].apply(l, arguments);
          } });
        };
        for (var g in Tn) h(g);
        this._scopeFire("interactions:new", { interaction: this });
      }
      return y(t, [{ key: "pointerMoveTolerance", get: function() {
        return 1;
      } }, { key: "pointerDown", value: function(e, r, n) {
        var o = this.updatePointer(e, r, n, !0), l = this.pointers[o];
        this._scopeFire("interactions:down", { pointer: e, event: r, eventTarget: n, pointerIndex: o, pointerInfo: l, type: "down", interaction: this });
      } }, { key: "start", value: function(e, r, n) {
        return !(this.interacting() || !this.pointerIsDown || this.pointers.length < (e.name === "gesture" ? 2 : 1) || !r.options[e.name].enabled) && (ar(this.prepared, e), this.interactable = r, this.element = n, this.rect = r.getRect(n), this.edges = this.prepared.edges ? H({}, this.prepared.edges) : { left: !0, right: !0, top: !0, bottom: !0 }, this._stopped = !1, this._interacting = this._doPhase({ interaction: this, event: this.downEvent, phase: "start" }) && !this._stopped, this._interacting);
      } }, { key: "pointerMove", value: function(e, r, n) {
        this.simulation || this.modification && this.modification.endResult || this.updatePointer(e, r, n, !1);
        var o, l, c = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
        this.pointerIsDown && !this.pointerWasMoved && (o = this.coords.cur.client.x - this.coords.start.client.x, l = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = ot(o, l) > this.pointerMoveTolerance);
        var p, h, g, d = this.getPointerIndex(e), b = { pointer: e, pointerIndex: d, pointerInfo: this.pointers[d], event: r, type: "move", eventTarget: n, dx: o, dy: l, duplicate: c, interaction: this };
        c || (p = this.coords.velocity, h = this.coords.delta, g = Math.max(h.timeStamp / 1e3, 1e-3), p.page.x = h.page.x / g, p.page.y = h.page.y / g, p.client.x = h.client.x / g, p.client.y = h.client.y / g, p.timeStamp = g), this._scopeFire("interactions:move", b), c || this.simulation || (this.interacting() && (b.type = null, this.move(b)), this.pointerWasMoved && yt(this.coords.prev, this.coords.cur));
      } }, { key: "move", value: function(e) {
        e && e.event || Vr(this.coords.delta), (e = H({ pointer: this._latestPointer.pointer, event: this._latestPointer.event, eventTarget: this._latestPointer.eventTarget, interaction: this }, e || {})).phase = "move", this._doPhase(e);
      } }, { key: "pointerUp", value: function(e, r, n, o) {
        var l = this.getPointerIndex(e);
        l === -1 && (l = this.updatePointer(e, r, n, !1));
        var c = /cancel$/i.test(r.type) ? "cancel" : "up";
        this._scopeFire("interactions:".concat(c), { pointer: e, pointerIndex: l, pointerInfo: this.pointers[l], event: r, eventTarget: n, type: c, curEventTarget: o, interaction: this }), this.simulation || this.end(r), this.removePointer(e, r);
      } }, { key: "documentBlur", value: function(e) {
        this.end(e), this._scopeFire("interactions:blur", { event: e, type: "blur", interaction: this });
      } }, { key: "end", value: function(e) {
        var r;
        this._ending = !0, e = e || this._latestPointer.event, this.interacting() && (r = this._doPhase({ event: e, interaction: this, phase: "end" })), this._ending = !1, r === !0 && this.stop();
      } }, { key: "currentAction", value: function() {
        return this._interacting ? this.prepared.name : null;
      } }, { key: "interacting", value: function() {
        return this._interacting;
      } }, { key: "stop", value: function() {
        this._scopeFire("interactions:stop", { interaction: this }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null;
      } }, { key: "getPointerIndex", value: function(e) {
        var r = st(e);
        return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : at(this.pointers, function(n) {
          return n.id === r;
        });
      } }, { key: "getPointerInfo", value: function(e) {
        return this.pointers[this.getPointerIndex(e)];
      } }, { key: "updatePointer", value: function(e, r, n, o) {
        var l, c, p, h = st(e), g = this.getPointerIndex(e), d = this.pointers[g];
        return o = o !== !1 && (o || /(down|start)$/i.test(r.type)), d ? d.pointer = e : (d = new Io(h, e, r, null, null), g = this.pointers.length, this.pointers.push(d)), lo(this.coords.cur, this.pointers.map(function(b) {
          return b.pointer;
        }), this._now()), l = this.coords.delta, c = this.coords.prev, p = this.coords.cur, l.page.x = p.page.x - c.page.x, l.page.y = p.page.y - c.page.y, l.client.x = p.client.x - c.client.x, l.client.y = p.client.y - c.client.y, l.timeStamp = p.timeStamp - c.timeStamp, o && (this.pointerIsDown = !0, d.downTime = this.coords.cur.timeStamp, d.downTarget = n, bt(this.downPointer, e), this.interacting() || (yt(this.coords.start, this.coords.cur), yt(this.coords.prev, this.coords.cur), this.downEvent = r, this.pointerWasMoved = !1)), this._updateLatestPointer(e, r, n), this._scopeFire("interactions:update-pointer", { pointer: e, event: r, eventTarget: n, down: o, pointerInfo: d, pointerIndex: g, interaction: this }), g;
      } }, { key: "removePointer", value: function(e, r) {
        var n = this.getPointerIndex(e);
        if (n !== -1) {
          var o = this.pointers[n];
          this._scopeFire("interactions:remove-pointer", { pointer: e, event: r, eventTarget: null, pointerIndex: n, pointerInfo: o, interaction: this }), this.pointers.splice(n, 1), this.pointerIsDown = !1;
        }
      } }, { key: "_updateLatestPointer", value: function(e, r, n) {
        this._latestPointer.pointer = e, this._latestPointer.event = r, this._latestPointer.eventTarget = n;
      } }, { key: "destroy", value: function() {
        this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;
      } }, { key: "_createPreparedEvent", value: function(e, r, n, o) {
        return new hr(this, e, this.prepared.name, r, this.element, n, o);
      } }, { key: "_fireEvent", value: function(e) {
        var r;
        (r = this.interactable) == null || r.fire(e), (!this.prevEvent || e.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = e);
      } }, { key: "_doPhase", value: function(e) {
        var r = e.event, n = e.phase, o = e.preEnd, l = e.type, c = this.rect;
        if (c && n === "move" && (mt(this.edges, c, this.coords.delta[this.interactable.options.deltaSource]), c.width = c.right - c.left, c.height = c.bottom - c.top), this._scopeFire("interactions:before-action-".concat(n), e) === !1) return !1;
        var p = e.iEvent = this._createPreparedEvent(r, n, o, l);
        return this._scopeFire("interactions:action-".concat(n), e), n === "start" && (this.prevEvent = p), this._fireEvent(p), this._scopeFire("interactions:after-action-".concat(n), e), !0;
      } }, { key: "_now", value: function() {
        return Date.now();
      } }]), t;
    }();
    function wn(t) {
      Sn(t.interaction);
    }
    function Sn(t) {
      if (!function(r) {
        return !(!r.offset.pending.x && !r.offset.pending.y);
      }(t)) return !1;
      var e = t.offset.pending;
      return dr(t.coords.cur, e), dr(t.coords.delta, e), mt(t.edges, t.rect, e), e.x = 0, e.y = 0, !0;
    }
    function $o(t) {
      var e = t.x, r = t.y;
      this.offset.pending.x += e, this.offset.pending.y += r, this.offset.total.x += e, this.offset.total.y += r;
    }
    function dr(t, e) {
      var r = t.page, n = t.client, o = e.x, l = e.y;
      r.x += o, r.y += l, n.x += o, n.y += l;
    }
    Tn.offsetBy = "";
    var ko = { id: "offset", before: ["modifiers", "pointer-events", "actions", "inertia"], install: function(t) {
      t.Interaction.prototype.offsetBy = $o;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.offset = { total: { x: 0, y: 0 }, pending: { x: 0, y: 0 } };
    }, "interactions:update-pointer": function(t) {
      return function(e) {
        e.pointerIsDown && (dr(e.coords.cur, e.offset.total), e.offset.pending.x = 0, e.offset.pending.y = 0);
      }(t.interaction);
    }, "interactions:before-action-start": wn, "interactions:before-action-move": wn, "interactions:before-action-end": function(t) {
      var e = t.interaction;
      if (Sn(e)) return e.move({ offset: !0 }), e.end(), !1;
    }, "interactions:stop": function(t) {
      var e = t.interaction;
      e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0;
    } } }, xn = ko, zo = function() {
      function t(e) {
        v(this, t), this.active = !1, this.isModified = !1, this.smoothEnd = !1, this.allowResume = !1, this.modification = void 0, this.modifierCount = 0, this.modifierArg = void 0, this.startCoords = void 0, this.t0 = 0, this.v0 = 0, this.te = 0, this.targetOffset = void 0, this.modifiedOffset = void 0, this.currentOffset = void 0, this.lambda_v0 = 0, this.one_ve_v0 = 0, this.timeout = void 0, this.interaction = void 0, this.interaction = e;
      }
      return y(t, [{ key: "start", value: function(e) {
        var r = this.interaction, n = Ct(r);
        if (!n || !n.enabled) return !1;
        var o = r.coords.velocity.client, l = ot(o.x, o.y), c = this.modification || (this.modification = new pr(r));
        if (c.copyFrom(r.modification), this.t0 = r._now(), this.allowResume = n.allowResume, this.v0 = l, this.currentOffset = { x: 0, y: 0 }, this.startCoords = r.coords.cur.page, this.modifierArg = c.fillArg({ pageCoords: this.startCoords, preEnd: !0, phase: "inertiastart" }), this.t0 - r.coords.cur.timeStamp < 50 && l > n.minSpeed && l > n.endSpeed) this.startInertia();
        else {
          if (c.result = c.setAll(this.modifierArg), !c.result.changed) return !1;
          this.startSmoothEnd();
        }
        return r.modification.result.rect = null, r.offsetBy(this.targetOffset), r._doPhase({ interaction: r, event: e, phase: "inertiastart" }), r.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y }), r.modification.result.rect = null, this.active = !0, r.simulation = this, !0;
      } }, { key: "startInertia", value: function() {
        var e = this, r = this.interaction.coords.velocity.client, n = Ct(this.interaction), o = n.resistance, l = -Math.log(n.endSpeed / this.v0) / o;
        this.targetOffset = { x: (r.x - l) / o, y: (r.y - l) / o }, this.te = l, this.lambda_v0 = o / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0;
        var c = this.modification, p = this.modifierArg;
        p.pageCoords = { x: this.startCoords.x + this.targetOffset.x, y: this.startCoords.y + this.targetOffset.y }, c.result = c.setAll(p), c.result.changed && (this.isModified = !0, this.modifiedOffset = { x: this.targetOffset.x + c.result.delta.x, y: this.targetOffset.y + c.result.delta.y }), this.onNextFrame(function() {
          return e.inertiaTick();
        });
      } }, { key: "startSmoothEnd", value: function() {
        var e = this;
        this.smoothEnd = !0, this.isModified = !0, this.targetOffset = { x: this.modification.result.delta.x, y: this.modification.result.delta.y }, this.onNextFrame(function() {
          return e.smoothEndTick();
        });
      } }, { key: "onNextFrame", value: function(e) {
        var r = this;
        this.timeout = je.request(function() {
          r.active && e();
        });
      } }, { key: "inertiaTick", value: function() {
        var e, r, n, o, l, c, p, h = this, g = this.interaction, d = Ct(g).resistance, b = (g._now() - this.t0) / 1e3;
        if (b < this.te) {
          var w, I = 1 - (Math.exp(-d * b) - this.lambda_v0) / this.one_ve_v0;
          this.isModified ? (e = 0, r = 0, n = this.targetOffset.x, o = this.targetOffset.y, l = this.modifiedOffset.x, c = this.modifiedOffset.y, w = { x: On(p = I, e, n, l), y: On(p, r, o, c) }) : w = { x: this.targetOffset.x * I, y: this.targetOffset.y * I };
          var E = { x: w.x - this.currentOffset.x, y: w.y - this.currentOffset.y };
          this.currentOffset.x += E.x, this.currentOffset.y += E.y, g.offsetBy(E), g.move(), this.onNextFrame(function() {
            return h.inertiaTick();
          });
        } else g.offsetBy({ x: this.modifiedOffset.x - this.currentOffset.x, y: this.modifiedOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "smoothEndTick", value: function() {
        var e = this, r = this.interaction, n = r._now() - this.t0, o = Ct(r).smoothEndDuration;
        if (n < o) {
          var l = { x: Cn(n, 0, this.targetOffset.x, o), y: Cn(n, 0, this.targetOffset.y, o) }, c = { x: l.x - this.currentOffset.x, y: l.y - this.currentOffset.y };
          this.currentOffset.x += c.x, this.currentOffset.y += c.y, r.offsetBy(c), r.move({ skipModifiers: this.modifierCount }), this.onNextFrame(function() {
            return e.smoothEndTick();
          });
        } else r.offsetBy({ x: this.targetOffset.x - this.currentOffset.x, y: this.targetOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "resume", value: function(e) {
        var r = e.pointer, n = e.event, o = e.eventTarget, l = this.interaction;
        l.offsetBy({ x: -this.currentOffset.x, y: -this.currentOffset.y }), l.updatePointer(r, n, o, !0), l._doPhase({ interaction: l, event: n, phase: "resume" }), yt(l.coords.prev, l.coords.cur), this.stop();
      } }, { key: "end", value: function() {
        this.interaction.move(), this.interaction.end(), this.stop();
      } }, { key: "stop", value: function() {
        this.active = this.smoothEnd = !1, this.interaction.simulation = null, je.cancel(this.timeout);
      } }]), t;
    }();
    function Ct(t) {
      var e = t.interactable, r = t.prepared;
      return e && e.options && r.name && e.options[r.name].inertia;
    }
    var jo = { id: "inertia", before: ["modifiers", "actions"], install: function(t) {
      var e = t.defaults;
      t.usePlugin(xn), t.usePlugin(bn), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = { enabled: !1, resistance: 10, minSpeed: 100, endSpeed: 10, allowResume: !0, smoothEndDuration: 300 };
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.inertia = new zo(e);
    }, "interactions:before-action-end": function(t) {
      var e = t.interaction, r = t.event;
      return (!e._interacting || e.simulation || !e.inertia.start(r)) && null;
    }, "interactions:down": function(t) {
      var e = t.interaction, r = t.eventTarget, n = e.inertia;
      if (n.active) for (var o = r; S.element(o); ) {
        if (o === e.element) {
          n.resume(t);
          break;
        }
        o = K(o);
      }
    }, "interactions:stop": function(t) {
      var e = t.interaction.inertia;
      e.active && e.stop();
    }, "interactions:before-action-resume": function(t) {
      var e = t.interaction.modification;
      e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t);
    }, "interactions:before-action-inertiastart": function(t) {
      return t.interaction.modification.setAndApply(t);
    }, "interactions:action-resume": ut, "interactions:action-inertiastart": ut, "interactions:after-action-inertiastart": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:after-action-resume": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    } } };
    function On(t, e, r, n) {
      var o = 1 - t;
      return o * o * e + 2 * o * t * r + t * t * n;
    }
    function Cn(t, e, r, n) {
      return -r * (t /= n) * (t - 2) + e;
    }
    var Ao = jo;
    function _n(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        if (t.immediatePropagationStopped) break;
        n(t);
      }
    }
    var Mn = function() {
      function t(e) {
        v(this, t), this.options = void 0, this.types = {}, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.global = void 0, this.options = H({}, e || {});
      }
      return y(t, [{ key: "fire", value: function(e) {
        var r, n = this.global;
        (r = this.types[e.type]) && _n(e, r), !e.propagationStopped && n && (r = n[e.type]) && _n(e, r);
      } }, { key: "on", value: function(e, r) {
        var n = Ue(e, r);
        for (e in n) this.types[e] = tn(this.types[e] || [], n[e]);
      } }, { key: "off", value: function(e, r) {
        var n = Ue(e, r);
        for (e in n) {
          var o = this.types[e];
          if (o && o.length) for (var l = 0, c = n[e]; l < c.length; l++) {
            var p = c[l], h = o.indexOf(p);
            h !== -1 && o.splice(h, 1);
          }
        }
      } }, { key: "getRect", value: function(e) {
        return null;
      } }]), t;
    }(), Lo = function() {
      function t(e) {
        v(this, t), this.currentTarget = void 0, this.originalEvent = void 0, this.type = void 0, this.originalEvent = e, bt(this, e);
      }
      return y(t, [{ key: "preventOriginalDefault", value: function() {
        this.originalEvent.preventDefault();
      } }, { key: "stopPropagation", value: function() {
        this.originalEvent.stopPropagation();
      } }, { key: "stopImmediatePropagation", value: function() {
        this.originalEvent.stopImmediatePropagation();
      } }]), t;
    }();
    function pt(t) {
      return S.object(t) ? { capture: !!t.capture, passive: !!t.passive } : { capture: !!t, passive: !1 };
    }
    function _t(t, e) {
      return t === e || (typeof t == "boolean" ? !!e.capture === t && !e.passive : !!t.capture == !!e.capture && !!t.passive == !!e.passive);
    }
    var Ho = { id: "events", install: function(t) {
      var e, r = [], n = {}, o = [], l = { add: c, remove: p, addDelegate: function(d, b, w, I, E) {
        var D = pt(E);
        if (!n[w]) {
          n[w] = [];
          for (var L = 0; L < o.length; L++) {
            var j = o[L];
            c(j, w, h), c(j, w, g, !0);
          }
        }
        var Y = n[w], q = lt(Y, function(ee) {
          return ee.selector === d && ee.context === b;
        });
        q || (q = { selector: d, context: b, listeners: [] }, Y.push(q)), q.listeners.push({ func: I, options: D });
      }, removeDelegate: function(d, b, w, I, E) {
        var D, L = pt(E), j = n[w], Y = !1;
        if (j)
          for (D = j.length - 1; D >= 0; D--) {
            var q = j[D];
            if (q.selector === d && q.context === b) {
              for (var ee = q.listeners, B = ee.length - 1; B >= 0; B--) {
                var Z = ee[B];
                if (Z.func === I && _t(Z.options, L)) {
                  ee.splice(B, 1), ee.length || (j.splice(D, 1), p(b, w, h), p(b, w, g, !0)), Y = !0;
                  break;
                }
              }
              if (Y) break;
            }
          }
      }, delegateListener: h, delegateUseCapture: g, delegatedEvents: n, documents: o, targets: r, supportsOptions: !1, supportsPassive: !1 };
      function c(d, b, w, I) {
        if (d.addEventListener) {
          var E = pt(I), D = lt(r, function(L) {
            return L.eventTarget === d;
          });
          D || (D = { eventTarget: d, events: {} }, r.push(D)), D.events[b] || (D.events[b] = []), lt(D.events[b], function(L) {
            return L.func === w && _t(L.options, E);
          }) || (d.addEventListener(b, w, l.supportsOptions ? E : E.capture), D.events[b].push({ func: w, options: E }));
        }
      }
      function p(d, b, w, I) {
        if (d.addEventListener && d.removeEventListener) {
          var E = at(r, function(me) {
            return me.eventTarget === d;
          }), D = r[E];
          if (D && D.events) if (b !== "all") {
            var L = !1, j = D.events[b];
            if (j) {
              if (w === "all") {
                for (var Y = j.length - 1; Y >= 0; Y--) {
                  var q = j[Y];
                  p(d, b, q.func, q.options);
                }
                return;
              }
              for (var ee = pt(I), B = 0; B < j.length; B++) {
                var Z = j[B];
                if (Z.func === w && _t(Z.options, ee)) {
                  d.removeEventListener(b, w, l.supportsOptions ? ee : ee.capture), j.splice(B, 1), j.length === 0 && (delete D.events[b], L = !0);
                  break;
                }
              }
            }
            L && !Object.keys(D.events).length && r.splice(E, 1);
          } else for (b in D.events) D.events.hasOwnProperty(b) && p(d, b, "all");
        }
      }
      function h(d, b) {
        for (var w = pt(b), I = new Lo(d), E = n[d.type], D = en(d)[0], L = D; S.element(L); ) {
          for (var j = 0; j < E.length; j++) {
            var Y = E[j], q = Y.selector, ee = Y.context;
            if (X(L, q) && F(ee, D) && F(ee, L)) {
              var B = Y.listeners;
              I.currentTarget = L;
              for (var Z = 0; Z < B.length; Z++) {
                var me = B[Z];
                _t(me.options, w) && me.func(I);
              }
            }
          }
          L = K(L);
        }
      }
      function g(d) {
        return h(d, !0);
      }
      return (e = t.document) == null || e.createElement("div").addEventListener("test", null, { get capture() {
        return l.supportsOptions = !0;
      }, get passive() {
        return l.supportsPassive = !0;
      } }), t.events = l, l;
    } }, fr = { methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"], search: function(t) {
      for (var e = 0, r = fr.methodOrder; e < r.length; e++) {
        var n = r[e], o = fr[n](t);
        if (o) return o;
      }
      return null;
    }, simulationResume: function(t) {
      var e = t.pointerType, r = t.eventType, n = t.eventTarget, o = t.scope;
      if (!/down|start/i.test(r)) return null;
      for (var l = 0, c = o.interactions.list; l < c.length; l++) {
        var p = c[l], h = n;
        if (p.simulation && p.simulation.allowResume && p.pointerType === e) for (; h; ) {
          if (h === p.element) return p;
          h = K(h);
        }
      }
      return null;
    }, mouseOrPen: function(t) {
      var e, r = t.pointerId, n = t.pointerType, o = t.eventType, l = t.scope;
      if (n !== "mouse" && n !== "pen") return null;
      for (var c = 0, p = l.interactions.list; c < p.length; c++) {
        var h = p[c];
        if (h.pointerType === n) {
          if (h.simulation && !En(h, r)) continue;
          if (h.interacting()) return h;
          e || (e = h);
        }
      }
      if (e) return e;
      for (var g = 0, d = l.interactions.list; g < d.length; g++) {
        var b = d[g];
        if (!(b.pointerType !== n || /down/i.test(o) && b.simulation)) return b;
      }
      return null;
    }, hasPointer: function(t) {
      for (var e = t.pointerId, r = 0, n = t.scope.interactions.list; r < n.length; r++) {
        var o = n[r];
        if (En(o, e)) return o;
      }
      return null;
    }, idle: function(t) {
      for (var e = t.pointerType, r = 0, n = t.scope.interactions.list; r < n.length; r++) {
        var o = n[r];
        if (o.pointers.length === 1) {
          var l = o.interactable;
          if (l && (!l.options.gesture || !l.options.gesture.enabled)) continue;
        } else if (o.pointers.length >= 2) continue;
        if (!o.interacting() && e === o.pointerType) return o;
      }
      return null;
    } };
    function En(t, e) {
      return t.pointers.some(function(r) {
        return r.id === e;
      });
    }
    var Wo = fr, vr = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];
    function In(t, e) {
      return function(r) {
        var n = e.interactions.list, o = Qr(r), l = en(r), c = l[0], p = l[1], h = [];
        if (/^touch/.test(r.type)) {
          e.prevTouchTime = e.now();
          for (var g = 0, d = r.changedTouches; g < d.length; g++) {
            var b = d[g], w = { pointer: b, pointerId: st(b), pointerType: o, eventType: r.type, eventTarget: c, curEventTarget: p, scope: e }, I = Pn(w);
            h.push([w.pointer, w.eventTarget, w.curEventTarget, I]);
          }
        } else {
          var E = !1;
          if (!R.supportsPointerEvent && /mouse/.test(r.type)) {
            for (var D = 0; D < n.length && !E; D++) E = n[D].pointerType !== "mouse" && n[D].pointerIsDown;
            E = E || e.now() - e.prevTouchTime < 500 || r.timeStamp === 0;
          }
          if (!E) {
            var L = { pointer: r, pointerId: st(r), pointerType: o, eventType: r.type, curEventTarget: p, eventTarget: c, scope: e }, j = Pn(L);
            h.push([L.pointer, L.eventTarget, L.curEventTarget, j]);
          }
        }
        for (var Y = 0; Y < h.length; Y++) {
          var q = h[Y], ee = q[0], B = q[1], Z = q[2];
          q[3][t](ee, r, B, Z);
        }
      };
    }
    function Pn(t) {
      var e = t.pointerType, r = t.scope, n = { interaction: Wo.search(t), searchDetails: t };
      return r.fire("interactions:find", n), n.interaction || r.interactions.new({ pointerType: e });
    }
    function gr(t, e) {
      var r = t.doc, n = t.scope, o = t.options, l = n.interactions.docEvents, c = n.events, p = c[e];
      for (var h in n.browser.isIOS && !o.events && (o.events = { passive: !1 }), c.delegatedEvents) p(r, h, c.delegateListener), p(r, h, c.delegateUseCapture, !0);
      for (var g = o && o.events, d = 0; d < l.length; d++) {
        var b = l[d];
        p(r, b.type, b.listener, g);
      }
    }
    var Fo = { id: "core/interactions", install: function(t) {
      for (var e = {}, r = 0; r < vr.length; r++) {
        var n = vr[r];
        e[n] = In(n, t);
      }
      var o, l = R.pEventTypes;
      function c() {
        for (var p = 0, h = t.interactions.list; p < h.length; p++) {
          var g = h[p];
          if (g.pointerIsDown && g.pointerType === "touch" && !g._interacting) for (var d = function() {
            var I = w[b];
            t.documents.some(function(E) {
              return F(E.doc, I.downTarget);
            }) || g.removePointer(I.pointer, I.event);
          }, b = 0, w = g.pointers; b < w.length; b++) d();
        }
      }
      (o = W.PointerEvent ? [{ type: l.down, listener: c }, { type: l.down, listener: e.pointerDown }, { type: l.move, listener: e.pointerMove }, { type: l.up, listener: e.pointerUp }, { type: l.cancel, listener: e.pointerUp }] : [{ type: "mousedown", listener: e.pointerDown }, { type: "mousemove", listener: e.pointerMove }, { type: "mouseup", listener: e.pointerUp }, { type: "touchstart", listener: c }, { type: "touchstart", listener: e.pointerDown }, { type: "touchmove", listener: e.pointerMove }, { type: "touchend", listener: e.pointerUp }, { type: "touchcancel", listener: e.pointerUp }]).push({ type: "blur", listener: function(p) {
        for (var h = 0, g = t.interactions.list; h < g.length; h++)
          g[h].documentBlur(p);
      } }), t.prevTouchTime = 0, t.Interaction = function(p) {
        O(g, p);
        var h = _(g);
        function g() {
          return v(this, g), h.apply(this, arguments);
        }
        return y(g, [{ key: "pointerMoveTolerance", get: function() {
          return t.interactions.pointerMoveTolerance;
        }, set: function(d) {
          t.interactions.pointerMoveTolerance = d;
        } }, { key: "_now", value: function() {
          return t.now();
        } }]), g;
      }(Ro), t.interactions = { list: [], new: function(p) {
        p.scopeFire = function(g, d) {
          return t.fire(g, d);
        };
        var h = new t.Interaction(p);
        return t.interactions.list.push(h), h;
      }, listeners: e, docEvents: o, pointerMoveTolerance: 1 }, t.usePlugin(mn);
    }, listeners: { "scope:add-document": function(t) {
      return gr(t, "add");
    }, "scope:remove-document": function(t) {
      return gr(t, "remove");
    }, "interactable:unset": function(t, e) {
      for (var r = t.interactable, n = e.interactions.list.length - 1; n >= 0; n--) {
        var o = e.interactions.list[n];
        o.interactable === r && (o.stop(), e.fire("interactions:destroy", { interaction: o }), o.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(n, 1));
      }
    } }, onDocSignal: gr, doOnInteractions: In, methodNames: vr }, Uo = Fo, Le = function(t) {
      return t[t.On = 0] = "On", t[t.Off = 1] = "Off", t;
    }(Le || {}), No = function() {
      function t(e, r, n, o) {
        v(this, t), this.target = void 0, this.options = void 0, this._actions = void 0, this.events = new Mn(), this._context = void 0, this._win = void 0, this._doc = void 0, this._scopeEvents = void 0, this._actions = r.actions, this.target = e, this._context = r.context || n, this._win = te(ke(e) ? this._context : e), this._doc = this._win.document, this._scopeEvents = o, this.set(r);
      }
      return y(t, [{ key: "_defaults", get: function() {
        return { base: {}, perAction: {}, actions: {} };
      } }, { key: "setOnEvents", value: function(e, r) {
        return S.func(r.onstart) && this.on("".concat(e, "start"), r.onstart), S.func(r.onmove) && this.on("".concat(e, "move"), r.onmove), S.func(r.onend) && this.on("".concat(e, "end"), r.onend), S.func(r.oninertiastart) && this.on("".concat(e, "inertiastart"), r.oninertiastart), this;
      } }, { key: "updatePerActionListeners", value: function(e, r, n) {
        var o, l = this, c = (o = this._actions.map[e]) == null ? void 0 : o.filterEventType, p = function(h) {
          return (c == null || c(h)) && xt(h, l._actions);
        };
        (S.array(r) || S.object(r)) && this._onOff(Le.Off, e, r, void 0, p), (S.array(n) || S.object(n)) && this._onOff(Le.On, e, n, void 0, p);
      } }, { key: "setPerAction", value: function(e, r) {
        var n = this._defaults;
        for (var o in r) {
          var l = o, c = this.options[e], p = r[l];
          l === "listeners" && this.updatePerActionListeners(e, c.listeners, p), S.array(p) ? c[l] = rn(p) : S.plainObject(p) ? (c[l] = H(c[l] || {}, Be(p)), S.object(n.perAction[l]) && "enabled" in n.perAction[l] && (c[l].enabled = p.enabled !== !1)) : S.bool(p) && S.object(n.perAction[l]) ? c[l].enabled = p : c[l] = p;
        }
      } }, { key: "getRect", value: function(e) {
        return e = e || (S.element(this.target) ? this.target : null), S.string(this.target) && (e = e || this._context.querySelector(this.target)), Oe(e);
      } }, { key: "rectChecker", value: function(e) {
        var r = this;
        return S.func(e) ? (this.getRect = function(n) {
          var o = H({}, e.apply(r, n));
          return "width" in o || (o.width = o.right - o.left, o.height = o.bottom - o.top), o;
        }, this) : e === null ? (delete this.getRect, this) : this.getRect;
      } }, { key: "_backCompatOption", value: function(e, r) {
        if (ke(r) || S.object(r)) {
          for (var n in this.options[e] = r, this._actions.map) this.options[n][e] = r;
          return this;
        }
        return this.options[e];
      } }, { key: "origin", value: function(e) {
        return this._backCompatOption("origin", e);
      } }, { key: "deltaSource", value: function(e) {
        return e === "page" || e === "client" ? (this.options.deltaSource = e, this) : this.options.deltaSource;
      } }, { key: "getAllElements", value: function() {
        var e = this.target;
        return S.string(e) ? Array.from(this._context.querySelectorAll(e)) : S.func(e) && e.getAllElements ? e.getAllElements() : S.element(e) ? [e] : [];
      } }, { key: "context", value: function() {
        return this._context;
      } }, { key: "inContext", value: function(e) {
        return this._context === e.ownerDocument || F(this._context, e);
      } }, { key: "testIgnoreAllow", value: function(e, r, n) {
        return !this.testIgnore(e.ignoreFrom, r, n) && this.testAllow(e.allowFrom, r, n);
      } }, { key: "testAllow", value: function(e, r, n) {
        return !e || !!S.element(n) && (S.string(e) ? pe(n, e, r) : !!S.element(e) && F(e, n));
      } }, { key: "testIgnore", value: function(e, r, n) {
        return !(!e || !S.element(n)) && (S.string(e) ? pe(n, e, r) : !!S.element(e) && F(e, n));
      } }, { key: "fire", value: function(e) {
        return this.events.fire(e), this;
      } }, { key: "_onOff", value: function(e, r, n, o, l) {
        S.object(r) && !S.array(r) && (o = n, n = null);
        var c = Ue(r, n, l);
        for (var p in c) {
          p === "wheel" && (p = R.wheelEvent);
          for (var h = 0, g = c[p]; h < g.length; h++) {
            var d = g[h];
            xt(p, this._actions) ? this.events[e === Le.On ? "on" : "off"](p, d) : S.string(this.target) ? this._scopeEvents[e === Le.On ? "addDelegate" : "removeDelegate"](this.target, this._context, p, d, o) : this._scopeEvents[e === Le.On ? "add" : "remove"](this.target, p, d, o);
          }
        }
        return this;
      } }, { key: "on", value: function(e, r, n) {
        return this._onOff(Le.On, e, r, n);
      } }, { key: "off", value: function(e, r, n) {
        return this._onOff(Le.Off, e, r, n);
      } }, { key: "set", value: function(e) {
        var r = this._defaults;
        for (var n in S.object(e) || (e = {}), this.options = Be(r.base), this._actions.methodDict) {
          var o = n, l = this._actions.methodDict[o];
          this.options[o] = {}, this.setPerAction(o, H(H({}, r.perAction), r.actions[o])), this[l](e[o]);
        }
        for (var c in e) c !== "getRect" ? S.func(this[c]) && this[c](e[c]) : this.rectChecker(e.getRect);
        return this;
      } }, { key: "unset", value: function() {
        if (S.string(this.target)) for (var e in this._scopeEvents.delegatedEvents) for (var r = this._scopeEvents.delegatedEvents[e], n = r.length - 1; n >= 0; n--) {
          var o = r[n], l = o.selector, c = o.context, p = o.listeners;
          l === this.target && c === this._context && r.splice(n, 1);
          for (var h = p.length - 1; h >= 0; h--) this._scopeEvents.removeDelegate(this.target, this._context, e, p[h][0], p[h][1]);
        }
        else this._scopeEvents.remove(this.target, "all");
      } }]), t;
    }(), Yo = function() {
      function t(e) {
        var r = this;
        v(this, t), this.list = [], this.selectorMap = {}, this.scope = void 0, this.scope = e, e.addListeners({ "interactable:unset": function(n) {
          var o = n.interactable, l = o.target, c = S.string(l) ? r.selectorMap[l] : l[r.scope.id], p = at(c, function(h) {
            return h === o;
          });
          c.splice(p, 1);
        } });
      }
      return y(t, [{ key: "new", value: function(e, r) {
        r = H(r || {}, { actions: this.scope.actions });
        var n = new this.scope.Interactable(e, r, this.scope.document, this.scope.events);
        return this.scope.addDocument(n._doc), this.list.push(n), S.string(e) ? (this.selectorMap[e] || (this.selectorMap[e] = []), this.selectorMap[e].push(n)) : (n.target[this.scope.id] || Object.defineProperty(e, this.scope.id, { value: [], configurable: !0 }), e[this.scope.id].push(n)), this.scope.fire("interactable:new", { target: e, options: r, interactable: n, win: this.scope._win }), n;
      } }, { key: "getExisting", value: function(e, r) {
        var n = r && r.context || this.scope.document, o = S.string(e), l = o ? this.selectorMap[e] : e[this.scope.id];
        if (l) return lt(l, function(c) {
          return c._context === n && (o || c.inContext(e));
        });
      } }, { key: "forEachMatch", value: function(e, r) {
        for (var n = 0, o = this.list; n < o.length; n++) {
          var l = o[n], c = void 0;
          if ((S.string(l.target) ? S.element(e) && X(e, l.target) : e === l.target) && l.inContext(e) && (c = r(l)), c !== void 0) return c;
        }
      } }]), t;
    }(), Go = function() {
      function t() {
        var e = this;
        v(this, t), this.id = "__interact_scope_".concat(Math.floor(100 * Math.random())), this.isInitialized = !1, this.listenerMaps = [], this.browser = R, this.defaults = Be(yn), this.Eventable = Mn, this.actions = { map: {}, phases: { start: !0, move: !0, end: !0 }, methodDict: {}, phaselessTypes: {} }, this.interactStatic = function(n) {
          var o = function l(c, p) {
            var h = n.interactables.getExisting(c, p);
            return h || ((h = n.interactables.new(c, p)).events.global = l.globalEvents), h;
          };
          return o.getPointerAverage = Jr, o.getTouchBBox = Qt, o.getTouchDistance = er, o.getTouchAngle = tr, o.getElementRect = Oe, o.getElementClientRect = ve, o.matchesSelector = X, o.closest = A, o.globalEvents = {}, o.version = "1.10.27", o.scope = n, o.use = function(l, c) {
            return this.scope.usePlugin(l, c), this;
          }, o.isSet = function(l, c) {
            return !!this.scope.interactables.get(l, c && c.context);
          }, o.on = ct(function(l, c, p) {
            if (S.string(l) && l.search(" ") !== -1 && (l = l.trim().split(/ +/)), S.array(l)) {
              for (var h = 0, g = l; h < g.length; h++) {
                var d = g[h];
                this.on(d, c, p);
              }
              return this;
            }
            if (S.object(l)) {
              for (var b in l) this.on(b, l[b], c);
              return this;
            }
            return xt(l, this.scope.actions) ? this.globalEvents[l] ? this.globalEvents[l].push(c) : this.globalEvents[l] = [c] : this.scope.events.add(this.scope.document, l, c, { options: p }), this;
          }, "The interact.on() method is being deprecated"), o.off = ct(function(l, c, p) {
            if (S.string(l) && l.search(" ") !== -1 && (l = l.trim().split(/ +/)), S.array(l)) {
              for (var h = 0, g = l; h < g.length; h++) {
                var d = g[h];
                this.off(d, c, p);
              }
              return this;
            }
            if (S.object(l)) {
              for (var b in l) this.off(b, l[b], c);
              return this;
            }
            var w;
            return xt(l, this.scope.actions) ? l in this.globalEvents && (w = this.globalEvents[l].indexOf(c)) !== -1 && this.globalEvents[l].splice(w, 1) : this.scope.events.remove(this.scope.document, l, c, p), this;
          }, "The interact.off() method is being deprecated"), o.debug = function() {
            return this.scope;
          }, o.supportsTouch = function() {
            return R.supportsTouch;
          }, o.supportsPointerEvent = function() {
            return R.supportsPointerEvent;
          }, o.stop = function() {
            for (var l = 0, c = this.scope.interactions.list; l < c.length; l++) c[l].stop();
            return this;
          }, o.pointerMoveTolerance = function(l) {
            return S.number(l) ? (this.scope.interactions.pointerMoveTolerance = l, this) : this.scope.interactions.pointerMoveTolerance;
          }, o.addDocument = function(l, c) {
            this.scope.addDocument(l, c);
          }, o.removeDocument = function(l) {
            this.scope.removeDocument(l);
          }, o;
        }(this), this.InteractEvent = hr, this.Interactable = void 0, this.interactables = new Yo(this), this._win = void 0, this.document = void 0, this.window = void 0, this.documents = [], this._plugins = { list: [], map: {} }, this.onWindowUnload = function(n) {
          return e.removeDocument(n.target);
        };
        var r = this;
        this.Interactable = function(n) {
          O(l, n);
          var o = _(l);
          function l() {
            return v(this, l), o.apply(this, arguments);
          }
          return y(l, [{ key: "_defaults", get: function() {
            return r.defaults;
          } }, { key: "set", value: function(c) {
            return M($(l.prototype), "set", this).call(this, c), r.fire("interactable:set", { options: c, interactable: this }), this;
          } }, { key: "unset", value: function() {
            M($(l.prototype), "unset", this).call(this);
            var c = r.interactables.list.indexOf(this);
            c < 0 || (r.interactables.list.splice(c, 1), r.fire("interactable:unset", { interactable: this }));
          } }]), l;
        }(No);
      }
      return y(t, [{ key: "addListeners", value: function(e, r) {
        this.listenerMaps.push({ id: r, map: e });
      } }, { key: "fire", value: function(e, r) {
        for (var n = 0, o = this.listenerMaps; n < o.length; n++) {
          var l = o[n].map[e];
          if (l && l(r, this, e) === !1) return !1;
        }
      } }, { key: "init", value: function(e) {
        return this.isInitialized ? this : function(r, n) {
          return r.isInitialized = !0, S.window(n) && Q(n), W.init(n), R.init(n), je.init(n), r.window = n, r.document = n.document, r.usePlugin(Uo), r.usePlugin(Ho), r;
        }(this, e);
      } }, { key: "pluginIsInstalled", value: function(e) {
        var r = e.id;
        return r ? !!this._plugins.map[r] : this._plugins.list.indexOf(e) !== -1;
      } }, { key: "usePlugin", value: function(e, r) {
        if (!this.isInitialized) return this;
        if (this.pluginIsInstalled(e)) return this;
        if (e.id && (this._plugins.map[e.id] = e), this._plugins.list.push(e), e.install && e.install(this, r), e.listeners && e.before) {
          for (var n = 0, o = this.listenerMaps.length, l = e.before.reduce(function(p, h) {
            return p[h] = !0, p[Dn(h)] = !0, p;
          }, {}); n < o; n++) {
            var c = this.listenerMaps[n].id;
            if (c && (l[c] || l[Dn(c)])) break;
          }
          this.listenerMaps.splice(n, 0, { id: e.id, map: e.listeners });
        } else e.listeners && this.listenerMaps.push({ id: e.id, map: e.listeners });
        return this;
      } }, { key: "addDocument", value: function(e, r) {
        if (this.getDocIndex(e) !== -1) return !1;
        var n = te(e);
        r = r ? H({}, r) : {}, this.documents.push({ doc: e, options: r }), this.events.documents.push(e), e !== this.document && this.events.add(n, "unload", this.onWindowUnload), this.fire("scope:add-document", { doc: e, window: n, scope: this, options: r });
      } }, { key: "removeDocument", value: function(e) {
        var r = this.getDocIndex(e), n = te(e), o = this.documents[r].options;
        this.events.remove(n, "unload", this.onWindowUnload), this.documents.splice(r, 1), this.events.documents.splice(r, 1), this.fire("scope:remove-document", { doc: e, window: n, scope: this, options: o });
      } }, { key: "getDocIndex", value: function(e) {
        for (var r = 0; r < this.documents.length; r++) if (this.documents[r].doc === e) return r;
        return -1;
      } }, { key: "getDocOptions", value: function(e) {
        var r = this.getDocIndex(e);
        return r === -1 ? null : this.documents[r].options;
      } }, { key: "now", value: function() {
        return (this.window.Date || Date).now();
      } }]), t;
    }();
    function Dn(t) {
      return t && t.replace(/\/.*$/, "");
    }
    var Rn = new Go(), ge = Rn.interactStatic, Ko = typeof globalThis < "u" ? globalThis : window;
    Rn.init(Ko);
    var Xo = Object.freeze({ __proto__: null, edgeTarget: function() {
    }, elements: function() {
    }, grid: function(t) {
      var e = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter(function(n) {
        var o = n[0], l = n[1];
        return o in t || l in t;
      }), r = function(n, o) {
        for (var l = t.range, c = t.limits, p = c === void 0 ? { left: -1 / 0, right: 1 / 0, top: -1 / 0, bottom: 1 / 0 } : c, h = t.offset, g = h === void 0 ? { x: 0, y: 0 } : h, d = { range: l, grid: t, x: null, y: null }, b = 0; b < e.length; b++) {
          var w = e[b], I = w[0], E = w[1], D = Math.round((n - g.x) / t[I]), L = Math.round((o - g.y) / t[E]);
          d[I] = Math.max(p.left, Math.min(p.right, D * t[I] + g.x)), d[E] = Math.max(p.top, Math.min(p.bottom, L * t[E] + g.y));
        }
        return d;
      };
      return r.grid = t, r.coordFields = e, r;
    } }), Bo = { id: "snappers", install: function(t) {
      var e = t.interactStatic;
      e.snappers = H(e.snappers || {}, Xo), e.createSnapGrid = e.snappers.grid;
    } }, Vo = Bo, qo = { start: function(t) {
      var e = t.state, r = t.rect, n = t.edges, o = t.pageCoords, l = e.options, c = l.ratio, p = l.enabled, h = e.options, g = h.equalDelta, d = h.modifiers;
      c === "preserve" && (c = r.width / r.height), e.startCoords = H({}, o), e.startRect = H({}, r), e.ratio = c, e.equalDelta = g;
      var b = e.linkedEdges = { top: n.top || n.left && !n.bottom, left: n.left || n.top && !n.right, bottom: n.bottom || n.right && !n.top, right: n.right || n.bottom && !n.left };
      if (e.xIsPrimaryAxis = !(!n.left && !n.right), e.equalDelta) {
        var w = (b.left ? 1 : -1) * (b.top ? 1 : -1);
        e.edgeSign = { x: w, y: w };
      } else e.edgeSign = { x: b.left ? -1 : 1, y: b.top ? -1 : 1 };
      if (p !== !1 && H(n, b), d != null && d.length) {
        var I = new pr(t.interaction);
        I.copyFrom(t.interaction.modification), I.prepareStates(d), e.subModification = I, I.startAll(u({}, t));
      }
    }, set: function(t) {
      var e = t.state, r = t.rect, n = t.coords, o = e.linkedEdges, l = H({}, n), c = e.equalDelta ? Zo : Jo;
      if (H(t.edges, o), c(e, e.xIsPrimaryAxis, n, r), !e.subModification) return null;
      var p = H({}, r);
      mt(o, p, { x: n.x - l.x, y: n.y - l.y });
      var h = e.subModification.setAll(u(u({}, t), {}, { rect: p, edges: o, pageCoords: n, prevCoords: n, prevRect: p })), g = h.delta;
      return h.changed && (c(e, Math.abs(g.x) > Math.abs(g.y), h.coords, h.rect), H(n, h.coords)), h.eventProps;
    }, defaults: { ratio: "preserve", equalDelta: !1, modifiers: [], enabled: !1 } };
    function Zo(t, e, r) {
      var n = t.startCoords, o = t.edgeSign;
      e ? r.y = n.y + (r.x - n.x) * o.y : r.x = n.x + (r.y - n.y) * o.x;
    }
    function Jo(t, e, r, n) {
      var o = t.startRect, l = t.startCoords, c = t.ratio, p = t.edgeSign;
      if (e) {
        var h = n.width / c;
        r.y = l.y + (h - o.height) * p.y;
      } else {
        var g = n.height * c;
        r.x = l.x + (g - o.width) * p.x;
      }
    }
    var Qo = Ae(qo, "aspectRatio"), $n = function() {
    };
    $n._defaults = {};
    var Mt = $n;
    function Ye(t, e, r) {
      return S.func(t) ? ye(t, e.interactable, e.element, [r.x, r.y, e]) : ye(t, e.interactable, e.element);
    }
    var Et = { start: function(t) {
      var e = t.rect, r = t.startOffset, n = t.state, o = t.interaction, l = t.pageCoords, c = n.options, p = c.elementRect, h = H({ left: 0, top: 0, right: 0, bottom: 0 }, c.offset || {});
      if (e && p) {
        var g = Ye(c.restriction, o, l);
        if (g) {
          var d = g.right - g.left - e.width, b = g.bottom - g.top - e.height;
          d < 0 && (h.left += d, h.right += d), b < 0 && (h.top += b, h.bottom += b);
        }
        h.left += r.left - e.width * p.left, h.top += r.top - e.height * p.top, h.right += r.right - e.width * (1 - p.right), h.bottom += r.bottom - e.height * (1 - p.bottom);
      }
      n.offset = h;
    }, set: function(t) {
      var e = t.coords, r = t.interaction, n = t.state, o = n.options, l = n.offset, c = Ye(o.restriction, r, e);
      if (c) {
        var p = function(h) {
          return !h || "left" in h && "top" in h || ((h = H({}, h)).left = h.x || 0, h.top = h.y || 0, h.right = h.right || h.left + h.width, h.bottom = h.bottom || h.top + h.height), h;
        }(c);
        e.x = Math.max(Math.min(p.right - l.right, e.x), p.left + l.left), e.y = Math.max(Math.min(p.bottom - l.bottom, e.y), p.top + l.top);
      }
    }, defaults: { restriction: null, elementRect: null, offset: null, endOnly: !1, enabled: !1 } }, es = Ae(Et, "restrict"), kn = { top: 1 / 0, left: 1 / 0, bottom: -1 / 0, right: -1 / 0 }, zn = { top: -1 / 0, left: -1 / 0, bottom: 1 / 0, right: 1 / 0 };
    function jn(t, e) {
      for (var r = 0, n = ["top", "left", "bottom", "right"]; r < n.length; r++) {
        var o = n[r];
        o in t || (t[o] = e[o]);
      }
      return t;
    }
    var ht = { noInner: kn, noOuter: zn, start: function(t) {
      var e, r = t.interaction, n = t.startOffset, o = t.state, l = o.options;
      l && (e = _e(Ye(l.offset, r, r.coords.start.page))), e = e || { x: 0, y: 0 }, o.offset = { top: e.y + n.top, left: e.x + n.left, bottom: e.y - n.bottom, right: e.x - n.right };
    }, set: function(t) {
      var e = t.coords, r = t.edges, n = t.interaction, o = t.state, l = o.offset, c = o.options;
      if (r) {
        var p = H({}, e), h = Ye(c.inner, n, p) || {}, g = Ye(c.outer, n, p) || {};
        jn(h, kn), jn(g, zn), r.top ? e.y = Math.min(Math.max(g.top + l.top, p.y), h.top + l.top) : r.bottom && (e.y = Math.max(Math.min(g.bottom + l.bottom, p.y), h.bottom + l.bottom)), r.left ? e.x = Math.min(Math.max(g.left + l.left, p.x), h.left + l.left) : r.right && (e.x = Math.max(Math.min(g.right + l.right, p.x), h.right + l.right));
      }
    }, defaults: { inner: null, outer: null, offset: null, endOnly: !1, enabled: !1 } }, ts = Ae(ht, "restrictEdges"), rs = H({ get elementRect() {
      return { top: 0, left: 0, bottom: 1, right: 1 };
    }, set elementRect(t) {
    } }, Et.defaults), ns = Ae({ start: Et.start, set: Et.set, defaults: rs }, "restrictRect"), is = { width: -1 / 0, height: -1 / 0 }, os = { width: 1 / 0, height: 1 / 0 }, ss = Ae({ start: function(t) {
      return ht.start(t);
    }, set: function(t) {
      var e = t.interaction, r = t.state, n = t.rect, o = t.edges, l = r.options;
      if (o) {
        var c = ze(Ye(l.min, e, t.coords)) || is, p = ze(Ye(l.max, e, t.coords)) || os;
        r.options = { endOnly: l.endOnly, inner: H({}, ht.noInner), outer: H({}, ht.noOuter) }, o.top ? (r.options.inner.top = n.bottom - c.height, r.options.outer.top = n.bottom - p.height) : o.bottom && (r.options.inner.bottom = n.top + c.height, r.options.outer.bottom = n.top + p.height), o.left ? (r.options.inner.left = n.right - c.width, r.options.outer.left = n.right - p.width) : o.right && (r.options.inner.right = n.left + c.width, r.options.outer.right = n.left + p.width), ht.set(t), r.options = l;
      }
    }, defaults: { min: null, max: null, endOnly: !1, enabled: !1 } }, "restrictSize"), mr = { start: function(t) {
      var e, r = t.interaction, n = t.interactable, o = t.element, l = t.rect, c = t.state, p = t.startOffset, h = c.options, g = h.offsetWithOrigin ? function(w) {
        var I = w.interaction.element, E = _e(ye(w.state.options.origin, null, null, [I])), D = E || it(w.interactable, I, w.interaction.prepared.name);
        return D;
      }(t) : { x: 0, y: 0 };
      if (h.offset === "startCoords") e = { x: r.coords.start.page.x, y: r.coords.start.page.y };
      else {
        var d = ye(h.offset, n, o, [r]);
        (e = _e(d) || { x: 0, y: 0 }).x += g.x, e.y += g.y;
      }
      var b = h.relativePoints;
      c.offsets = l && b && b.length ? b.map(function(w, I) {
        return { index: I, relativePoint: w, x: p.left - l.width * w.x + e.x, y: p.top - l.height * w.y + e.y };
      }) : [{ index: 0, relativePoint: null, x: e.x, y: e.y }];
    }, set: function(t) {
      var e = t.interaction, r = t.coords, n = t.state, o = n.options, l = n.offsets, c = it(e.interactable, e.element, e.prepared.name), p = H({}, r), h = [];
      o.offsetWithOrigin || (p.x -= c.x, p.y -= c.y);
      for (var g = 0, d = l; g < d.length; g++) for (var b = d[g], w = p.x - b.x, I = p.y - b.y, E = 0, D = o.targets.length; E < D; E++) {
        var L = o.targets[E], j = void 0;
        (j = S.func(L) ? L(w, I, e._proxy, b, E) : L) && h.push({ x: (S.number(j.x) ? j.x : w) + b.x, y: (S.number(j.y) ? j.y : I) + b.y, range: S.number(j.range) ? j.range : o.range, source: L, index: E, offset: b });
      }
      for (var Y = { target: null, inRange: !1, distance: 0, range: 0, delta: { x: 0, y: 0 } }, q = 0; q < h.length; q++) {
        var ee = h[q], B = ee.range, Z = ee.x - p.x, me = ee.y - p.y, le = ot(Z, me), Te = le <= B;
        B === 1 / 0 && Y.inRange && Y.range !== 1 / 0 && (Te = !1), Y.target && !(Te ? Y.inRange && B !== 1 / 0 ? le / B < Y.distance / Y.range : B === 1 / 0 && Y.range !== 1 / 0 || le < Y.distance : !Y.inRange && le < Y.distance) || (Y.target = ee, Y.distance = le, Y.range = B, Y.inRange = Te, Y.delta.x = Z, Y.delta.y = me);
      }
      return Y.inRange && (r.x = Y.target.x, r.y = Y.target.y), n.closest = Y, Y;
    }, defaults: { range: 1 / 0, targets: null, offset: null, offsetWithOrigin: !0, origin: null, relativePoints: null, endOnly: !1, enabled: !1 } }, as = Ae(mr, "snap"), It = { start: function(t) {
      var e = t.state, r = t.edges, n = e.options;
      if (!r) return null;
      t.state = { options: { targets: null, relativePoints: [{ x: r.left ? 0 : 1, y: r.top ? 0 : 1 }], offset: n.offset || "self", origin: { x: 0, y: 0 }, range: n.range } }, e.targetFields = e.targetFields || [["width", "height"], ["x", "y"]], mr.start(t), e.offsets = t.state.offsets, t.state = e;
    }, set: function(t) {
      var e = t.interaction, r = t.state, n = t.coords, o = r.options, l = r.offsets, c = { x: n.x - l[0].x, y: n.y - l[0].y };
      r.options = H({}, o), r.options.targets = [];
      for (var p = 0, h = o.targets || []; p < h.length; p++) {
        var g = h[p], d = void 0;
        if (d = S.func(g) ? g(c.x, c.y, e) : g) {
          for (var b = 0, w = r.targetFields; b < w.length; b++) {
            var I = w[b], E = I[0], D = I[1];
            if (E in d || D in d) {
              d.x = d[E], d.y = d[D];
              break;
            }
          }
          r.options.targets.push(d);
        }
      }
      var L = mr.set(t);
      return r.options = o, L;
    }, defaults: { range: 1 / 0, targets: null, offset: null, endOnly: !1, enabled: !1 } }, ls = Ae(It, "snapSize"), br = { aspectRatio: Qo, restrictEdges: ts, restrict: es, restrictRect: ns, restrictSize: ss, snapEdges: Ae({ start: function(t) {
      var e = t.edges;
      return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? "left" : "right", e.top ? "top" : "bottom"]], It.start(t)) : null;
    }, set: It.set, defaults: H(Be(It.defaults), { targets: void 0, range: void 0, offset: { x: 0, y: 0 } }) }, "snapEdges"), snap: as, snapSize: ls, spring: Mt, avoid: Mt, transform: Mt, rubberband: Mt }, cs = { id: "modifiers", install: function(t) {
      var e = t.interactStatic;
      for (var r in t.usePlugin(bn), t.usePlugin(Vo), e.modifiers = br, br) {
        var n = br[r], o = n._defaults, l = n._methods;
        o._methods = l, t.defaults.perAction[r] = o;
      }
    } }, us = cs, An = function(t) {
      O(r, t);
      var e = _(r);
      function r(n, o, l, c, p, h) {
        var g;
        if (v(this, r), bt(T(g = e.call(this, p)), l), l !== o && bt(T(g), o), g.timeStamp = h, g.originalEvent = l, g.type = n, g.pointerId = st(o), g.pointerType = Qr(o), g.target = c, g.currentTarget = null, n === "tap") {
          var d = p.getPointerIndex(o);
          g.dt = g.timeStamp - p.pointers[d].downTime;
          var b = g.timeStamp - p.tapTime;
          g.double = !!p.prevTap && p.prevTap.type !== "doubletap" && p.prevTap.target === g.target && b < 500;
        } else n === "doubletap" && (g.dt = o.timeStamp - p.tapTime, g.double = !0);
        return g;
      }
      return y(r, [{ key: "_subtractOrigin", value: function(n) {
        var o = n.x, l = n.y;
        return this.pageX -= o, this.pageY -= l, this.clientX -= o, this.clientY -= l, this;
      } }, { key: "_addOrigin", value: function(n) {
        var o = n.x, l = n.y;
        return this.pageX += o, this.pageY += l, this.clientX += o, this.clientY += l, this;
      } }, { key: "preventDefault", value: function() {
        this.originalEvent.preventDefault();
      } }]), r;
    }(wt), dt = { id: "pointer-events/base", before: ["inertia", "modifiers", "auto-start", "actions"], install: function(t) {
      t.pointerEvents = dt, t.defaults.actions.pointerEvents = dt.defaults, H(t.actions.phaselessTypes, dt.types);
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.prevTap = null, e.tapTime = 0;
    }, "interactions:update-pointer": function(t) {
      var e = t.down, r = t.pointerInfo;
      !e && r.hold || (r.hold = { duration: 1 / 0, timeout: null });
    }, "interactions:move": function(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget;
      t.duplicate || r.pointerIsDown && !r.pointerWasMoved || (r.pointerIsDown && yr(t), He({ interaction: r, pointer: n, event: o, eventTarget: l, type: "move" }, e));
    }, "interactions:down": function(t, e) {
      (function(r, n) {
        for (var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget, h = r.pointerIndex, g = o.pointers[h].hold, d = Ce(p), b = { interaction: o, pointer: l, event: c, eventTarget: p, type: "hold", targets: [], path: d, node: null }, w = 0; w < d.length; w++) {
          var I = d[w];
          b.node = I, n.fire("pointerEvents:collect-targets", b);
        }
        if (b.targets.length) {
          for (var E = 1 / 0, D = 0, L = b.targets; D < L.length; D++) {
            var j = L[D].eventable.options.holdDuration;
            j < E && (E = j);
          }
          g.duration = E, g.timeout = setTimeout(function() {
            He({ interaction: o, eventTarget: p, pointer: l, event: c, type: "hold" }, n);
          }, E);
        }
      })(t, e), He(t, e);
    }, "interactions:up": function(t, e) {
      yr(t), He(t, e), function(r, n) {
        var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget;
        o.pointerWasMoved || He({ interaction: o, eventTarget: p, pointer: l, event: c, type: "tap" }, n);
      }(t, e);
    }, "interactions:cancel": function(t, e) {
      yr(t), He(t, e);
    } }, PointerEvent: An, fire: He, collectEventTargets: Ln, defaults: { holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: { x: 0, y: 0 } }, types: { down: !0, move: !0, up: !0, cancel: !0, tap: !0, doubletap: !0, hold: !0 } };
    function He(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget, c = t.type, p = t.targets, h = p === void 0 ? Ln(t, e) : p, g = new An(c, n, o, l, r, e.now());
      e.fire("pointerEvents:new", { pointerEvent: g });
      for (var d = { interaction: r, pointer: n, event: o, eventTarget: l, targets: h, type: c, pointerEvent: g }, b = 0; b < h.length; b++) {
        var w = h[b];
        for (var I in w.props || {}) g[I] = w.props[I];
        var E = it(w.eventable, w.node);
        if (g._subtractOrigin(E), g.eventable = w.eventable, g.currentTarget = w.node, w.eventable.fire(g), g._addOrigin(E), g.immediatePropagationStopped || g.propagationStopped && b + 1 < h.length && h[b + 1].node !== g.currentTarget) break;
      }
      if (e.fire("pointerEvents:fired", d), c === "tap") {
        var D = g.double ? He({ interaction: r, pointer: n, event: o, eventTarget: l, type: "doubletap" }, e) : g;
        r.prevTap = D, r.tapTime = D.timeStamp;
      }
      return g;
    }
    function Ln(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget, c = t.type, p = r.getPointerIndex(n), h = r.pointers[p];
      if (c === "tap" && (r.pointerWasMoved || !h || h.downTarget !== l)) return [];
      for (var g = Ce(l), d = { interaction: r, pointer: n, event: o, eventTarget: l, type: c, path: g, targets: [], node: null }, b = 0; b < g.length; b++) {
        var w = g[b];
        d.node = w, e.fire("pointerEvents:collect-targets", d);
      }
      return c === "hold" && (d.targets = d.targets.filter(function(I) {
        var E, D;
        return I.eventable.options.holdDuration === ((E = r.pointers[p]) == null || (D = E.hold) == null ? void 0 : D.duration);
      })), d.targets;
    }
    function yr(t) {
      var e = t.interaction, r = t.pointerIndex, n = e.pointers[r].hold;
      n && n.timeout && (clearTimeout(n.timeout), n.timeout = null);
    }
    var ps = Object.freeze({ __proto__: null, default: dt });
    function hs(t) {
      var e = t.interaction;
      e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null);
    }
    var ds = { id: "pointer-events/holdRepeat", install: function(t) {
      t.usePlugin(dt);
      var e = t.pointerEvents;
      e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0;
    }, listeners: ["move", "up", "cancel", "endall"].reduce(function(t, e) {
      return t["pointerEvents:".concat(e)] = hs, t;
    }, { "pointerEvents:new": function(t) {
      var e = t.pointerEvent;
      e.type === "hold" && (e.count = (e.count || 0) + 1);
    }, "pointerEvents:fired": function(t, e) {
      var r = t.interaction, n = t.pointerEvent, o = t.eventTarget, l = t.targets;
      if (n.type === "hold" && l.length) {
        var c = l[0].eventable.options.holdRepeatInterval;
        c <= 0 || (r.holdIntervalHandle = setTimeout(function() {
          e.pointerEvents.fire({ interaction: r, eventTarget: o, type: "hold", pointer: n, event: n }, e);
        }, c));
      }
    } }) }, fs = ds, vs = { id: "pointer-events/interactableTargets", install: function(t) {
      var e = t.Interactable;
      e.prototype.pointerEvents = function(n) {
        return H(this.events.options, n), this;
      };
      var r = e.prototype._backCompatOption;
      e.prototype._backCompatOption = function(n, o) {
        var l = r.call(this, n, o);
        return l === this && (this.events.options[n] = o), l;
      };
    }, listeners: { "pointerEvents:collect-targets": function(t, e) {
      var r = t.targets, n = t.node, o = t.type, l = t.eventTarget;
      e.interactables.forEachMatch(n, function(c) {
        var p = c.events, h = p.options;
        p.types[o] && p.types[o].length && c.testIgnoreAllow(h, n, l) && r.push({ node: n, eventable: p, props: { interactable: c } });
      });
    }, "interactable:new": function(t) {
      var e = t.interactable;
      e.events.getRect = function(r) {
        return e.getRect(r);
      };
    }, "interactable:set": function(t, e) {
      var r = t.interactable, n = t.options;
      H(r.events.options, e.pointerEvents.defaults), H(r.events.options, n.pointerEvents || {});
    } } }, gs = vs, ms = { id: "pointer-events", install: function(t) {
      t.usePlugin(ps), t.usePlugin(fs), t.usePlugin(gs);
    } }, bs = ms, ys = { id: "reflow", install: function(t) {
      var e = t.Interactable;
      t.actions.phases.reflow = !0, e.prototype.reflow = function(r) {
        return function(n, o, l) {
          for (var c = n.getAllElements(), p = l.window.Promise, h = p ? [] : null, g = function() {
            var b = c[d], w = n.getRect(b);
            if (!w) return 1;
            var I, E = lt(l.interactions.list, function(j) {
              return j.interacting() && j.interactable === n && j.element === b && j.prepared.name === o.name;
            });
            if (E) E.move(), h && (I = E._reflowPromise || new p(function(j) {
              E._reflowResolve = j;
            }));
            else {
              var D = ze(w), L = /* @__PURE__ */ function(j) {
                return { coords: j, get page() {
                  return this.coords.page;
                }, get client() {
                  return this.coords.client;
                }, get timeStamp() {
                  return this.coords.timeStamp;
                }, get pageX() {
                  return this.coords.page.x;
                }, get pageY() {
                  return this.coords.page.y;
                }, get clientX() {
                  return this.coords.client.x;
                }, get clientY() {
                  return this.coords.client.y;
                }, get pointerId() {
                  return this.coords.pointerId;
                }, get target() {
                  return this.coords.target;
                }, get type() {
                  return this.coords.type;
                }, get pointerType() {
                  return this.coords.pointerType;
                }, get buttons() {
                  return this.coords.buttons;
                }, preventDefault: function() {
                } };
              }({ page: { x: D.x, y: D.y }, client: { x: D.x, y: D.y }, timeStamp: l.now() });
              I = function(j, Y, q, ee, B) {
                var Z = j.interactions.new({ pointerType: "reflow" }), me = { interaction: Z, event: B, pointer: B, eventTarget: q, phase: "reflow" };
                Z.interactable = Y, Z.element = q, Z.prevEvent = B, Z.updatePointer(B, B, q, !0), Vr(Z.coords.delta), ar(Z.prepared, ee), Z._doPhase(me);
                var le = j.window, Te = le.Promise, Se = Te ? new Te(function(De) {
                  Z._reflowResolve = De;
                }) : void 0;
                return Z._reflowPromise = Se, Z.start(ee, Y, q), Z._interacting ? (Z.move(me), Z.end(B)) : (Z.stop(), Z._reflowResolve()), Z.removePointer(B, B), Se;
              }(l, n, b, o, L);
            }
            h && h.push(I);
          }, d = 0; d < c.length && !g(); d++) ;
          return h && p.all(h).then(function() {
            return n;
          });
        }(this, r, t);
      };
    }, listeners: { "interactions:stop": function(t, e) {
      var r = t.interaction;
      r.pointerType === "reflow" && (r._reflowResolve && r._reflowResolve(), function(n, o) {
        n.splice(n.indexOf(o), 1);
      }(e.interactions.list, r));
    } } }, Ts = ys;
    if (ge.use(mn), ge.use(xn), ge.use(bs), ge.use(Ao), ge.use(us), ge.use(Co), ge.use(fo), ge.use(go), ge.use(Ts), ge.default = ge, f(s) === "object" && s) try {
      s.exports = ge;
    } catch {
    }
    return ge.default = ge, ge;
  });
})(Lt, Lt.exports);
var Ss = Lt.exports;
const Tr = /* @__PURE__ */ Ze(Ss);
var xi = { exports: {} };
(function(s, i) {
  (function(a, u) {
    s.exports = u();
  })(We, function() {
    var a = 1e3, u = 6e4, f = 36e5, v = "millisecond", m = "second", y = "minute", x = "hour", O = "day", $ = "week", P = "month", T = "quarter", _ = "year", M = "date", C = "Invalid Date", z = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, N = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, G = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(W) {
      var k = ["th", "st", "nd", "rd"], R = W % 100;
      return "[" + W + (k[(R - 20) % 10] || k[R] || k[0]) + "]";
    } }, Q = function(W, k, R) {
      var F = String(W);
      return !F || F.length >= k ? W : "" + Array(k + 1 - F.length).join(R) + W;
    }, te = { s: Q, z: function(W) {
      var k = -W.utcOffset(), R = Math.abs(k), F = Math.floor(R / 60), A = R % 60;
      return (k <= 0 ? "+" : "-") + Q(F, 2, "0") + ":" + Q(A, 2, "0");
    }, m: function W(k, R) {
      if (k.date() < R.date()) return -W(R, k);
      var F = 12 * (R.year() - k.year()) + (R.month() - k.month()), A = k.clone().add(F, P), K = R - A < 0, X = k.clone().add(F + (K ? -1 : 1), P);
      return +(-(F + (R - A) / (K ? A - X : X - A)) || 0);
    }, a: function(W) {
      return W < 0 ? Math.ceil(W) || 0 : Math.floor(W);
    }, p: function(W) {
      return { M: P, y: _, w: $, d: O, D: M, h: x, m: y, s: m, ms: v, Q: T }[W] || String(W || "").toLowerCase().replace(/s$/, "");
    }, u: function(W) {
      return W === void 0;
    } }, re = "en", ue = {};
    ue[re] = G;
    var S = "$isDayjsObject", be = function(W) {
      return W instanceof de || !(!W || !W[S]);
    }, we = function W(k, R, F) {
      var A;
      if (!k) return re;
      if (typeof k == "string") {
        var K = k.toLowerCase();
        ue[K] && (A = K), R && (ue[K] = R, A = K);
        var X = k.split("-");
        if (!A && X.length > 1) return W(X[0]);
      } else {
        var ie = k.name;
        ue[ie] = k, A = ie;
      }
      return !F && A && (re = A), A || !F && re;
    }, ce = function(W, k) {
      if (be(W)) return W.clone();
      var R = typeof k == "object" ? k : {};
      return R.date = W, R.args = arguments, new de(R);
    }, ne = te;
    ne.l = we, ne.i = be, ne.w = function(W, k) {
      return ce(W, { locale: k.$L, utc: k.$u, x: k.$x, $offset: k.$offset });
    };
    var de = function() {
      function W(R) {
        this.$L = we(R.locale, null, !0), this.parse(R), this.$x = this.$x || R.x || {}, this[S] = !0;
      }
      var k = W.prototype;
      return k.parse = function(R) {
        this.$d = function(F) {
          var A = F.date, K = F.utc;
          if (A === null) return /* @__PURE__ */ new Date(NaN);
          if (ne.u(A)) return /* @__PURE__ */ new Date();
          if (A instanceof Date) return new Date(A);
          if (typeof A == "string" && !/Z$/i.test(A)) {
            var X = A.match(z);
            if (X) {
              var ie = X[2] - 1 || 0, ae = (X[7] || "0").substring(0, 3);
              return K ? new Date(Date.UTC(X[1], ie, X[3] || 1, X[4] || 0, X[5] || 0, X[6] || 0, ae)) : new Date(X[1], ie, X[3] || 1, X[4] || 0, X[5] || 0, X[6] || 0, ae);
            }
          }
          return new Date(A);
        }(R), this.init();
      }, k.init = function() {
        var R = this.$d;
        this.$y = R.getFullYear(), this.$M = R.getMonth(), this.$D = R.getDate(), this.$W = R.getDay(), this.$H = R.getHours(), this.$m = R.getMinutes(), this.$s = R.getSeconds(), this.$ms = R.getMilliseconds();
      }, k.$utils = function() {
        return ne;
      }, k.isValid = function() {
        return this.$d.toString() !== C;
      }, k.isSame = function(R, F) {
        var A = ce(R);
        return this.startOf(F) <= A && A <= this.endOf(F);
      }, k.isAfter = function(R, F) {
        return ce(R) < this.startOf(F);
      }, k.isBefore = function(R, F) {
        return this.endOf(F) < ce(R);
      }, k.$g = function(R, F, A) {
        return ne.u(R) ? this[F] : this.set(A, R);
      }, k.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, k.valueOf = function() {
        return this.$d.getTime();
      }, k.startOf = function(R, F) {
        var A = this, K = !!ne.u(F) || F, X = ne.p(R), ie = function(H, fe) {
          var ye = ne.w(A.$u ? Date.UTC(A.$y, fe, H) : new Date(A.$y, fe, H), A);
          return K ? ye : ye.endOf(O);
        }, ae = function(H, fe) {
          return ne.w(A.toDate()[H].apply(A.toDate("s"), (K ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(fe)), A);
        }, pe = this.$W, he = this.$M, ve = this.$D, Oe = "set" + (this.$u ? "UTC" : "");
        switch (X) {
          case _:
            return K ? ie(1, 0) : ie(31, 11);
          case P:
            return K ? ie(1, he) : ie(0, he + 1);
          case $:
            var Ce = this.$locale().weekStart || 0, ke = (pe < Ce ? pe + 7 : pe) - Ce;
            return ie(K ? ve - ke : ve + (6 - ke), he);
          case O:
          case M:
            return ae(Oe + "Hours", 0);
          case x:
            return ae(Oe + "Minutes", 1);
          case y:
            return ae(Oe + "Seconds", 2);
          case m:
            return ae(Oe + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, k.endOf = function(R) {
        return this.startOf(R, !1);
      }, k.$set = function(R, F) {
        var A, K = ne.p(R), X = "set" + (this.$u ? "UTC" : ""), ie = (A = {}, A[O] = X + "Date", A[M] = X + "Date", A[P] = X + "Month", A[_] = X + "FullYear", A[x] = X + "Hours", A[y] = X + "Minutes", A[m] = X + "Seconds", A[v] = X + "Milliseconds", A)[K], ae = K === O ? this.$D + (F - this.$W) : F;
        if (K === P || K === _) {
          var pe = this.clone().set(M, 1);
          pe.$d[ie](ae), pe.init(), this.$d = pe.set(M, Math.min(this.$D, pe.daysInMonth())).$d;
        } else ie && this.$d[ie](ae);
        return this.init(), this;
      }, k.set = function(R, F) {
        return this.clone().$set(R, F);
      }, k.get = function(R) {
        return this[ne.p(R)]();
      }, k.add = function(R, F) {
        var A, K = this;
        R = Number(R);
        var X = ne.p(F), ie = function(he) {
          var ve = ce(K);
          return ne.w(ve.date(ve.date() + Math.round(he * R)), K);
        };
        if (X === P) return this.set(P, this.$M + R);
        if (X === _) return this.set(_, this.$y + R);
        if (X === O) return ie(1);
        if (X === $) return ie(7);
        var ae = (A = {}, A[y] = u, A[x] = f, A[m] = a, A)[X] || 1, pe = this.$d.getTime() + R * ae;
        return ne.w(pe, this);
      }, k.subtract = function(R, F) {
        return this.add(-1 * R, F);
      }, k.format = function(R) {
        var F = this, A = this.$locale();
        if (!this.isValid()) return A.invalidDate || C;
        var K = R || "YYYY-MM-DDTHH:mm:ssZ", X = ne.z(this), ie = this.$H, ae = this.$m, pe = this.$M, he = A.weekdays, ve = A.months, Oe = A.meridiem, Ce = function(fe, ye, _e, ze) {
          return fe && (fe[ye] || fe(F, K)) || _e[ye].slice(0, ze);
        }, ke = function(fe) {
          return ne.s(ie % 12 || 12, fe, "0");
        }, H = Oe || function(fe, ye, _e) {
          var ze = fe < 12 ? "AM" : "PM";
          return _e ? ze.toLowerCase() : ze;
        };
        return K.replace(N, function(fe, ye) {
          return ye || function(_e) {
            switch (_e) {
              case "YY":
                return String(F.$y).slice(-2);
              case "YYYY":
                return ne.s(F.$y, 4, "0");
              case "M":
                return pe + 1;
              case "MM":
                return ne.s(pe + 1, 2, "0");
              case "MMM":
                return Ce(A.monthsShort, pe, ve, 3);
              case "MMMM":
                return Ce(ve, pe);
              case "D":
                return F.$D;
              case "DD":
                return ne.s(F.$D, 2, "0");
              case "d":
                return String(F.$W);
              case "dd":
                return Ce(A.weekdaysMin, F.$W, he, 2);
              case "ddd":
                return Ce(A.weekdaysShort, F.$W, he, 3);
              case "dddd":
                return he[F.$W];
              case "H":
                return String(ie);
              case "HH":
                return ne.s(ie, 2, "0");
              case "h":
                return ke(1);
              case "hh":
                return ke(2);
              case "a":
                return H(ie, ae, !0);
              case "A":
                return H(ie, ae, !1);
              case "m":
                return String(ae);
              case "mm":
                return ne.s(ae, 2, "0");
              case "s":
                return String(F.$s);
              case "ss":
                return ne.s(F.$s, 2, "0");
              case "SSS":
                return ne.s(F.$ms, 3, "0");
              case "Z":
                return X;
            }
            return null;
          }(fe) || X.replace(":", "");
        });
      }, k.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, k.diff = function(R, F, A) {
        var K, X = this, ie = ne.p(F), ae = ce(R), pe = (ae.utcOffset() - this.utcOffset()) * u, he = this - ae, ve = function() {
          return ne.m(X, ae);
        };
        switch (ie) {
          case _:
            K = ve() / 12;
            break;
          case P:
            K = ve();
            break;
          case T:
            K = ve() / 3;
            break;
          case $:
            K = (he - pe) / 6048e5;
            break;
          case O:
            K = (he - pe) / 864e5;
            break;
          case x:
            K = he / f;
            break;
          case y:
            K = he / u;
            break;
          case m:
            K = he / a;
            break;
          default:
            K = he;
        }
        return A ? K : ne.a(K);
      }, k.daysInMonth = function() {
        return this.endOf(P).$D;
      }, k.$locale = function() {
        return ue[this.$L];
      }, k.locale = function(R, F) {
        if (!R) return this.$L;
        var A = this.clone(), K = we(R, F, !0);
        return K && (A.$L = K), A;
      }, k.clone = function() {
        return ne.w(this.$d, this);
      }, k.toDate = function() {
        return new Date(this.valueOf());
      }, k.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, k.toISOString = function() {
        return this.$d.toISOString();
      }, k.toString = function() {
        return this.$d.toUTCString();
      }, W;
    }(), Ee = de.prototype;
    return ce.prototype = Ee, [["$ms", v], ["$s", m], ["$m", y], ["$H", x], ["$W", O], ["$M", P], ["$y", _], ["$D", M]].forEach(function(W) {
      Ee[W[1]] = function(k) {
        return this.$g(k, W[0], W[1]);
      };
    }), ce.extend = function(W, k) {
      return W.$i || (W(k, de, ce), W.$i = !0), ce;
    }, ce.locale = we, ce.isDayjs = be, ce.unix = function(W) {
      return ce(1e3 * W);
    }, ce.en = ue[re], ce.Ls = ue, ce.p = {}, ce;
  });
})(xi);
var xs = xi.exports;
const Me = /* @__PURE__ */ Ze(xs);
var Oi = { exports: {} };
(function(s, i) {
  (function(a, u) {
    s.exports = u();
  })(We, function() {
    var a = "minute", u = /[+-]\d\d(?::?\d\d)?/g, f = /([+-]|\d\d)/g;
    return function(v, m, y) {
      var x = m.prototype;
      y.utc = function(C) {
        var z = { date: C, utc: !0, args: arguments };
        return new m(z);
      }, x.utc = function(C) {
        var z = y(this.toDate(), { locale: this.$L, utc: !0 });
        return C ? z.add(this.utcOffset(), a) : z;
      }, x.local = function() {
        return y(this.toDate(), { locale: this.$L, utc: !1 });
      };
      var O = x.parse;
      x.parse = function(C) {
        C.utc && (this.$u = !0), this.$utils().u(C.$offset) || (this.$offset = C.$offset), O.call(this, C);
      };
      var $ = x.init;
      x.init = function() {
        if (this.$u) {
          var C = this.$d;
          this.$y = C.getUTCFullYear(), this.$M = C.getUTCMonth(), this.$D = C.getUTCDate(), this.$W = C.getUTCDay(), this.$H = C.getUTCHours(), this.$m = C.getUTCMinutes(), this.$s = C.getUTCSeconds(), this.$ms = C.getUTCMilliseconds();
        } else $.call(this);
      };
      var P = x.utcOffset;
      x.utcOffset = function(C, z) {
        var N = this.$utils().u;
        if (N(C)) return this.$u ? 0 : N(this.$offset) ? P.call(this) : this.$offset;
        if (typeof C == "string" && (C = function(re) {
          re === void 0 && (re = "");
          var ue = re.match(u);
          if (!ue) return null;
          var S = ("" + ue[0]).match(f) || ["-", 0, 0], be = S[0], we = 60 * +S[1] + +S[2];
          return we === 0 ? 0 : be === "+" ? we : -we;
        }(C), C === null)) return this;
        var G = Math.abs(C) <= 16 ? 60 * C : C, Q = this;
        if (z) return Q.$offset = G, Q.$u = C === 0, Q;
        if (C !== 0) {
          var te = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (Q = this.local().add(G + te, a)).$offset = G, Q.$x.$localOffset = te;
        } else Q = this.utc();
        return Q;
      };
      var T = x.format;
      x.format = function(C) {
        var z = C || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return T.call(this, z);
      }, x.valueOf = function() {
        var C = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * C;
      }, x.isUTC = function() {
        return !!this.$u;
      }, x.toISOString = function() {
        return this.toDate().toISOString();
      }, x.toString = function() {
        return this.toDate().toUTCString();
      };
      var _ = x.toDate;
      x.toDate = function(C) {
        return C === "s" && this.$offset ? y(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : _.call(this);
      };
      var M = x.diff;
      x.diff = function(C, z, N) {
        if (C && this.$u === C.$u) return M.call(this, C, z, N);
        var G = this.local(), Q = y(C).local();
        return M.call(G, Q, z, N);
      };
    };
  });
})(Oi);
var Os = Oi.exports;
const Cs = /* @__PURE__ */ Ze(Os);
function _s() {
  this.__data__ = [], this.size = 0;
}
var Ms = _s;
function Es(s, i) {
  return s === i || s !== s && i !== i;
}
var Ci = Es, Is = Ci;
function Ps(s, i) {
  for (var a = s.length; a--; )
    if (Is(s[a][0], i))
      return a;
  return -1;
}
var Yt = Ps, Ds = Yt, Rs = Array.prototype, $s = Rs.splice;
function ks(s) {
  var i = this.__data__, a = Ds(i, s);
  if (a < 0)
    return !1;
  var u = i.length - 1;
  return a == u ? i.pop() : $s.call(i, a, 1), --this.size, !0;
}
var zs = ks, js = Yt;
function As(s) {
  var i = this.__data__, a = js(i, s);
  return a < 0 ? void 0 : i[a][1];
}
var Ls = As, Hs = Yt;
function Ws(s) {
  return Hs(this.__data__, s) > -1;
}
var Fs = Ws, Us = Yt;
function Ns(s, i) {
  var a = this.__data__, u = Us(a, s);
  return u < 0 ? (++this.size, a.push([s, i])) : a[u][1] = i, this;
}
var Ys = Ns, Gs = Ms, Ks = zs, Xs = Ls, Bs = Fs, Vs = Ys;
function Je(s) {
  var i = -1, a = s == null ? 0 : s.length;
  for (this.clear(); ++i < a; ) {
    var u = s[i];
    this.set(u[0], u[1]);
  }
}
Je.prototype.clear = Gs;
Je.prototype.delete = Ks;
Je.prototype.get = Xs;
Je.prototype.has = Bs;
Je.prototype.set = Vs;
var Gt = Je, qs = Gt;
function Zs() {
  this.__data__ = new qs(), this.size = 0;
}
var Js = Zs;
function Qs(s) {
  var i = this.__data__, a = i.delete(s);
  return this.size = i.size, a;
}
var ea = Qs;
function ta(s) {
  return this.__data__.get(s);
}
var ra = ta;
function na(s) {
  return this.__data__.has(s);
}
var ia = na, oa = typeof We == "object" && We && We.Object === Object && We, _i = oa, sa = _i, aa = typeof self == "object" && self && self.Object === Object && self, la = sa || aa || Function("return this")(), $e = la, ca = $e, ua = ca.Symbol, kr = ua, Wn = kr, Mi = Object.prototype, pa = Mi.hasOwnProperty, ha = Mi.toString, vt = Wn ? Wn.toStringTag : void 0;
function da(s) {
  var i = pa.call(s, vt), a = s[vt];
  try {
    s[vt] = void 0;
    var u = !0;
  } catch {
  }
  var f = ha.call(s);
  return u && (i ? s[vt] = a : delete s[vt]), f;
}
var fa = da, va = Object.prototype, ga = va.toString;
function ma(s) {
  return ga.call(s);
}
var ba = ma, Fn = kr, ya = fa, Ta = ba, wa = "[object Null]", Sa = "[object Undefined]", Un = Fn ? Fn.toStringTag : void 0;
function xa(s) {
  return s == null ? s === void 0 ? Sa : wa : Un && Un in Object(s) ? ya(s) : Ta(s);
}
var Kt = xa;
function Oa(s) {
  var i = typeof s;
  return s != null && (i == "object" || i == "function");
}
var Ei = Oa, Ca = Kt, _a = Ei, Ma = "[object AsyncFunction]", Ea = "[object Function]", Ia = "[object GeneratorFunction]", Pa = "[object Proxy]";
function Da(s) {
  if (!_a(s))
    return !1;
  var i = Ca(s);
  return i == Ea || i == Ia || i == Ma || i == Pa;
}
var Ii = Da, Ra = $e, $a = Ra["__core-js_shared__"], ka = $a, wr = ka, Nn = function() {
  var s = /[^.]+$/.exec(wr && wr.keys && wr.keys.IE_PROTO || "");
  return s ? "Symbol(src)_1." + s : "";
}();
function za(s) {
  return !!Nn && Nn in s;
}
var ja = za, Aa = Function.prototype, La = Aa.toString;
function Ha(s) {
  if (s != null) {
    try {
      return La.call(s);
    } catch {
    }
    try {
      return s + "";
    } catch {
    }
  }
  return "";
}
var Pi = Ha, Wa = Ii, Fa = ja, Ua = Ei, Na = Pi, Ya = /[\\^$.*+?()[\]{}|]/g, Ga = /^\[object .+?Constructor\]$/, Ka = Function.prototype, Xa = Object.prototype, Ba = Ka.toString, Va = Xa.hasOwnProperty, qa = RegExp(
  "^" + Ba.call(Va).replace(Ya, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Za(s) {
  if (!Ua(s) || Fa(s))
    return !1;
  var i = Wa(s) ? qa : Ga;
  return i.test(Na(s));
}
var Ja = Za;
function Qa(s, i) {
  return s == null ? void 0 : s[i];
}
var el = Qa, tl = Ja, rl = el;
function nl(s, i) {
  var a = rl(s, i);
  return tl(a) ? a : void 0;
}
var Qe = nl, il = Qe, ol = $e, sl = il(ol, "Map"), zr = sl, al = Qe, ll = al(Object, "create"), Xt = ll, Yn = Xt;
function cl() {
  this.__data__ = Yn ? Yn(null) : {}, this.size = 0;
}
var ul = cl;
function pl(s) {
  var i = this.has(s) && delete this.__data__[s];
  return this.size -= i ? 1 : 0, i;
}
var hl = pl, dl = Xt, fl = "__lodash_hash_undefined__", vl = Object.prototype, gl = vl.hasOwnProperty;
function ml(s) {
  var i = this.__data__;
  if (dl) {
    var a = i[s];
    return a === fl ? void 0 : a;
  }
  return gl.call(i, s) ? i[s] : void 0;
}
var bl = ml, yl = Xt, Tl = Object.prototype, wl = Tl.hasOwnProperty;
function Sl(s) {
  var i = this.__data__;
  return yl ? i[s] !== void 0 : wl.call(i, s);
}
var xl = Sl, Ol = Xt, Cl = "__lodash_hash_undefined__";
function _l(s, i) {
  var a = this.__data__;
  return this.size += this.has(s) ? 0 : 1, a[s] = Ol && i === void 0 ? Cl : i, this;
}
var Ml = _l, El = ul, Il = hl, Pl = bl, Dl = xl, Rl = Ml;
function et(s) {
  var i = -1, a = s == null ? 0 : s.length;
  for (this.clear(); ++i < a; ) {
    var u = s[i];
    this.set(u[0], u[1]);
  }
}
et.prototype.clear = El;
et.prototype.delete = Il;
et.prototype.get = Pl;
et.prototype.has = Dl;
et.prototype.set = Rl;
var $l = et, Gn = $l, kl = Gt, zl = zr;
function jl() {
  this.size = 0, this.__data__ = {
    hash: new Gn(),
    map: new (zl || kl)(),
    string: new Gn()
  };
}
var Al = jl;
function Ll(s) {
  var i = typeof s;
  return i == "string" || i == "number" || i == "symbol" || i == "boolean" ? s !== "__proto__" : s === null;
}
var Hl = Ll, Wl = Hl;
function Fl(s, i) {
  var a = s.__data__;
  return Wl(i) ? a[typeof i == "string" ? "string" : "hash"] : a.map;
}
var Bt = Fl, Ul = Bt;
function Nl(s) {
  var i = Ul(this, s).delete(s);
  return this.size -= i ? 1 : 0, i;
}
var Yl = Nl, Gl = Bt;
function Kl(s) {
  return Gl(this, s).get(s);
}
var Xl = Kl, Bl = Bt;
function Vl(s) {
  return Bl(this, s).has(s);
}
var ql = Vl, Zl = Bt;
function Jl(s, i) {
  var a = Zl(this, s), u = a.size;
  return a.set(s, i), this.size += a.size == u ? 0 : 1, this;
}
var Ql = Jl, ec = Al, tc = Yl, rc = Xl, nc = ql, ic = Ql;
function tt(s) {
  var i = -1, a = s == null ? 0 : s.length;
  for (this.clear(); ++i < a; ) {
    var u = s[i];
    this.set(u[0], u[1]);
  }
}
tt.prototype.clear = ec;
tt.prototype.delete = tc;
tt.prototype.get = rc;
tt.prototype.has = nc;
tt.prototype.set = ic;
var Di = tt, oc = Gt, sc = zr, ac = Di, lc = 200;
function cc(s, i) {
  var a = this.__data__;
  if (a instanceof oc) {
    var u = a.__data__;
    if (!sc || u.length < lc - 1)
      return u.push([s, i]), this.size = ++a.size, this;
    a = this.__data__ = new ac(u);
  }
  return a.set(s, i), this.size = a.size, this;
}
var uc = cc, pc = Gt, hc = Js, dc = ea, fc = ra, vc = ia, gc = uc;
function rt(s) {
  var i = this.__data__ = new pc(s);
  this.size = i.size;
}
rt.prototype.clear = hc;
rt.prototype.delete = dc;
rt.prototype.get = fc;
rt.prototype.has = vc;
rt.prototype.set = gc;
var mc = rt, bc = "__lodash_hash_undefined__";
function yc(s) {
  return this.__data__.set(s, bc), this;
}
var Tc = yc;
function wc(s) {
  return this.__data__.has(s);
}
var Sc = wc, xc = Di, Oc = Tc, Cc = Sc;
function Ht(s) {
  var i = -1, a = s == null ? 0 : s.length;
  for (this.__data__ = new xc(); ++i < a; )
    this.add(s[i]);
}
Ht.prototype.add = Ht.prototype.push = Oc;
Ht.prototype.has = Cc;
var _c = Ht;
function Mc(s, i) {
  for (var a = -1, u = s == null ? 0 : s.length; ++a < u; )
    if (i(s[a], a, s))
      return !0;
  return !1;
}
var Ec = Mc;
function Ic(s, i) {
  return s.has(i);
}
var Pc = Ic, Dc = _c, Rc = Ec, $c = Pc, kc = 1, zc = 2;
function jc(s, i, a, u, f, v) {
  var m = a & kc, y = s.length, x = i.length;
  if (y != x && !(m && x > y))
    return !1;
  var O = v.get(s), $ = v.get(i);
  if (O && $)
    return O == i && $ == s;
  var P = -1, T = !0, _ = a & zc ? new Dc() : void 0;
  for (v.set(s, i), v.set(i, s); ++P < y; ) {
    var M = s[P], C = i[P];
    if (u)
      var z = m ? u(C, M, P, i, s, v) : u(M, C, P, s, i, v);
    if (z !== void 0) {
      if (z)
        continue;
      T = !1;
      break;
    }
    if (_) {
      if (!Rc(i, function(N, G) {
        if (!$c(_, G) && (M === N || f(M, N, a, u, v)))
          return _.push(G);
      })) {
        T = !1;
        break;
      }
    } else if (!(M === C || f(M, C, a, u, v))) {
      T = !1;
      break;
    }
  }
  return v.delete(s), v.delete(i), T;
}
var Ri = jc, Ac = $e, Lc = Ac.Uint8Array, Hc = Lc;
function Wc(s) {
  var i = -1, a = Array(s.size);
  return s.forEach(function(u, f) {
    a[++i] = [f, u];
  }), a;
}
var Fc = Wc;
function Uc(s) {
  var i = -1, a = Array(s.size);
  return s.forEach(function(u) {
    a[++i] = u;
  }), a;
}
var Nc = Uc, Kn = kr, Xn = Hc, Yc = Ci, Gc = Ri, Kc = Fc, Xc = Nc, Bc = 1, Vc = 2, qc = "[object Boolean]", Zc = "[object Date]", Jc = "[object Error]", Qc = "[object Map]", eu = "[object Number]", tu = "[object RegExp]", ru = "[object Set]", nu = "[object String]", iu = "[object Symbol]", ou = "[object ArrayBuffer]", su = "[object DataView]", Bn = Kn ? Kn.prototype : void 0, Sr = Bn ? Bn.valueOf : void 0;
function au(s, i, a, u, f, v, m) {
  switch (a) {
    case su:
      if (s.byteLength != i.byteLength || s.byteOffset != i.byteOffset)
        return !1;
      s = s.buffer, i = i.buffer;
    case ou:
      return !(s.byteLength != i.byteLength || !v(new Xn(s), new Xn(i)));
    case qc:
    case Zc:
    case eu:
      return Yc(+s, +i);
    case Jc:
      return s.name == i.name && s.message == i.message;
    case tu:
    case nu:
      return s == i + "";
    case Qc:
      var y = Kc;
    case ru:
      var x = u & Bc;
      if (y || (y = Xc), s.size != i.size && !x)
        return !1;
      var O = m.get(s);
      if (O)
        return O == i;
      u |= Vc, m.set(s, i);
      var $ = Gc(y(s), y(i), u, f, v, m);
      return m.delete(s), $;
    case iu:
      if (Sr)
        return Sr.call(s) == Sr.call(i);
  }
  return !1;
}
var lu = au;
function cu(s, i) {
  for (var a = -1, u = i.length, f = s.length; ++a < u; )
    s[f + a] = i[a];
  return s;
}
var uu = cu, pu = Array.isArray, jr = pu, hu = uu, du = jr;
function fu(s, i, a) {
  var u = i(s);
  return du(s) ? u : hu(u, a(s));
}
var vu = fu;
function gu(s, i) {
  for (var a = -1, u = s == null ? 0 : s.length, f = 0, v = []; ++a < u; ) {
    var m = s[a];
    i(m, a, s) && (v[f++] = m);
  }
  return v;
}
var mu = gu;
function bu() {
  return [];
}
var yu = bu, Tu = mu, wu = yu, Su = Object.prototype, xu = Su.propertyIsEnumerable, Vn = Object.getOwnPropertySymbols, Ou = Vn ? function(s) {
  return s == null ? [] : (s = Object(s), Tu(Vn(s), function(i) {
    return xu.call(s, i);
  }));
} : wu, Cu = Ou;
function _u(s, i) {
  for (var a = -1, u = Array(s); ++a < s; )
    u[a] = i(a);
  return u;
}
var Mu = _u;
function Eu(s) {
  return s != null && typeof s == "object";
}
var Vt = Eu, Iu = Kt, Pu = Vt, Du = "[object Arguments]";
function Ru(s) {
  return Pu(s) && Iu(s) == Du;
}
var $u = Ru, qn = $u, ku = Vt, $i = Object.prototype, zu = $i.hasOwnProperty, ju = $i.propertyIsEnumerable, Au = qn(/* @__PURE__ */ function() {
  return arguments;
}()) ? qn : function(s) {
  return ku(s) && zu.call(s, "callee") && !ju.call(s, "callee");
}, Lu = Au, Wt = { exports: {} };
function Hu() {
  return !1;
}
var Wu = Hu;
Wt.exports;
(function(s, i) {
  var a = $e, u = Wu, f = i && !i.nodeType && i, v = f && !0 && s && !s.nodeType && s, m = v && v.exports === f, y = m ? a.Buffer : void 0, x = y ? y.isBuffer : void 0, O = x || u;
  s.exports = O;
})(Wt, Wt.exports);
var ki = Wt.exports, Fu = 9007199254740991, Uu = /^(?:0|[1-9]\d*)$/;
function Nu(s, i) {
  var a = typeof s;
  return i = i ?? Fu, !!i && (a == "number" || a != "symbol" && Uu.test(s)) && s > -1 && s % 1 == 0 && s < i;
}
var Yu = Nu, Gu = 9007199254740991;
function Ku(s) {
  return typeof s == "number" && s > -1 && s % 1 == 0 && s <= Gu;
}
var zi = Ku, Xu = Kt, Bu = zi, Vu = Vt, qu = "[object Arguments]", Zu = "[object Array]", Ju = "[object Boolean]", Qu = "[object Date]", ep = "[object Error]", tp = "[object Function]", rp = "[object Map]", np = "[object Number]", ip = "[object Object]", op = "[object RegExp]", sp = "[object Set]", ap = "[object String]", lp = "[object WeakMap]", cp = "[object ArrayBuffer]", up = "[object DataView]", pp = "[object Float32Array]", hp = "[object Float64Array]", dp = "[object Int8Array]", fp = "[object Int16Array]", vp = "[object Int32Array]", gp = "[object Uint8Array]", mp = "[object Uint8ClampedArray]", bp = "[object Uint16Array]", yp = "[object Uint32Array]", oe = {};
oe[pp] = oe[hp] = oe[dp] = oe[fp] = oe[vp] = oe[gp] = oe[mp] = oe[bp] = oe[yp] = !0;
oe[qu] = oe[Zu] = oe[cp] = oe[Ju] = oe[up] = oe[Qu] = oe[ep] = oe[tp] = oe[rp] = oe[np] = oe[ip] = oe[op] = oe[sp] = oe[ap] = oe[lp] = !1;
function Tp(s) {
  return Vu(s) && Bu(s.length) && !!oe[Xu(s)];
}
var wp = Tp;
function Sp(s) {
  return function(i) {
    return s(i);
  };
}
var xp = Sp, Ft = { exports: {} };
Ft.exports;
(function(s, i) {
  var a = _i, u = i && !i.nodeType && i, f = u && !0 && s && !s.nodeType && s, v = f && f.exports === u, m = v && a.process, y = function() {
    try {
      var x = f && f.require && f.require("util").types;
      return x || m && m.binding && m.binding("util");
    } catch {
    }
  }();
  s.exports = y;
})(Ft, Ft.exports);
var Op = Ft.exports, Cp = wp, _p = xp, Zn = Op, Jn = Zn && Zn.isTypedArray, Mp = Jn ? _p(Jn) : Cp, ji = Mp, Ep = Mu, Ip = Lu, Pp = jr, Dp = ki, Rp = Yu, $p = ji, kp = Object.prototype, zp = kp.hasOwnProperty;
function jp(s, i) {
  var a = Pp(s), u = !a && Ip(s), f = !a && !u && Dp(s), v = !a && !u && !f && $p(s), m = a || u || f || v, y = m ? Ep(s.length, String) : [], x = y.length;
  for (var O in s)
    (i || zp.call(s, O)) && !(m && // Safari 9 has enumerable `arguments.length` in strict mode.
    (O == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    f && (O == "offset" || O == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    v && (O == "buffer" || O == "byteLength" || O == "byteOffset") || // Skip index properties.
    Rp(O, x))) && y.push(O);
  return y;
}
var Ap = jp, Lp = Object.prototype;
function Hp(s) {
  var i = s && s.constructor, a = typeof i == "function" && i.prototype || Lp;
  return s === a;
}
var Wp = Hp;
function Fp(s, i) {
  return function(a) {
    return s(i(a));
  };
}
var Up = Fp, Np = Up, Yp = Np(Object.keys, Object), Gp = Yp, Kp = Wp, Xp = Gp, Bp = Object.prototype, Vp = Bp.hasOwnProperty;
function qp(s) {
  if (!Kp(s))
    return Xp(s);
  var i = [];
  for (var a in Object(s))
    Vp.call(s, a) && a != "constructor" && i.push(a);
  return i;
}
var Zp = qp, Jp = Ii, Qp = zi;
function eh(s) {
  return s != null && Qp(s.length) && !Jp(s);
}
var th = eh, rh = Ap, nh = Zp, ih = th;
function oh(s) {
  return ih(s) ? rh(s) : nh(s);
}
var sh = oh, ah = vu, lh = Cu, ch = sh;
function uh(s) {
  return ah(s, ch, lh);
}
var ph = uh, Qn = ph, hh = 1, dh = Object.prototype, fh = dh.hasOwnProperty;
function vh(s, i, a, u, f, v) {
  var m = a & hh, y = Qn(s), x = y.length, O = Qn(i), $ = O.length;
  if (x != $ && !m)
    return !1;
  for (var P = x; P--; ) {
    var T = y[P];
    if (!(m ? T in i : fh.call(i, T)))
      return !1;
  }
  var _ = v.get(s), M = v.get(i);
  if (_ && M)
    return _ == i && M == s;
  var C = !0;
  v.set(s, i), v.set(i, s);
  for (var z = m; ++P < x; ) {
    T = y[P];
    var N = s[T], G = i[T];
    if (u)
      var Q = m ? u(G, N, T, i, s, v) : u(N, G, T, s, i, v);
    if (!(Q === void 0 ? N === G || f(N, G, a, u, v) : Q)) {
      C = !1;
      break;
    }
    z || (z = T == "constructor");
  }
  if (C && !z) {
    var te = s.constructor, re = i.constructor;
    te != re && "constructor" in s && "constructor" in i && !(typeof te == "function" && te instanceof te && typeof re == "function" && re instanceof re) && (C = !1);
  }
  return v.delete(s), v.delete(i), C;
}
var gh = vh, mh = Qe, bh = $e, yh = mh(bh, "DataView"), Th = yh, wh = Qe, Sh = $e, xh = wh(Sh, "Promise"), Oh = xh, Ch = Qe, _h = $e, Mh = Ch(_h, "Set"), Eh = Mh, Ih = Qe, Ph = $e, Dh = Ih(Ph, "WeakMap"), Rh = Dh, Or = Th, Cr = zr, _r = Oh, Mr = Eh, Er = Rh, Ai = Kt, nt = Pi, ei = "[object Map]", $h = "[object Object]", ti = "[object Promise]", ri = "[object Set]", ni = "[object WeakMap]", ii = "[object DataView]", kh = nt(Or), zh = nt(Cr), jh = nt(_r), Ah = nt(Mr), Lh = nt(Er), Ge = Ai;
(Or && Ge(new Or(new ArrayBuffer(1))) != ii || Cr && Ge(new Cr()) != ei || _r && Ge(_r.resolve()) != ti || Mr && Ge(new Mr()) != ri || Er && Ge(new Er()) != ni) && (Ge = function(s) {
  var i = Ai(s), a = i == $h ? s.constructor : void 0, u = a ? nt(a) : "";
  if (u)
    switch (u) {
      case kh:
        return ii;
      case zh:
        return ei;
      case jh:
        return ti;
      case Ah:
        return ri;
      case Lh:
        return ni;
    }
  return i;
});
var Hh = Ge, xr = mc, Wh = Ri, Fh = lu, Uh = gh, oi = Hh, si = jr, ai = ki, Nh = ji, Yh = 1, li = "[object Arguments]", ci = "[object Array]", Dt = "[object Object]", Gh = Object.prototype, ui = Gh.hasOwnProperty;
function Kh(s, i, a, u, f, v) {
  var m = si(s), y = si(i), x = m ? ci : oi(s), O = y ? ci : oi(i);
  x = x == li ? Dt : x, O = O == li ? Dt : O;
  var $ = x == Dt, P = O == Dt, T = x == O;
  if (T && ai(s)) {
    if (!ai(i))
      return !1;
    m = !0, $ = !1;
  }
  if (T && !$)
    return v || (v = new xr()), m || Nh(s) ? Wh(s, i, a, u, f, v) : Fh(s, i, x, a, u, f, v);
  if (!(a & Yh)) {
    var _ = $ && ui.call(s, "__wrapped__"), M = P && ui.call(i, "__wrapped__");
    if (_ || M) {
      var C = _ ? s.value() : s, z = M ? i.value() : i;
      return v || (v = new xr()), f(C, z, a, u, v);
    }
  }
  return T ? (v || (v = new xr()), Uh(s, i, a, u, f, v)) : !1;
}
var Xh = Kh, Bh = Xh, pi = Vt;
function Li(s, i, a, u, f) {
  return s === i ? !0 : s == null || i == null || !pi(s) && !pi(i) ? s !== s && i !== i : Bh(s, i, a, u, Li, f);
}
var Vh = Li, qh = Vh;
function Zh(s, i) {
  return qh(s, i);
}
var Jh = Zh;
const Ir = /* @__PURE__ */ Ze(Jh);
function J(s, i) {
  return typeof s.get == "function" ? s.get(i) : s[i];
}
function hi(s) {
  return typeof s.count == "function" ? s.count() : s.length;
}
function gt(s, i) {
  return hi(s) === hi(i) && s.every((a, u) => a === J(i, u.toString()));
}
function Qh(s, i) {
  const a = {};
  return s.forEach((u) => {
    a[u[i]] = u;
  }), a;
}
function $t() {
}
function Ke(...s) {
  return (i, ...a) => {
    i.preventDefault(), s.forEach((u) => u && u(i, ...a));
  };
}
function Hi({ item: s, itemContext: i, getItemProps: a, getResizeProps: u }) {
  const { left: f, right: v } = u(), { key: m, ref: y, ...x } = a(s.itemProps ?? {}), { useResizeHandle: O } = i;
  return Rt(
    "div",
    { ...x, ref: y, key: `${m}-outer` },
    O ? Rt("div", { ...f, key: `${m}-lr` }) : null,
    U("div", { className: "rct-item-content", style: { maxHeight: `${i.dimensions.height}` }, children: i.title }, `${m}-content`),
    O ? Rt("div", { ...v, key: `${m}-rr` }) : null
  );
}
function Ut(s, i, a) {
  return (i - s) / a;
}
function Nt(s, i, a, u) {
  const f = a / (i - s);
  return (u - s) * f;
}
function Ar(s, i, a, u) {
  return (i - s) / a * u + s;
}
function Lr(s, i, a, u, f) {
  let v = Me(s).startOf(a);
  if (u[a] && u[a] > 1) {
    const m = v.get(a);
    v = v.set(a, m - m % u[a]);
  }
  for (; v.valueOf() < i; ) {
    const m = Me(v).add(u[a] || 1, a).startOf(a);
    f(v, m), v = m;
  }
}
const Pr = 17;
function kt(s, i, a) {
  const u = {
    second: 1e3,
    minute: 60,
    hour: 60,
    day: 24,
    month: 30,
    year: 12
  };
  let f = "year", v = s;
  return Object.keys(u).some((m) => {
    const y = m;
    v = v / u[y];
    const x = v / a[y], O = a[y] && a[y] > 1 ? 3 * Pr : Pr, $ = i / O;
    if (x < $)
      return f = m, !0;
  }), f;
}
const Dr = {
  second: "minute",
  minute: "hour",
  hour: "day",
  day: "month",
  month: "year",
  year: "year"
};
function Hr(s) {
  if (!Dr[s])
    throw new Error(`unit ${s} is not acceptable`);
  return Dr[s];
}
function Wi({ itemTimeStart: s, itemTimeEnd: i, dragTime: a, isDragging: u, isResizing: f, resizingEdge: v, resizeTime: m }) {
  const y = i - s;
  return [
    u && a ? a : f && v === "left" && m ? m : s,
    u && a ? a + y : f && v === "right" && m ? m : i
  ];
}
function Fi({ itemTimeStart: s, itemTimeEnd: i, canvasTimeStart: a, canvasTimeEnd: u, canvasWidth: f }) {
  const v = i - s, m = Math.max(s, a), y = Math.min(i, u), x = Nt(a, u, f, m), $ = Nt(a, u, f, y) - x;
  return {
    left: x,
    width: Math.max($, 3),
    collisionLeft: s,
    collisionWidth: v
  };
}
function Wr(s, i) {
  const { groupIdKey: a } = i, u = {};
  for (let f = 0; f < s.length; f++)
    u[J(s[f], a)] = {
      index: f,
      group: s[f]
    };
  return u;
}
function Ui(s, i) {
  var f, v;
  const a = {}, u = Object.keys(i);
  for (let m = 0; m < u.length; m++) {
    const y = i[u[m]];
    a[m] = {
      index: y.index,
      group: y.group,
      items: []
    };
  }
  for (let m = 0; m < s.length; m++)
    if (s[m].dimensions !== void 0 && ((f = s[m].dimensions) == null ? void 0 : f.order) !== void 0) {
      const y = a[((v = s[m].dimensions) == null ? void 0 : v.order.index) ?? 0];
      y && y.items.push(s[m]);
    }
  return a;
}
function Fr(s, i, a, u) {
  const { itemTimeStartKey: f, itemTimeEndKey: v } = u;
  return s.filter((m) => {
    const y = Me(J(m, f)).valueOf() <= a, x = Me(J(m, v)).valueOf() >= i;
    return y && x;
  });
}
const ed = 1e-3;
function Ni(s, i, a = ed) {
  return s.collisionLeft + a < i.collisionLeft + i.collisionWidth && s.collisionLeft + s.collisionWidth - a > i.collisionLeft && s.top - 0 + a < i.top + i.height && s.top + s.height + 0 - a > i.top;
}
function Yi(s, i, a, u, f, v) {
  let m = u;
  const y = (s - i.dimensions.height) / 2;
  if (i.dimensions.stack && i.dimensions.top === null) {
    i.dimensions.top = f + y, m = Math.max(m, s);
    do {
      var x = null;
      for (let O = v - 1, $ = 0; O >= $; O--) {
        const P = a[O];
        if (P.dimensions.top !== null && P.dimensions.stack && Ni(i.dimensions, P.dimensions)) {
          x = P;
          break;
        }
      }
      x != null && (i.dimensions.top = x.dimensions.top + s, m = Math.max(m, i.dimensions.top + i.dimensions.height + y - f));
    } while (x);
  }
  return {
    groupHeight: m,
    verticalMargin: y,
    itemTop: i.dimensions.top
  };
}
function Gi(s, i, a, u) {
  var v, m;
  const f = (s - (((v = i.dimensions) == null ? void 0 : v.height) ?? 1)) / 2;
  return i.dimensions && i.dimensions.top === null && (i.dimensions.top = u + f, a = Math.max(a, s)), { groupHeight: a, verticalMargin: 0, itemTop: ((m = i.dimensions) == null ? void 0 : m.top) ?? 0 };
}
function di(s = []) {
  return s.reduce((i, a) => i + a, 0);
}
function Ki(s, i, a, u) {
  const f = [], v = [], m = Ui(s, i);
  for (const y in m) {
    const x = m[y], { items: O, group: $ } = x, P = di(f), T = $.stackItems !== void 0 ? $.stackItems : u, { groupHeight: _ } = Xi(O, T, a, P);
    v.push(P), $.height ? f.push($.height) : f.push(Math.max(_, a));
  }
  return {
    height: di(f),
    groupHeights: f,
    groupTops: v
  };
}
function Xi(s, i, a, u) {
  let f = 0, v = 0;
  for (let m = 0; m < s.length; m++) {
    const y = i ? Yi(a, s[m], s, f, u, m) : Gi(a, s[m], f, u);
    f = y.groupHeight, v = y.verticalMargin;
  }
  return { groupHeight: f, verticalMargin: v };
}
function qe(s, i, a, u, f, v, m, y, x, O, $, P, T, _, M) {
  const z = Fr(s, u, f, v).map((ue) => Vi({
    item: ue,
    keys: v,
    draggingItem: O,
    resizingItem: $,
    dragTime: P,
    resizingEdge: T,
    resizeTime: _,
    groups: i,
    newGroupOrder: M
  }));
  if (i.length === 0)
    return {
      dimensionItems: [],
      height: 0,
      groupHeights: [],
      groupTops: []
    };
  const N = Wr(i, v), G = z.map((ue) => Bi({
    item: ue,
    keys: v,
    canvasTimeStart: u,
    canvasTimeEnd: f,
    canvasWidth: a,
    groupOrders: N,
    lineHeight: m,
    itemHeightRatio: y
  })).filter((ue) => !!ue), { height: Q, groupHeights: te, groupTops: re } = Ki(G, N, m, x);
  return { dimensionItems: G, height: Q, groupHeights: te, groupTops: re };
}
function Re(s, i) {
  return s * i;
}
function Bi({ item: s, keys: i, canvasTimeStart: a, canvasTimeEnd: u, canvasWidth: f, groupOrders: v, lineHeight: m, itemHeightRatio: y }) {
  const x = J(s, i.itemIdKey), O = Fi({
    itemTimeStart: J(s, i.itemTimeStartKey),
    itemTimeEnd: J(s, i.itemTimeEndKey),
    canvasTimeStart: a,
    canvasTimeEnd: u,
    canvasWidth: f
  });
  if (O)
    return O.top = null, O.order = v[J(s, i.itemGroupKey)], O.stack = !s.isOverlay, O.height = m * y, {
      id: x,
      dimensions: O
    };
}
function Vi({ item: s, keys: i, draggingItem: a, resizingItem: u, dragTime: f, resizingEdge: v, resizeTime: m, groups: y, newGroupOrder: x }) {
  if (!u && !a)
    return s;
  const O = J(s, i.itemIdKey), $ = O === a, P = O === u, [T, _] = Wi({
    itemTimeStart: J(s, i.itemTimeStartKey),
    itemTimeEnd: J(s, i.itemTimeEndKey),
    isDragging: $,
    isResizing: P,
    dragTime: f,
    resizingEdge: v,
    resizeTime: m
  });
  return {
    ...s,
    [i.itemTimeStartKey]: T,
    [i.itemTimeEndKey]: _,
    [i.itemGroupKey]: $ ? J(y[x], i.groupIdKey) : J(s, i.itemGroupKey)
  };
}
function Ur(s, i, a) {
  const u = i - s, f = s - u * (a - 1) / 2, v = f + u * a;
  return [f, v];
}
function Rr(s, i, a, u, f, v, m) {
  const y = v.buffer, x = m.canvasTimeStart, O = m.canvasTimeEnd, $ = m.visibleTimeEnd - m.visibleTimeStart, P = i - s, T = {
    ...m,
    visibleTimeStart: s,
    visibleTimeEnd: i
  }, _ = $ * (y - 1) * 0.25;
  if (P !== $ || s <= x + _ || i >= O - _ || a) {
    const [C, z] = Ur(s, i, y);
    T.canvasTimeStart = C, T.canvasTimeEnd = z;
    const N = {
      ...m,
      ...T
    }, G = Re(N.width, v.buffer);
    Object.assign(T, qe(u, f, G, N.canvasTimeStart, N.canvasTimeEnd, v.keys, v.lineHeight, v.itemHeightRatio, v.stackItems, N.draggingItem, N.resizingItem, N.dragTime, N.resizingEdge, N.resizeTime, N.newGroupOrder));
  }
  return T;
}
const bf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NEXT_UNITS: Dr,
  calculateDimensions: Fi,
  calculateInteractionNewTimes: Wi,
  calculateScrollCanvas: Rr,
  calculateTimeForXPosition: Ar,
  calculateXPositionForTime: Nt,
  collision: Ni,
  coordinateToTimeRatio: Ut,
  getCanvasBoundariesFromVisibleTime: Ur,
  getCanvasWidth: Re,
  getGroupOrders: Wr,
  getGroupedItems: Ui,
  getItemDimensions: Bi,
  getItemWithInteractions: Vi,
  getMinUnit: kt,
  getNextUnit: Hr,
  getVisibleItems: Fr,
  groupNoStack: Gi,
  groupStack: Yi,
  iterateTimes: Lr,
  minCellWidth: Pr,
  stackAll: Ki,
  stackGroup: Xi,
  stackTimelineItems: qe
}, Symbol.toStringTag, { value: "Module" })), td = {
  fontSize: 12,
  color: "white",
  cursor: "pointer",
  background: "#2196f3",
  borderTopWidth: "1px",
  borderBottomWidth: "1px",
  borderLeftWidth: "1px",
  borderRightWidth: "1px",
  borderStyle: "solid",
  borderColor: "#1a6fb3",
  zIndex: 80
}, rd = {
  background: "#ffc107",
  borderTopWidth: "1px",
  borderLeftWidth: "1px",
  borderRightWidth: "1px",
  borderBottomWidth: "1px",
  borderStyle: "solid",
  borderColor: "#ff9800",
  zIndex: 82
}, nd = {
  willChange: "left, top, width",
  cursor: "move"
}, id = {
  borderLeftWidth: 3
}, od = {
  cursor: "w-resize"
}, sd = {
  borderRightWidth: "3px"
}, ad = {
  cursor: "e-resize"
}, ld = {
  position: "absolute",
  width: 24,
  maxWidth: "20%",
  minWidth: 2,
  height: "100%",
  top: 0,
  left: 0,
  cursor: "pointer",
  zIndex: 88
}, cd = {
  position: "absolute",
  width: 24,
  maxWidth: "20%",
  minWidth: 2,
  height: "100%",
  top: 0,
  right: 0,
  cursor: "pointer",
  zIndex: 88
}, ud = {
  getTimelineState: () => (console.warn('"getTimelineState" default func is being used'), {}),
  getLeftOffsetFromDate: () => (console.warn('"getLeftOffsetFromDate" default func is being used'), 0),
  getDateFromLeftOffsetPosition: () => (console.warn('"getDateFromLeftOffsetPosition" default func is being used'), 0),
  showPeriod: () => {
    console.warn('"showPeriod" default func is being used');
  }
}, Nr = se.createContext(ud), { Consumer: pd, Provider: hd } = Nr;
class dd extends se.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "getTimelineState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { visibleTimeStart: a, visibleTimeEnd: u, canvasTimeStart: f, canvasTimeEnd: v, canvasWidth: m, timelineUnit: y, timelineWidth: x } = this.props;
        return {
          visibleTimeStart: a,
          visibleTimeEnd: u,
          canvasTimeStart: f,
          canvasTimeEnd: v,
          canvasWidth: m,
          timelineUnit: y,
          timelineWidth: x
        };
      }
    }), Object.defineProperty(this, "getLeftOffsetFromDate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        const { canvasTimeStart: u, canvasTimeEnd: f, canvasWidth: v } = this.props;
        return Nt(u, f, v, a);
      }
    }), Object.defineProperty(this, "getDateFromLeftOffsetPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        const { canvasTimeStart: u, canvasTimeEnd: f, canvasWidth: v } = this.props;
        return Ar(u, f, v, a);
      }
    }), this.state = {
      timelineContext: {
        getTimelineState: this.getTimelineState,
        getLeftOffsetFromDate: this.getLeftOffsetFromDate,
        getDateFromLeftOffsetPosition: this.getDateFromLeftOffsetPosition,
        showPeriod: this.props.showPeriod
      }
    };
  }
  render() {
    return U(hd, { value: this.state.timelineContext, children: this.props.children });
  }
}
const qt = pd, fd = () => wi(Nr);
Me.extend(Cs);
class Yr extends xe {
  constructor(i) {
    super(i), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        interactMounted: !1,
        dragging: !1,
        dragStart: null,
        preDragPosition: null,
        dragTime: null,
        dragGroupDelta: null,
        resizing: !1,
        resizeEdge: null,
        resizeStart: null,
        resizeTime: null
      }
    }), Object.defineProperty(this, "itemId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "itemTitle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "itemDivTitle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "itemTimeStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "itemTimeEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "itemRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Si()
    }), Object.defineProperty(this, "dragLeft", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dragRight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "startedClicking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "startedTouching", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "dragInProgress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "fireInteractEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        var u;
        if (this.itemRef && this.itemRef.current) {
          const f = new CustomEvent("itemInteraction", {
            bubbles: !0,
            detail: {
              itemInteraction: a
            }
          });
          (u = this.itemRef.current) == null || u.dispatchEvent(f);
        }
      }
    }), Object.defineProperty(this, "onMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        this.state.interactMounted || (a.preventDefault(), this.startedClicking = !0);
      }
    }), Object.defineProperty(this, "onMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        !this.state.interactMounted && this.startedClicking && (this.startedClicking = !1, this.actualClick(a, "click"));
      }
    }), Object.defineProperty(this, "onTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        this.state.interactMounted || (a.preventDefault(), this.startedTouching = !0);
      }
    }), Object.defineProperty(this, "onTouchEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        !this.state.interactMounted && this.startedTouching && (this.startedTouching = !1, this.actualClick(a, "touch"));
      }
    }), Object.defineProperty(this, "handleDoubleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        a.stopPropagation(), this.props.onItemDoubleClick && this.props.onItemDoubleClick(this.itemId, a);
      }
    }), Object.defineProperty(this, "handleContextMenu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        this.props.onContextMenu && (a.preventDefault(), a.stopPropagation(), this.props.onContextMenu(this.itemId, a));
      }
    }), Object.defineProperty(this, "getDragLeftRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => this.dragLeft = a
    }), Object.defineProperty(this, "getDragRightRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => this.dragRight = a
    }), Object.defineProperty(this, "getItemProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a = {}) => {
        const u = "rct-item" + (this.props.item.className ? ` ${this.props.item.className}` : "");
        return {
          key: this.itemId,
          ref: this.itemRef,
          title: this.itemDivTitle,
          className: u + ` ${a.className ? a.className : ""}`,
          onMouseDown: Ke(this.onMouseDown, a.onMouseDown),
          onMouseUp: Ke(this.onMouseUp, a.onMouseUp),
          onTouchStart: Ke(this.onTouchStart, a.onTouchStart),
          onTouchEnd: Ke(this.onTouchEnd, a.onTouchEnd),
          onDoubleClick: Ke(this.handleDoubleClick, a.onDoubleClick),
          onContextMenu: Ke(this.handleContextMenu, a.onContextMenu),
          style: Object.assign({}, this.getItemStyle(a))
        };
      }
    }), Object.defineProperty(this, "getResizeProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a = {}) => {
        let u = "rct-item-handler rct-item-handler-left rct-item-handler-resize-left";
        a.leftClassName && (u += ` ${a.leftClassName}`);
        let f = "rct-item-handler rct-item-handler-right rct-item-handler-resize-right";
        return a.rightClassName && (f += ` ${a.rightClassName}`), {
          left: {
            ref: this.getDragLeftRef,
            className: u,
            style: Object.assign({}, ld, a.leftStyle)
          },
          right: {
            ref: this.getDragRightRef,
            className: f,
            style: Object.assign({}, cd, a.rightStyle)
          }
        };
      }
    }), this.cacheDataFromProps(i);
  }
  shouldComponentUpdate(i, a) {
    return !Ir(this.props, i) || !Ir(this.state, a);
  }
  cacheDataFromProps(i) {
    this.itemId = J(i.item, i.keys.itemIdKey), this.itemTitle = J(i.item, i.keys.itemTitleKey), this.itemDivTitle = i.keys.itemDivTitleKey ? J(i.item, i.keys.itemDivTitleKey) : this.itemTitle, this.itemTimeStart = J(i.item, i.keys.itemTimeStartKey), this.itemTimeEnd = J(i.item, i.keys.itemTimeEndKey);
  }
  getTimeRatio() {
    const { canvasTimeStart: i, canvasTimeEnd: a, canvasWidth: u } = this.props;
    return Ut(i, a, u);
  }
  dragTimeSnap(i, a) {
    const { dragSnap: u } = this.props;
    if (u) {
      const f = a ? Me().utcOffset() * 60 * 1e3 : 0;
      return Math.round(i / u) * u - f % u;
    } else
      return i;
  }
  resizeTimeSnap(i) {
    const { dragSnap: a } = this.props;
    if (a) {
      const u = this.itemTimeEnd % a;
      return Math.round((i - u) / a) * a + u;
    } else
      return i;
  }
  dragTime(i) {
    const a = Me(this.itemTimeStart);
    return this.state.dragging ? this.dragTimeSnap(this.timeFor(i) + this.state.dragStart.offset, !0) : a.valueOf();
  }
  timeFor(i) {
    const a = Ut(this.props.canvasTimeStart, this.props.canvasTimeEnd, this.props.canvasWidth), u = At(this.props.scrollRef).offsetLeft, f = jt(this.props.scrollRef);
    return (i.pageX - u + f.scrollLeft) * a + this.props.canvasTimeStart;
  }
  dragGroupDelta(i) {
    const { groupTops: a, order: u } = this.props;
    if (this.state.dragging) {
      if (!this.props.canChangeGroup)
        return 0;
      let f = 0;
      const v = At(this.props.scrollRef).offsetTop, m = jt(this.props.scrollRef);
      for (const y of Object.keys(a)) {
        const x = a[y];
        if (i.pageY - v + m.scrollTop > x)
          f = parseInt(y, 10) - u.index;
        else
          break;
      }
      return this.props.order.index + f < 0 ? 0 - this.props.order.index : f;
    } else
      return 0;
  }
  resizeTimeDelta(i, a) {
    const u = this.itemTimeEnd - this.itemTimeStart, f = this.dragTimeSnap((i.pageX - this.state.resizeStart) * this.getTimeRatio());
    return u + (a === "left" ? -f : f) < (this.props.dragSnap || 1e3) ? a === "left" ? u - (this.props.dragSnap || 1e3) : (this.props.dragSnap || 1e3) - u : f;
  }
  mountInteract() {
    const i = this.props.useResizeHandle ? ".rct-item-handler-resize-left" : !0, a = this.props.useResizeHandle ? ".rct-item-handler-resize-right" : !0;
    Tr(this.itemRef.current).resizable({
      edges: {
        left: this.canResizeLeft() && i,
        right: this.canResizeRight() && a,
        top: !1,
        bottom: !1
      },
      enabled: this.props.selected && (this.canResizeLeft() || this.canResizeRight())
    }).draggable({
      enabled: this.props.selected && this.canMove()
    }).styleCursor(!1).on("dragstart", (u) => {
      if (this.props.selected) {
        this.dragInProgress = !0, this.fireInteractEvent(!0);
        const f = this.timeFor(u);
        this.setState({
          dragging: !0,
          dragStart: {
            x: u.pageX,
            y: u.pageY,
            offset: this.itemTimeStart - f
          },
          preDragPosition: { x: u.target.offsetLeft, y: u.target.offsetTop },
          dragTime: this.itemTimeStart,
          dragGroupDelta: 0
        });
      } else
        return !1;
    }).on("dragmove", (u) => {
      this.state.dragging && this.setState((f) => {
        if (!this.dragInProgress)
          return { ...f };
        let v = this.dragTime(u);
        const m = this.dragGroupDelta(u);
        return this.props.moveResizeValidator && (v = this.props.moveResizeValidator("move", this.props.item, v)), this.props.onDrag && this.props.onDrag(this.itemId, v, this.props.order.index + m), {
          dragTime: v,
          dragGroupDelta: m
        };
      });
    }).on("dragend", (u) => {
      if (this.state.dragging) {
        if (this.props.onDrop) {
          this.dragInProgress = !1, this.fireInteractEvent(!1);
          let f = this.dragTime(u);
          this.props.moveResizeValidator && (f = this.props.moveResizeValidator("move", this.props.item, f)), this.props.onDrop(this.itemId, f, this.props.order.index + this.dragGroupDelta(u));
        }
        this.setState({
          dragging: !1,
          dragStart: null,
          preDragPosition: null,
          dragTime: null,
          dragGroupDelta: null
        });
      }
    }).on("resizestart", (u) => {
      if (this.props.selected)
        this.fireInteractEvent(!0), this.setState({
          resizing: !0,
          resizeEdge: null,
          // we don't know yet
          resizeStart: u.pageX,
          resizeTime: 0
        });
      else
        return !1;
    }).on("resizemove", (u) => {
      if (this.state.resizing) {
        let f = this.state.resizeEdge;
        f || (f = u.deltaRect.left !== 0 ? "left" : "right", this.setState({ resizeEdge: f }));
        let v = this.resizeTimeSnap(this.timeFor(u));
        this.props.moveResizeValidator && (v = this.props.moveResizeValidator("resize", this.props.item, v, f)), this.props.onResizing && this.props.onResizing(this.itemId, v, f), this.setState({
          resizeTime: v
        });
      }
    }).on("resizeend", (u) => {
      if (this.state.resizing) {
        this.fireInteractEvent(!1);
        const { resizeEdge: f } = this.state;
        let v = this.resizeTimeSnap(this.timeFor(u));
        this.props.moveResizeValidator && (v = this.props.moveResizeValidator("resize", this.props.item, v, f)), this.props.onResized && this.props.onResized(this.itemId, v, f, this.resizeTimeDelta(u, f)), this.setState({
          resizing: !1,
          resizeStart: null,
          resizeEdge: null,
          resizeTime: null
        });
      }
    }).on("tap", (u) => {
      this.actualClick(u, u.pointerType === "mouse" ? "click" : "touch");
    }), this.setState({
      interactMounted: !0
    });
  }
  canResizeLeft(i = this.props) {
    var u;
    return !i.canResizeLeft || i.minResizeWidth === void 0 ? !1 : parseInt((u = i.dimensions.width) == null ? void 0 : u.toString(), 10) >= i.minResizeWidth;
  }
  canResizeRight(i = this.props) {
    var u;
    return !i.canResizeRight || i.minResizeWidth === void 0 ? !1 : parseInt((u = i.dimensions.width) == null ? void 0 : u.toString(), 10) >= i.minResizeWidth;
  }
  canMove(i = this.props) {
    return !!i.canMove;
  }
  componentDidUpdate(i) {
    this.cacheDataFromProps(this.props);
    let { interactMounted: a } = this.state;
    const u = i.selected && this.canMove(i), f = i.selected && this.canResizeLeft(i), v = i.selected && this.canResizeRight(i), m = this.props.selected && this.canMove(this.props), y = this.props.selected && this.canResizeLeft(this.props), x = this.props.selected && this.canResizeRight(this.props);
    if (this.itemRef && this.itemRef.current) {
      if (this.props.selected && !a && (this.mountInteract(), a = !0), a && (f !== y || v !== x)) {
        const O = this.props.useResizeHandle ? this.dragLeft : !0, $ = this.props.useResizeHandle ? this.dragRight : !0;
        Tr(this.itemRef.current).resizable({
          enabled: y || x,
          edges: {
            top: !1,
            bottom: !1,
            left: y && O,
            right: x && $
          }
        });
      }
      a && u !== m && Tr(this.itemRef.current).draggable({ enabled: m });
    } else
      a = !1;
    a !== this.state.interactMounted && this.setState({
      interactMounted: a
    });
  }
  actualClick(i, a) {
    this.props.canSelect && this.props.onSelect && this.props.onSelect(this.itemId, a, i);
  }
  getItemStyle(i) {
    const a = this.props.dimensions, u = {
      position: "absolute",
      boxSizing: "border-box",
      left: `${a.left}px`,
      top: `${a.top}px`,
      width: `${a.width}px`,
      height: `${a.height}px`,
      lineHeight: `${a.height}px`
    };
    return Object.assign({}, td, this.props.selected ? rd : {}, this.props.selected && this.canMove(this.props) ? nd : {}, this.props.selected && this.canResizeLeft(this.props) ? id : {}, this.props.selected && this.canResizeLeft(this.props) && this.state.dragging ? od : {}, this.props.selected && this.canResizeRight(this.props) ? sd : {}, this.props.selected && this.canResizeRight(this.props) && this.state.dragging ? ad : {}, i.style, u);
  }
  render() {
    if (typeof this.props.order > "u" || this.props.order === null)
      return null;
    const i = this.context, a = {
      dimensions: this.props.dimensions,
      useResizeHandle: !!this.props.useResizeHandle,
      title: this.itemTitle,
      canMove: this.canMove(this.props),
      canResizeLeft: this.canResizeLeft(this.props),
      canResizeRight: this.canResizeRight(this.props),
      selected: this.props.selected,
      dragging: this.state.dragging,
      dragStart: this.state.dragStart,
      dragTime: this.state.dragTime,
      dragGroupDelta: this.state.dragGroupDelta,
      resizing: this.state.resizing,
      resizeEdge: this.state.resizeEdge,
      resizeStart: this.state.resizeStart,
      resizeTime: this.state.resizeTime
    };
    return this.props.itemRenderer ? this.props.itemRenderer({
      item: this.props.item,
      timelineContext: i,
      itemContext: a,
      getItemProps: this.getItemProps,
      getResizeProps: this.getResizeProps
    }) : Hi({
      item: this.props.item,
      itemContext: a,
      getItemProps: this.getItemProps,
      getResizeProps: this.getResizeProps
    });
  }
}
Object.defineProperty(Yr, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    selected: !1,
    itemRenderer: Hi
  }
});
Object.defineProperty(Yr, "contextType", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Nr
});
function vd(s, i) {
  const a = J(s, "canResize") !== void 0 ? J(s, "canResize") : i;
  return a === "left" || a === "both";
}
function gd(s, i) {
  const a = J(s, "canResize") !== void 0 ? J(s, "canResize") : i;
  return a === "right" || a === "both" || a === !0;
}
class md extends xe {
  shouldComponentUpdate(i) {
    return !(gt(i.groups, this.props.groups) && gt(i.items, this.props.items) && gt(i.dimensionItems, this.props.dimensionItems) && i.keys === this.props.keys && i.canvasTimeStart === this.props.canvasTimeStart && i.canvasTimeEnd === this.props.canvasTimeEnd && i.canvasWidth === this.props.canvasWidth && i.selectedItem === this.props.selectedItem && i.selected === this.props.selected && i.dragSnap === this.props.dragSnap && i.minResizeWidth === this.props.minResizeWidth && i.canChangeGroup === this.props.canChangeGroup && i.canMove === this.props.canMove && i.canResize === this.props.canResize && i.canSelect === this.props.canSelect);
  }
  isSelected(i, a) {
    if (this.props.selected) {
      const u = J(i, a);
      return this.props.selected.includes(u);
    } else
      return this.props.selectedItem === J(i, a);
  }
  getVisibleItems(i, a) {
    const { keys: u, items: f } = this.props;
    return Fr(f, i, a, u);
  }
  render() {
    const { canvasTimeStart: i, canvasTimeEnd: a, dimensionItems: u, keys: f, groups: v } = this.props, { itemIdKey: m, itemGroupKey: y } = f, x = Wr(v, f), O = this.getVisibleItems(i, a), $ = Qh(u, "id");
    return U("div", { className: "rct-items", children: O.filter((P) => $[J(P, m)]).map((P) => U(Yr, { itemProps: P.itemProps, item: P, keys: this.props.keys, order: x[J(P, y)], dimensions: $[J(P, m)].dimensions, selected: this.isSelected(P, m), canChangeGroup: J(P, "canChangeGroup") !== void 0 ? J(P, "canChangeGroup") : this.props.canChangeGroup, canMove: J(P, "canMove") !== void 0 ? J(P, "canMove") : this.props.canMove, canResizeLeft: vd(P, this.props.canResize), canResizeRight: gd(P, this.props.canResize), canSelect: J(P, "canSelect") !== void 0 ? J(P, "canSelect") : this.props.canSelect, useResizeHandle: this.props.useResizeHandle, groupTops: this.props.groupTops, canvasTimeStart: this.props.canvasTimeStart, canvasTimeEnd: this.props.canvasTimeEnd, canvasWidth: this.props.canvasWidth, dragSnap: this.props.dragSnap, minResizeWidth: this.props.minResizeWidth, onResizing: this.props.itemResizing, onResized: this.props.itemResized, moveResizeValidator: this.props.moveResizeValidator, onDrag: this.props.itemDrag, onDrop: this.props.itemDrop, onItemDoubleClick: this.props.onItemDoubleClick, onContextMenu: this.props.onItemContextMenu, onSelect: this.props.itemSelect, itemRenderer: this.props.itemRenderer, scrollRef: this.props.scrollRef }, J(P, m))) });
  }
}
class fi extends xe {
  shouldComponentUpdate(i) {
    return !(i.keys === this.props.keys && i.width === this.props.width && i.height === this.props.height && gt(i.groups, this.props.groups) && gt(i.groupHeights, this.props.groupHeights));
  }
  renderGroupContent(i, a = !1, u, f) {
    return this.props.groupRenderer ? se.createElement(this.props.groupRenderer, {
      group: i,
      isRightSidebar: a
    }) : J(i, a ? f : u);
  }
  render() {
    const { width: i, groupHeights: a, height: u, isRightSidebar: f } = this.props, { groupIdKey: v, groupTitleKey: m, groupRightTitleKey: y } = this.props.keys, x = {
      width: `${i}px`,
      height: `${u}px`
    }, O = {
      width: `${i}px`
    }, $ = this.props.groups.map((P, T) => {
      const _ = {
        height: `${a[T]}px`,
        lineHeight: `${a[T]}px`
      };
      return U("div", { className: "rct-sidebar-row rct-sidebar-row-" + (T % 2 === 0 ? "even" : "odd"), style: _, children: this.renderGroupContent(P, f, m, y) }, J(P, v));
    });
    return U("div", { className: "rct-sidebar" + (f ? " rct-sidebar-right" : ""), style: x, children: U("div", { style: O, children: $ }) });
  }
}
class bd extends xe {
  shouldComponentUpdate(i) {
    return !(i.canvasTimeStart === this.props.canvasTimeStart && i.canvasTimeEnd === this.props.canvasTimeEnd && i.canvasWidth === this.props.canvasWidth && i.lineCount === this.props.lineCount && i.minUnit === this.props.minUnit && i.timeSteps === this.props.timeSteps && i.height === this.props.height && i.verticalLineClassNamesForTime === this.props.verticalLineClassNamesForTime);
  }
  render() {
    const {
      canvasTimeStart: i,
      canvasTimeEnd: a,
      // canvasWidth,
      minUnit: u,
      timeSteps: f,
      height: v,
      verticalLineClassNamesForTime: m,
      getLeftOffsetFromDate: y
    } = this.props, x = [];
    return Lr(i, a, u, f, (O, $) => {
      const T = O.get(u === "day" ? "date" : u) === (u === "day" ? 1 : 0);
      let _ = [];
      m && (_ = m(
        O.unix() * 1e3,
        // turn into ms, which is what verticalLineClassNamesForTime expects
        $.unix() * 1e3 - 1
      ));
      const M = "rct-vl" + (T ? " rct-vl-first" : "") + (u === "day" || u === "hour" || u === "minute" ? ` rct-day-${O.day()} ` : " ") + _.join(" "), C = y(O.valueOf()), z = y($.valueOf());
      x.push(U("div", { className: M, style: {
        pointerEvents: "none",
        top: "0px",
        left: `${C}px`,
        width: `${z - C}px`,
        height: `${v}px`
      } }, `line-${O.valueOf()}`));
    }), U("div", { className: "rct-vertical-lines", children: x });
  }
}
const yd = ({ ...s }) => U(qt, { children: ({ getLeftOffsetFromDate: i }) => U(bd, { getLeftOffsetFromDate: i, ...s }) });
class Td extends xe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "handleMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.originClickX = i.clientX;
      }
    }), Object.defineProperty(this, "handleMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.props.clickTolerance !== void 0 && Math.abs(this.originClickX - i.clientX) > this.props.clickTolerance && (this.cancelClick = !0);
      }
    }), Object.defineProperty(this, "handleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.cancelClick || this.props.onClick(i), this.cancelClick = !1, this.originClickX = null;
      }
    }), Object.defineProperty(this, "originClickX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cancelClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  render() {
    const i = se.Children.only(this.props.children);
    return se.cloneElement(i, {
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp,
      onClick: this.handleClick
    });
  }
}
class wd extends xe {
  render() {
    const { onContextMenu: i, onDoubleClick: a, isEvenRow: u, style: f, onClick: v, clickTolerance: m, horizontalLineClassNamesForGroup: y, group: x } = this.props;
    let O = [];
    return y && (O = y(x)), U(Td, { clickTolerance: m, onClick: v, children: U("div", { onContextMenu: i, onDoubleClick: a, className: (u ? "rct-hl-even " : "rct-hl-odd ") + (O ? O.join(" ") : ""), style: f }) });
  }
}
class Sd extends xe {
  shouldComponentUpdate(i) {
    return !(i.canvasWidth === this.props.canvasWidth && i.lineCount === this.props.lineCount && i.groupHeights === this.props.groupHeights && i.groups === this.props.groups);
  }
  render() {
    const { canvasWidth: i, lineCount: a, groupHeights: u, onRowClick: f, onRowDoubleClick: v, clickTolerance: m, groups: y, horizontalLineClassNamesForGroup: x, onRowContextClick: O } = this.props, $ = [];
    for (let P = 0; P < a; P++)
      $.push(U(wd, { clickTolerance: m, onContextMenu: (T) => O(T, P), onClick: (T) => f(T, P), onDoubleClick: (T) => v(T, P), isEvenRow: P % 2 === 0, group: y[P], horizontalLineClassNamesForGroup: x, style: {
        width: `${i}px`,
        height: `${u[P]}px`
      } }, `horizontal-line-${P}`));
    return U("div", { className: "rct-horizontal-lines", children: $ });
  }
}
class xd extends xe {
  constructor(i) {
    super(i), Object.defineProperty(this, "scrollComponentRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Si()
    }), Object.defineProperty(this, "dragLastPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "lastTouchDistance", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "singleTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "lastSingleTouch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "isItemInteraction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "handleScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const a = this.scrollComponentRef.current.scrollLeft;
        this.props.onScroll(a);
      }
    }), Object.defineProperty(this, "handleWheel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        if (a.ctrlKey || a.metaKey || a.altKey) {
          a.preventDefault();
          const u = Hn(a.currentTarget), f = a.clientX - u.x, v = a.ctrlKey ? 10 : a.metaKey ? 3 : 1;
          this.props.onWheelZoom(v, f, a.deltaY);
        } else a.shiftKey && (a.preventDefault(), this.props.onScroll(this.scrollComponentRef.current.scrollLeft + (a.deltaY || a.deltaX)));
      }
    }), Object.defineProperty(this, "handleMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        a.button === 0 && (this.dragLastPosition = a.pageX, this.setState({
          isDragging: !0
        }));
      }
    }), Object.defineProperty(this, "handleMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        this.state.isDragging && !this.isItemInteraction && (this.props.onScroll(this.scrollComponentRef.current.scrollLeft + this.dragLastPosition - a.pageX), this.dragLastPosition = a.pageX);
      }
    }), Object.defineProperty(this, "handleMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.dragLastPosition = null, this.setState({
          isDragging: !1
        });
      }
    }), Object.defineProperty(this, "handleMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.dragLastPosition = null, this.setState({
          isDragging: !1
        });
      }
    }), Object.defineProperty(this, "handleTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        if (a.touches.length === 2)
          a.preventDefault(), this.lastTouchDistance = Math.abs(a.touches[0].screenX - a.touches[1].screenX), this.singleTouchStart = null, this.lastSingleTouch = null;
        else if (a.touches.length === 1) {
          a.preventDefault();
          const u = a.touches[0].clientX, f = a.touches[0].clientY;
          this.lastTouchDistance = null, this.singleTouchStart = { x: u, y: f, screenY: window.pageYOffset }, this.lastSingleTouch = { x: u, y: f, screenY: window.pageYOffset };
        }
      }
    }), Object.defineProperty(this, "handleTouchMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        const { width: u, onZoom: f } = this.props;
        if (this.isItemInteraction) {
          a.preventDefault();
          return;
        }
        if (this.lastTouchDistance && a.touches.length === 2) {
          a.preventDefault();
          const v = Math.abs(a.touches[0].screenX - a.touches[1].screenX), m = Hn(a.currentTarget), y = (a.touches[0].screenX + a.touches[1].screenX) / 2 - m.x;
          v !== 0 && this.lastTouchDistance !== 0 && (f(this.lastTouchDistance / v, y / u), this.lastTouchDistance = v);
        } else if (this.lastSingleTouch && a.touches.length === 1) {
          a.preventDefault();
          const v = a.touches[0].clientX, m = a.touches[0].clientY, y = v - this.lastSingleTouch.x, x = v - this.singleTouchStart.x, O = m - this.singleTouchStart.y;
          this.lastSingleTouch = { x: v, y: m, screenY: window.pageYOffset };
          const $ = Math.abs(x) * 3 > Math.abs(O), P = Math.abs(O) * 3 > Math.abs(x);
          y !== 0 && $ && this.props.onScroll(this.scrollComponentRef.current.scrollLeft - y), P && window.scrollTo(window.scrollX, this.singleTouchStart.screenY - O);
        }
      }
    }), Object.defineProperty(this, "handleTouchEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.lastTouchDistance && (this.lastTouchDistance = null), this.lastSingleTouch && (this.lastSingleTouch = null, this.singleTouchStart = null);
      }
    }), Object.defineProperty(this, "handleItemInteract", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        this.isItemInteraction = a.detail.itemInteraction;
      }
    }), this.state = {
      isDragging: !1
    };
  }
  componentDidMount() {
    this.scrollComponentRef.current && (this.props.scrollRef(this.scrollComponentRef.current), this.scrollComponentRef.current.addEventListener("wheel", this.handleWheel, { passive: !1 }), this.scrollComponentRef.current.addEventListener("itemInteraction", this.handleItemInteract), this.scrollComponentRef.current.addEventListener("touchstart", this.handleTouchStart, { passive: !1 }), this.scrollComponentRef.current.addEventListener("touchmove", this.handleTouchMove, { passive: !1 }));
  }
  componentWillUnmount() {
    this.scrollComponentRef.current && (this.scrollComponentRef.current.removeEventListener("wheel", this.handleWheel), this.scrollComponentRef.current.removeEventListener("itemInteraction", this.handleItemInteract), this.scrollComponentRef.current.removeEventListener("touchstart", this.handleTouchStart), this.scrollComponentRef.current.removeEventListener("touchmove", this.handleTouchMove));
  }
  render() {
    const { width: i, height: a, children: u } = this.props, { isDragging: f } = this.state, v = {
      width: `${i}px`,
      height: `${a + 20}px`,
      //20px to push the scroll element down off screen...?
      cursor: f ? "move" : "default",
      position: "relative"
    };
    return U("div", {
      ref: this.scrollComponentRef,
      "data-testid": "scroll-element",
      className: "rct-scroll",
      style: v,
      onMouseDown: this.handleMouseDown,
      onMouseMove: this.handleMouseMove,
      onMouseUp: this.handleMouseUp,
      onMouseLeave: this.handleMouseLeave,
      //        onTouchStart={this.handleTouchStart}
      //         onTouchMove={this.handleTouchMove}
      onTouchEnd: this.handleTouchEnd,
      onScroll: this.handleScroll,
      children: u
    });
  }
}
const Od = {
  subscribeToMouseOver: () => (console.warn('"subscribeToMouseOver" default func is being used'), () => {
  })
}, { Consumer: Cd, Provider: _d } = se.createContext(Od), Md = _d, Ed = Cd, Id = {
  markers: [],
  subscribeMarker: () => (console.warn("default subscribe marker used"), {
    unsubscribe: $t,
    getMarker: $t
  }),
  updateMarker: () => (console.warn("default subscribe marker used"), $t)
}, { Consumer: Pd, Provider: Dd } = se.createContext(Id);
let vi = 0;
const Rd = () => (vi += 1, vi + 1);
class $d extends se.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "handleSubscribeToMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => (a = {
        ...a,
        // REVIEW: in the event that we accept id to be passed to the Marker components, this line would override those
        id: Rd()
      }, this.setState((u) => ({
        markers: [...u.markers, a]
      })), {
        unsubscribe: () => {
          this.setState((u) => ({
            markers: u.markers.filter((f) => f.id !== a.id)
          }));
        },
        getMarker: () => a
      })
    }), Object.defineProperty(this, "handleUpdateMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (a) => {
        const u = this.state.markers.findIndex((f) => f.id === a.id);
        u < 0 || this.setState((f) => ({
          markers: [
            ...f.markers.slice(0, u),
            a,
            ...f.markers.slice(u + 1)
          ]
        }));
      }
    }), this.state = {
      markers: [],
      subscribeMarker: this.handleSubscribeToMarker,
      updateMarker: this.handleUpdateMarker
    };
  }
  render() {
    return U(Dd, { value: this.state, children: this.props.children });
  }
}
const Zt = Pd;
var Fe;
(function(s) {
  s.Today = "Today", s.Custom = "Custom", s.Cursor = "Cursor";
})(Fe || (Fe = {}));
const kd = {
  position: "absolute",
  top: 0,
  bottom: 0,
  width: "2px",
  backgroundColor: "black",
  // by default, pointer events (specifically click) will
  // "pass through".  This is added so that CursorMarker
  // will not get in the way of canvas click
  pointerEvents: "none"
}, Gr = (s) => ({
  ...kd,
  left: s
}), Kr = (s) => function({ styles: a }) {
  return U("div", { style: a, "data-testid": s });
}, zd = Kr("default-today-line");
let qi = class extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        date: Date.now()
      }
    }), Object.defineProperty(this, "intervalToken", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  componentDidMount() {
    this.intervalToken = this.createIntervalUpdater(this.props.interval);
  }
  componentDidUpdate(i) {
    i.interval !== this.props.interval && (clearInterval(this.intervalToken), this.intervalToken = this.createIntervalUpdater(this.props.interval));
  }
  createIntervalUpdater(i) {
    return setInterval(() => {
      this.setState({
        date: Date.now()
        // FIXME: use date utils pass in as props
      });
    }, i);
  }
  componentWillUnmount() {
    clearInterval(this.intervalToken);
  }
  render() {
    const { date: i } = this.state, a = this.props.getLeftOffsetFromDate(i), u = Gr(a);
    return this.props.renderer({ styles: u, date: i });
  }
};
Object.defineProperty(qi, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: zd
  }
});
const jd = Kr("default-customer-marker-id");
let Zi = class extends se.Component {
  render() {
    const { date: i } = this.props, a = this.props.getLeftOffsetFromDate(i), u = Gr(a);
    return this.props.renderer({ styles: u, date: i });
  }
};
Object.defineProperty(Zi, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: jd
  }
});
const Ad = Kr("default-cursor-marker");
let Ji = class extends se.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "handleCanvasMouseOver", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ leftOffset: a, date: u, isCursorOverCanvas: f }) => {
        this.setState({
          leftOffset: a,
          date: u,
          isShowingCursor: f
        });
      }
    }), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.state = {
      leftOffset: 0,
      date: 0,
      isShowingCursor: !1
    };
  }
  componentDidMount() {
    this.unsubscribe = this.props.subscribeToCanvasMouseOver(this.handleCanvasMouseOver);
  }
  componentWillUnmount() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  render() {
    const { isShowingCursor: i, leftOffset: a, date: u } = this.state;
    if (!i)
      return null;
    const f = Gr(a);
    return this.props.renderer ? this.props.renderer({ styles: f, date: u }) : null;
  }
};
Object.defineProperty(Ji, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: Ad
  }
});
const Qi = (s) => U(Ed, { children: ({ subscribeToMouseOver: i }) => U(Ji, { subscribeToCanvasMouseOver: i, ...s }) });
Qi.displayName = "CursorMarkerWrapper";
const Ld = () => U(qt, { children: ({ getLeftOffsetFromDate: s, getTimelineState: i }) => U(Zt, { children: ({ markers: a }) => {
  const u = i();
  return a.map((f) => {
    switch (f.type) {
      case Fe.Today:
        return (/* @__PURE__ */ new Date()).valueOf() >= u.canvasTimeStart && (/* @__PURE__ */ new Date()).valueOf() <= u.canvasTimeEnd ? U(qi, { getLeftOffsetFromDate: s, renderer: f.renderer, interval: f.interval }, f.id) : null;
      case Fe.Custom:
        return f.date >= u.canvasTimeStart && f.date <= u.canvasTimeEnd ? U(Zi, { renderer: f.renderer, date: f.date, getLeftOffsetFromDate: s }, f.id) : null;
      case Fe.Cursor:
        return U(Qi, { renderer: f.renderer, getLeftOffsetFromDate: s }, f.id);
      default:
        return null;
    }
  });
} }) }), Hd = {
  position: "absolute",
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
};
class Wd extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "handleMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        var a;
        if (this.subscription !== null) {
          const { pageX: u } = i, { left: f } = ((a = this.containerEl.current) == null ? void 0 : a.getBoundingClientRect()) ?? {
            left: 0
          }, v = u - f, m = this.props.getDateFromLeftOffsetPosition(v);
          this.subscription({
            leftOffset: v,
            date: m,
            isCursorOverCanvas: !0
          });
        }
      }
    }), Object.defineProperty(this, "handleMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.subscription !== null && this.subscription({ leftOffset: 0, date: 0, isCursorOverCanvas: !1 });
      }
    }), Object.defineProperty(this, "handleMouseMoveSubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => (this.subscription = i, () => {
        this.subscription = null;
      })
    }), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        subscribeToMouseOver: this.handleMouseMoveSubscribe
      }
    }), Object.defineProperty(this, "containerEl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: se.createRef()
    }), Object.defineProperty(this, "subscription", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  render() {
    return U(Md, { value: this.state, children: Ve("div", { style: Hd, onMouseMove: this.handleMouseMove, onMouseLeave: this.handleMouseLeave, ref: this.containerEl, children: [U(Ld, {}), this.props.children] }) });
  }
}
const Fd = (s) => U(qt, { children: ({ getDateFromLeftOffsetPosition: i }) => U(Wd, { getDateFromLeftOffsetPosition: i, ...s }) });
function Ud(s) {
  s._resizeEventListener = () => s.resize(), window.addEventListener("resize", s._resizeEventListener);
}
function Nd(s) {
  window.removeEventListener("resize", s._resizeEventListener);
}
const gi = { addListener: Ud, removeListener: Nd }, Yd = {
  groupIdKey: "id",
  groupTitleKey: "title",
  groupRightTitleKey: "rightTitle",
  groupLabelKey: "title",
  itemIdKey: "id",
  itemTitleKey: "title",
  itemDivTitleKey: "title",
  itemGroupKey: "group",
  itemTimeStartKey: "start_time",
  itemTimeEndKey: "end_time"
}, Gd = {
  second: 1,
  minute: 1,
  hour: 1,
  day: 1,
  month: 1,
  year: 1
}, Kd = {
  year: {
    long: "YYYY",
    mediumLong: "YYYY",
    medium: "YYYY",
    short: "YY"
  },
  month: {
    long: "MMMM YYYY",
    mediumLong: "MMMM",
    medium: "MMMM",
    short: "MM/YY"
  },
  week: {
    long: "w",
    mediumLong: "w",
    medium: "w",
    short: "w"
  },
  day: {
    long: "dddd, LL",
    mediumLong: "dddd, LL",
    medium: "dd D",
    short: "D"
  },
  hour: {
    long: "dddd, LL, HH:00",
    mediumLong: "L, HH:00",
    medium: "HH:00",
    short: "HH"
  },
  minute: {
    long: "HH:mm",
    mediumLong: "HH:mm",
    medium: "HH:mm",
    short: "mm"
  },
  second: {
    long: "mm:ss",
    mediumLong: "mm:ss",
    medium: "mm:ss",
    short: "ss"
  }
}, Xd = {
  registerScroll: () => (console.warn("default registerScroll header used"), $t),
  rightSidebarWidth: 0,
  leftSidebarWidth: 150,
  timeSteps: {}
}, eo = se.createContext(Xd);
class Bd extends se.Component {
  render() {
    const i = {
      rightSidebarWidth: this.props.rightSidebarWidth,
      leftSidebarWidth: this.props.leftSidebarWidth,
      timeSteps: this.props.timeSteps,
      registerScroll: this.props.registerScroll
    };
    return U(eo.Provider, { value: i, children: this.props.children });
  }
}
const Vd = eo, Xr = () => wi(Vd);
var to = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(s) {
  (function() {
    var i = {}.hasOwnProperty;
    function a() {
      for (var v = "", m = 0; m < arguments.length; m++) {
        var y = arguments[m];
        y && (v = f(v, u(y)));
      }
      return v;
    }
    function u(v) {
      if (typeof v == "string" || typeof v == "number")
        return v;
      if (typeof v != "object")
        return "";
      if (Array.isArray(v))
        return a.apply(null, v);
      if (v.toString !== Object.prototype.toString && !v.toString.toString().includes("[native code]"))
        return v.toString();
      var m = "";
      for (var y in v)
        i.call(v, y) && v[y] && (m = f(m, y));
      return m;
    }
    function f(v, m) {
      return m ? v ? v + " " + m : v + m : v;
    }
    s.exports ? (a.default = a, s.exports = a) : window.classNames = a;
  })();
})(to);
var qd = to.exports;
const mi = /* @__PURE__ */ Ze(qd), Zd = "left", ro = "right";
class Jd extends ws {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getRootProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i = {}) => {
        const { style: a } = i, u = this.props.variant === ro ? this.props.rightSidebarWidth : this.props.leftSidebarWidth;
        return {
          style: {
            color: (a == null ? void 0 : a.color) ?? "#fff",
            ...a,
            width: u
          }
        };
      }
    }), Object.defineProperty(this, "getStateAndHelpers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => ({
        getRootProps: this.getRootProps,
        data: this.props.headerData
      })
    });
  }
  render() {
    const i = this.getStateAndHelpers();
    return this.props.children(i);
  }
}
const Qd = ({ getRootProps: s }) => U("div", { "data-testid": "sidebarHeader", ...s() }), zt = (s) => {
  const { children: i, variant: a = Zd, headerData: u } = s, { leftSidebarWidth: f, rightSidebarWidth: v } = Xr();
  return U(Jd, { leftSidebarWidth: f, rightSidebarWidth: v, variant: a, headerData: u, children: i || Qd });
};
zt.secretKey = "SidebarHeader";
class ef extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getRootStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => ({
        ...this.props.style,
        display: "flex",
        width: "100%"
      })
    }), Object.defineProperty(this, "getCalendarHeaderStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { leftSidebarWidth: i, rightSidebarWidth: a, calendarHeaderStyle: u } = this.props;
        return {
          ...u,
          overflow: "hidden",
          width: `calc(100% - ${i + a}px)`
        };
      }
    }), Object.defineProperty(this, "isSidebarHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => i.type === void 0 ? !1 : i.type.secretKey === zt.secretKey
    });
  }
  render() {
    let i, a;
    const u = [], f = Array.isArray(this.props.children) ? this.props.children.filter((v) => v) : [this.props.children];
    return se.Children.map(f, (v) => {
      var m;
      this.isSidebarHeader(v) ? ((m = v == null ? void 0 : v.props) == null ? void 0 : m.variant) === ro ? i = v : a = v : u.push(v);
    }), a || (a = U(zt, {})), !i && this.props.rightSidebarWidth && (i = U(zt, { variant: "right" })), Ve("div", { "data-testid": "headerRootDiv", style: this.getRootStyle(), className: mi("rct-header-root", this.props.className), children: [a, U("div", { ref: this.props.registerScroll, style: this.getCalendarHeaderStyle(), className: mi("rct-calendar-header", this.props.calendarHeaderClassName), "data-testid": "headerContainer", children: u }), i] });
  }
}
const $r = ({ children: s, style: i, className: a, calendarHeaderStyle: u, calendarHeaderClassName: f }) => {
  const { leftSidebarWidth: v, rightSidebarWidth: m, registerScroll: y } = Xr();
  return U(ef, { leftSidebarWidth: v, rightSidebarWidth: m, registerScroll: y, style: i, className: a, calendarHeaderStyle: u, calendarHeaderClassName: f, children: s });
};
$r.secretKey = "TimelineHeaders";
class no extends se.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "getHeaderIntervals", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ canvasTimeStart: x, canvasTimeEnd: O, unit: $, timeSteps: P, getLeftOffsetFromDate: T }) => {
        const _ = [];
        return Lr(x, O, $, P, (M, C) => {
          const z = T(M.valueOf()), G = T(C.valueOf()) - z;
          _.push({
            startTime: M,
            endTime: C,
            labelWidth: G,
            left: z
          });
        }), _;
      }
    }), Object.defineProperty(this, "getRootProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (x = {}) => {
        const { style: O } = x;
        return {
          style: Object.assign({}, O || {}, {
            position: "relative",
            width: this.props.canvasWidth,
            height: this.props.height
          })
        };
      }
    }), Object.defineProperty(this, "getIntervalProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (x = {}) => {
        const { interval: O, style: $ } = x;
        if (!O)
          throw new Error("you should provide interval to the prop getter");
        const { startTime: P, labelWidth: T, left: _ } = O;
        return {
          style: {
            ...$,
            left: _,
            width: T,
            position: "absolute"
          },
          key: `label-${P.valueOf()}`
        };
      }
    }), Object.defineProperty(this, "getStateAndHelpers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const {
          /*canvasTimeStart,
          canvasTimeEnd,
          timelineWidth,
          visibleTimeStart,
          visibleTimeEnd,*/
          unit: x,
          showPeriod: O,
          headerData: $
        } = this.props;
        return {
          /*timelineContext: {
            timelineWidth,
            visibleTimeStart,
            visibleTimeEnd,
            canvasTimeStart,
            canvasTimeEnd,
          },*/
          headerContext: {
            unit: x,
            intervals: this.state.intervals
          },
          getRootProps: this.getRootProps,
          getIntervalProps: this.getIntervalProps,
          showPeriod: O,
          data: $
        };
      }
    });
    const { canvasTimeStart: a, canvasTimeEnd: u, unit: f, timeSteps: v, getLeftOffsetFromDate: m } = i, y = this.getHeaderIntervals({
      canvasTimeStart: a,
      canvasTimeEnd: u,
      unit: f,
      timeSteps: v,
      getLeftOffsetFromDate: m
    });
    this.state = {
      intervals: y
    };
  }
  /*shouldComponentUpdate(nextProps: CustomHeaderProps<Data>) {
    if (
      nextProps.canvasTimeStart !== this.props.canvasTimeStart ||
      nextProps.canvasTimeEnd !== this.props.canvasTimeEnd ||
      nextProps.canvasWidth !== this.props.canvasWidth ||
      nextProps.unit !== this.props.unit ||
      nextProps.timeSteps !== this.props.timeSteps ||
      nextProps.showPeriod !== this.props.showPeriod ||
      nextProps.children !== this.props.children ||
      nextProps.headerData !== this.props.headerData
    ) {
      return true
    }
    return false
  }*/
  componentDidUpdate(i) {
    if (!Ir(i, this.props)) {
      const { canvasTimeStart: a, canvasTimeEnd: u, unit: f, timeSteps: v, getLeftOffsetFromDate: m } = this.props, y = this.getHeaderIntervals({
        canvasTimeStart: a,
        canvasTimeEnd: u,
        unit: f,
        timeSteps: v,
        getLeftOffsetFromDate: m
      });
      this.setState({ intervals: y });
    }
  }
  render() {
    const i = this.getStateAndHelpers();
    return this.props.children(i);
  }
}
Object.defineProperty(no, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    height: 30
  }
});
function tf({ children: s, unit: i, headerData: a, height: u }) {
  const { getTimelineState: f, showPeriod: v, getLeftOffsetFromDate: m } = fd(), y = f(), { timeSteps: x } = Xr();
  return U(no, { children: s, timeSteps: x, showPeriod: v, unit: i || y.timelineUnit, ...y, headerData: a, getLeftOffsetFromDate: m, height: u });
}
var bi = Number.isNaN || function(i) {
  return typeof i == "number" && i !== i;
};
function rf(s, i) {
  return !!(s === i || bi(s) && bi(i));
}
function nf(s, i) {
  if (s.length !== i.length)
    return !1;
  for (var a = 0; a < s.length; a++)
    if (!rf(s[a], i[a]))
      return !1;
  return !0;
}
function yi(s, i) {
  i === void 0 && (i = nf);
  var a = null;
  function u() {
    for (var f = [], v = 0; v < arguments.length; v++)
      f[v] = arguments[v];
    if (a && a.lastThis === this && i(f, a.lastArgs))
      return a.lastResult;
    var m = s.apply(this, f);
    return a = {
      lastResult: m,
      lastArgs: f,
      lastThis: this
    }, m;
  }
  return u.clear = function() {
    a = null;
  }, u;
}
class of extends se.PureComponent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "onIntervalClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { primaryHeader: i, interval: a, unit: u, showPeriod: f } = this.props;
        if (i) {
          const v = Hr(u), m = a.startTime.clone().startOf(v), y = a.startTime.clone().endOf(v);
          f(m, y);
        } else
          f(a.startTime, a.endTime);
      }
    }), Object.defineProperty(this, "getIntervalProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i = {}) => ({
        ...this.props.getIntervalProps({
          interval: this.props.interval,
          ...i
        }),
        onClick: Ke(this.onIntervalClick, i.onClick)
      })
    });
  }
  render() {
    const { intervalText: i, interval: a, intervalRenderer: u, headerData: f } = this.props, v = u;
    if (v)
      return v({
        getIntervalProps: this.getIntervalProps,
        intervalContext: {
          interval: a,
          intervalText: i
        },
        data: f
      });
    const { key: m, ...y } = this.getIntervalProps();
    return Rt(
      "div",
      { "data-testid": "dateHeaderInterval", ...y, key: m, className: `rct-dateHeader ${this.props.primaryHeader ? "rct-dateHeader-primary" : ""}` },
      U("span", { children: i })
    );
  }
}
function sf({ headerContext: { intervals: s, unit: i }, getRootProps: a, getIntervalProps: u, showPeriod: f, data: { style: v, intervalRenderer: m, className: y, getLabelFormat: x, unitProp: O, headerData: $ } }) {
  return U("div", { "data-testid": "dateHeader", className: y, ...a({ style: v }), children: s.map((P) => {
    const T = x([P.startTime, P.endTime], i, P.labelWidth);
    return U(of, { unit: i, interval: P, showPeriod: f, intervalText: T, primaryHeader: O === "primaryHeader", getIntervalProps: u, intervalRenderer: m, headerData: $ }, `label-${P.startTime.valueOf()}`);
  }) });
}
class af extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getHeaderUnit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => this.props.unit === "primaryHeader" ? Hr(this.props.timelineUnit) : this.props.unit ? this.props.unit : this.props.timelineUnit
    }), Object.defineProperty(this, "getRootStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: yi((i) => ({
        height: 30,
        ...i
      }))
    }), Object.defineProperty(this, "getLabelFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i, a, u) => {
        const { labelFormat: f } = this.props;
        if (typeof f == "string")
          return i[0].format(f);
        if (typeof f == "function")
          return f(i, a, u);
        throw new Error("labelFormat should be function or string");
      }
    }), Object.defineProperty(this, "getHeaderData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: yi((i, a, u, f, v, m) => ({
        intervalRenderer: i,
        style: a,
        className: u,
        getLabelFormat: f,
        unitProp: v,
        headerData: m
      }))
    });
  }
  render() {
    const i = this.getHeaderUnit(), { height: a } = this.props;
    return U(tf, { children: sf, unit: i, height: a, headerData: this.getHeaderData(this.props.intervalRenderer, this.getRootStyle(this.props.style), this.props.className, this.getLabelFormat, this.props.unit, this.props.headerData) });
  }
}
function Ti({ labelFormat: s, unit: i, style: a, className: u, intervalRenderer: f, headerData: v, height: m }) {
  return U(qt, { children: ({ getTimelineState: y }) => {
    const x = y();
    return U(af, { timelineUnit: x.timelineUnit, unit: i, labelFormat: s || lf, style: a, className: u, intervalRenderer: f, headerData: v, height: m });
  } });
}
const lf = ([s], i, a = 150, u = Kd) => {
  let f;
  return a >= 150 ? f = u[i].long : a >= 100 ? f = u[i].mediumLong : a >= 50 ? f = u[i].medium : f = u[i].short, s.format(f);
};
var io = { exports: {} };
(function(s, i) {
  (function(a, u) {
    s.exports = u();
  })(We, function() {
    var a = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(u, f, v) {
      var m = f.prototype, y = m.format;
      v.en.formats = a, m.format = function(x) {
        x === void 0 && (x = "YYYY-MM-DDTHH:mm:ssZ");
        var O = this.$locale().formats, $ = function(P, T) {
          return P.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(_, M, C) {
            var z = C && C.toUpperCase();
            return M || T[C] || a[C] || T[z].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(N, G, Q) {
              return G || Q.slice(1);
            });
          });
        }(x, O === void 0 ? {} : O);
        return y.call(this, $);
      };
    };
  });
})(io);
var cf = io.exports;
const uf = /* @__PURE__ */ Ze(cf);
Me.extend(uf);
class oo extends xe {
  constructor(i) {
    super(i), Object.defineProperty(this, "getTimelineContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { width: T, visibleTimeStart: _, visibleTimeEnd: M, canvasTimeStart: C, canvasTimeEnd: z } = this.state, N = M - _, G = Re(T, this.props.buffer), Q = kt(N, T, this.props.timeSteps);
        return {
          canvasWidth: G,
          timelineUnit: Q,
          timelineWidth: T,
          visibleTimeStart: _,
          visibleTimeEnd: M,
          canvasTimeStart: C,
          canvasTimeEnd: z
        };
      }
    }), Object.defineProperty(this, "getTimelineUnit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { width: T, visibleTimeStart: _, visibleTimeEnd: M } = this.state, { timeSteps: C } = this.props, z = M - _;
        return kt(z, T, C);
      }
    }), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scrollComponent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "scrollHeaderRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "resize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T = this.props) => {
        var re;
        const { width: _ } = ((re = this.container.current) == null ? void 0 : re.getBoundingClientRect()) ?? { width: 0 }, M = _ - T.sidebarWidth - T.rightSidebarWidth, C = Re(M, T.buffer), { dimensionItems: z, height: N, groupHeights: G, groupTops: Q } = qe(T.items, T.groups, C, this.state.canvasTimeStart, this.state.canvasTimeEnd, T.keys, T.lineHeight, T.itemHeightRatio, T.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder);
        this.setState({
          width: M,
          dimensionItems: z,
          height: N,
          groupHeights: G,
          groupTops: Q
        });
        const te = M * ((T.buffer - 1) / 2);
        this.scrollComponent && (this.scrollComponent.scrollLeft = te), this.scrollHeaderRef && (this.scrollHeaderRef.scrollLeft = te);
      }
    }), Object.defineProperty(this, "onScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        var N, G;
        const _ = this.state.width, M = this.state.canvasTimeStart, C = this.state.visibleTimeEnd - this.state.visibleTimeStart, z = M + C * T / _;
        (this.state.visibleTimeStart !== z || this.state.visibleTimeEnd !== z + C) && ((G = (N = this.props).onTimeChange) == null || G.call(N, z, z + C, this.updateScrollCanvas, this.getTimelineUnit()));
      }
    }), Object.defineProperty(this, "updateScrollCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _, M = !1, C = this.props.items, z = this.props.groups) => {
        this.setState(Rr(T, _, M, C, z, this.props, this.state));
      }
    }), Object.defineProperty(this, "handleWheelZoom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _, M) => {
        this.changeZoom(1 + T * M / 500, _ / this.state.width);
      }
    }), Object.defineProperty(this, "changeZoom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _ = 0.5) => {
        const { minZoom: M, maxZoom: C } = this.props, z = this.state.visibleTimeEnd - this.state.visibleTimeStart, N = Math.min(Math.max(Math.round(z * T), M), C), G = Math.round(this.state.visibleTimeStart + (z - N) * _);
        this.props.onTimeChange && this.props.onTimeChange(G, G + N, this.updateScrollCanvas, this.getTimelineUnit());
      }
    }), Object.defineProperty(this, "showPeriod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _) => {
        var N, G;
        const M = T.valueOf(), z = _.valueOf() - M;
        z < this.props.minZoom || (G = (N = this.props).onTimeChange) == null || G.call(N, M, M + z, this.updateScrollCanvas, this.getTimelineUnit());
      }
    }), Object.defineProperty(this, "selectItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _, M) => {
        if (this.isItemSelected(T) || this.props.itemTouchSendsClick && _ === "touch") {
          if (T && this.props.onItemClick) {
            const C = this.timeFromItemEvent(M);
            this.props.onItemClick(T, M, C);
          }
        } else if (this.setState({ selectedItem: T }), T && this.props.onItemSelect) {
          const C = this.timeFromItemEvent(M);
          this.props.onItemSelect(T, M, C);
        } else T === null && this.props.onItemDeselect && this.props.onItemDeselect(M);
      }
    }), Object.defineProperty(this, "doubleClickItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _) => {
        if (this.props.onItemDoubleClick) {
          const M = this.timeFromItemEvent(_);
          this.props.onItemDoubleClick(T, _, M);
        }
      }
    }), Object.defineProperty(this, "contextMenuClickItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _) => {
        if (this.props.onItemContextMenu) {
          const M = this.timeFromItemEvent(_);
          this.props.onItemContextMenu(T, _, M);
        }
      }
    }), Object.defineProperty(this, "getTimeFromRowClickEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        const { dragSnap: _, buffer: M } = this.props, { width: C, canvasTimeStart: z, canvasTimeEnd: N } = this.state, { offsetX: G } = T.nativeEvent;
        let Q = Ar(z, N, Re(C, M), G);
        return Q = Math.floor(Q / _) * _, Q;
      }
    }), Object.defineProperty(this, "timeFromItemEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        const { width: _, visibleTimeStart: M, visibleTimeEnd: C } = this.state, z = this.props.dragSnap, N = this.scrollComponent, { left: G } = N.getBoundingClientRect(), te = (T.clientX - G) / _, re = C - M, ue = te * re;
        let S = Math.round(M + ue);
        return S = Math.floor(S / z) * z, S;
      }
    }), Object.defineProperty(this, "dragItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _, M) => {
        const C = this.props.groups[M], z = this.props.keys;
        this.setState({
          draggingItem: T,
          dragTime: _,
          newGroupOrder: M,
          dragGroupTitle: C ? J(C, z.groupLabelKey) : ""
        }), this.updatingItem({
          eventType: "move",
          itemId: T,
          time: _,
          newGroupOrder: M
        });
      }
    }), Object.defineProperty(this, "dropItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _, M) => {
        this.setState({ draggingItem: null, dragTime: null, dragGroupTitle: null }), this.props.onItemMove && this.props.onItemMove(T, _, M);
      }
    }), Object.defineProperty(this, "resizingItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _, M) => {
        this.setState({
          resizingItem: T,
          resizingEdge: M,
          resizeTime: _
        }), this.updatingItem({
          eventType: "resize",
          itemId: T,
          time: _,
          edge: M || void 0
        });
      }
    }), Object.defineProperty(this, "resizedItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _, M, C) => {
        this.setState({ resizingItem: null, resizingEdge: null, resizeTime: null }), this.props.onItemResize && C !== 0 && this.props.onItemResize(T, _, M);
      }
    }), Object.defineProperty(this, "updatingItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ eventType: T, itemId: _, time: M, edge: C, newGroupOrder: z }) => {
        this.props.onItemDrag && (T === "move" ? this.props.onItemDrag({
          eventType: T,
          itemId: _,
          time: M,
          newGroupOrder: z
        }) : this.props.onItemDrag({
          eventType: T,
          itemId: _,
          time: M,
          edge: C
        }));
      }
    }), Object.defineProperty(this, "handleRowClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _) => {
        if (this.hasSelectedItem() && this.selectItem(null, "click", T), this.props.onCanvasClick == null)
          return;
        const M = this.getTimeFromRowClickEvent(T), C = J(this.props.groups[_], this.props.keys.groupIdKey);
        this.props.onCanvasClick(C, M, T);
      }
    }), Object.defineProperty(this, "handleRowDoubleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _) => {
        if (this.props.onCanvasDoubleClick == null)
          return;
        const M = this.getTimeFromRowClickEvent(T), C = J(this.props.groups[_], this.props.keys.groupIdKey);
        this.props.onCanvasDoubleClick(C, M, T);
      }
    }), Object.defineProperty(this, "handleScrollContextMenu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _) => {
        if (this.props.onCanvasContextMenu == null)
          return;
        const M = this.getTimeFromRowClickEvent(T), C = J(this.props.groups[_], this.props.keys.groupIdKey);
        this.props.onCanvasContextMenu && (T.preventDefault(), this.props.onCanvasContextMenu(C, M, T));
      }
    }), Object.defineProperty(this, "handleHeaderRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        this.scrollHeaderRef = T, this.props.headerRef && this.props.headerRef(T);
      }
    }), Object.defineProperty(this, "isTimelineHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => T.type === void 0 ? !1 : T.type.secretKey === $r.secretKey
    }), Object.defineProperty(this, "renderHeaders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        if (this.props.children) {
          let T;
          if (se.Children.map(this.props.children, (_) => {
            this.isTimelineHeader(_) && (T = _);
          }), T)
            return T;
        }
        return Ve($r, { children: [U(Ti, { unit: "primaryHeader" }), U(Ti, {})] });
      }
    }), Object.defineProperty(this, "getScrollElementRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        this.props.scrollRef && this.props.scrollRef(T), this.scrollComponent = T;
      }
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: se.createRef()
    }), Object.defineProperty(this, "getBoundingClientRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => this.scrollComponent.getBoundingClientRect()
    }), Object.defineProperty(this, "calculateDropCoordinatesToTimeAndGroup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, _) => {
        const M = Re(this.state.width, this.props.buffer), C = Ut(this.state.canvasTimeStart, this.state.canvasTimeEnd, M), z = At(this.scrollComponent).offsetLeft, N = jt(this.scrollComponent), G = (T - z + N.scrollLeft) * C + this.state.canvasTimeStart;
        let Q = 0;
        for (const re of this.state.groupTops)
          if (_ > Number(re))
            Q = this.state.groupTops.indexOf(re);
          else
            break;
        if (!this.props.dragSnap)
          return { time: G, groupIndex: Q };
        const te = Me().utcOffset() * 60 * 1e3;
        return {
          time: Math.round(G / this.props.dragSnap) * this.props.dragSnap - te % this.props.dragSnap,
          groupIndex: Q
        };
      }
    }), this.getSelected = this.getSelected.bind(this), this.hasSelectedItem = this.hasSelectedItem.bind(this), this.isItemSelected = this.isItemSelected.bind(this);
    let a = null, u = null;
    if (this.props.defaultTimeStart && this.props.defaultTimeEnd)
      a = this.props.defaultTimeStart, u = this.props.defaultTimeEnd;
    else if (this.props.visibleTimeStart && this.props.visibleTimeEnd)
      a = this.props.visibleTimeStart, u = this.props.visibleTimeEnd;
    else
      throw new Error('You must provide either "defaultTimeStart" and "defaultTimeEnd" or "visibleTimeStart" and "visibleTimeEnd" to initialize the Timeline');
    const [f, v] = Ur(a, u, i.buffer), m = {
      width: 1e3,
      visibleTimeStart: a,
      visibleTimeEnd: u,
      canvasTimeStart: f,
      canvasTimeEnd: v,
      selectedItem: null,
      dragTime: null,
      dragGroupTitle: null,
      resizeTime: null,
      resizingItem: null,
      resizingEdge: null,
      newGroupOrder: 0
      //CHECK
    }, y = Re(m.width, i.buffer), { dimensionItems: x, height: O, groupHeights: $, groupTops: P } = qe(i.items, i.groups, y, m.canvasTimeStart, m.canvasTimeEnd, i.keys, i.lineHeight, i.itemHeightRatio, i.stackItems, m.draggingItem, m.resizingItem, m.dragTime, m.resizingEdge, m.resizeTime, m.newGroupOrder);
    m.dimensionItems = x, m.height = O, m.groupHeights = $, m.groupTops = P, this.state = m;
  }
  componentDidMount() {
    this.resize(this.props), this.props.resizeDetector && this.props.resizeDetector.addListener && this.props.resizeDetector.addListener(this), gi.addListener(this);
  }
  componentWillUnmount() {
    this.props.resizeDetector && this.props.resizeDetector.addListener && this.props.resizeDetector.removeListener(this), gi.removeListener(this);
  }
  static getDerivedStateFromProps(i, a) {
    const { visibleTimeStart: u, visibleTimeEnd: f, items: v, groups: m } = i, y = { items: v, groups: m }, x = v !== a.items || m !== a.groups;
    if (u && f)
      Object.assign(y, Rr(u, f, x, v, m, i, a));
    else if (x) {
      const O = Re(a.width, i.buffer);
      Object.assign(y, qe(v, m, O, a.canvasTimeStart, a.canvasTimeEnd, i.keys, i.lineHeight, i.itemHeightRatio, i.stackItems, a.draggingItem, a.resizingItem, a.dragTime, a.resizingEdge, a.resizeTime, a.newGroupOrder));
    }
    return y;
  }
  componentDidUpdate(i, a) {
    const u = this.state.visibleTimeEnd - this.state.visibleTimeStart, f = a.visibleTimeEnd - a.visibleTimeStart;
    this.props.onZoom && u !== f && this.props.onZoom(this.getTimelineContext(), this.getTimelineUnit()), this.props.onBoundsChange && this.state.canvasTimeStart !== a.canvasTimeStart && this.props.onBoundsChange(this.state.canvasTimeStart, this.state.canvasTimeStart + u * 3);
    const v = Math.round(this.state.width * (this.state.visibleTimeStart - this.state.canvasTimeStart) / u);
    (Math.round(a.width * (a.visibleTimeStart - a.canvasTimeStart) / f) !== v || this.scrollComponent.scrollLeft !== v) && (this.scrollComponent.scrollLeft = v, this.scrollHeaderRef.scrollLeft = v);
  }
  columns(i, a, u, f, v, m) {
    var y;
    return U(yd, { canvasTimeStart: i, canvasTimeEnd: a, canvasWidth: u, lineCount: ((y = this.props.groups) == null ? void 0 : y.length) || 0, minUnit: f, timeSteps: v, height: m, verticalLineClassNamesForTime: this.props.verticalLineClassNamesForTime });
  }
  rows(i, a, u) {
    var f;
    return U(Sd, { groups: u, canvasWidth: i, lineCount: ((f = this.props.groups) == null ? void 0 : f.length) || 0, groupHeights: a, clickTolerance: this.props.clickTolerance, onRowClick: this.handleRowClick, onRowDoubleClick: this.handleRowDoubleClick, horizontalLineClassNamesForGroup: this.props.horizontalLineClassNamesForGroup, onRowContextClick: this.handleScrollContextMenu });
  }
  items({ canvasTimeStart: i, canvasTimeEnd: a, canvasWidth: u, dimensionItems: f, groupTops: v }) {
    return U(md, { canvasTimeStart: i, canvasTimeEnd: a, canvasWidth: u, dimensionItems: f, groupTops: v, items: this.props.items, groups: this.props.groups, keys: this.props.keys, selectedItem: this.state.selectedItem || void 0, dragSnap: this.props.dragSnap, minResizeWidth: this.props.minResizeWidth, canChangeGroup: this.props.canChangeGroup, canMove: this.props.canMove, canResize: this.props.canResize, useResizeHandle: this.props.useResizeHandle, canSelect: this.props.canSelect, moveResizeValidator: this.props.moveResizeValidator, itemSelect: this.selectItem, itemDrag: this.dragItem, itemDrop: this.dropItem, onItemDoubleClick: this.doubleClickItem, onItemContextMenu: this.props.onItemContextMenu ? this.contextMenuClickItem : void 0, itemResizing: this.resizingItem, itemResized: this.resizedItem, itemRenderer: this.props.itemRenderer, selected: this.props.selected, scrollRef: this.scrollComponent });
  }
  sidebar(i, a) {
    const { sidebarWidth: u } = this.props;
    return u && U(fi, { groups: this.props.groups, groupRenderer: this.props.groupRenderer, keys: this.props.keys, width: u, groupHeights: a, height: i });
  }
  rightSidebar(i, a) {
    const { rightSidebarWidth: u } = this.props;
    return u && U(fi, { groups: this.props.groups, keys: this.props.keys, groupRenderer: this.props.groupRenderer, isRightSidebar: !0, width: u, groupHeights: a, height: i });
  }
  childrenWithProps(i, a, u, f, v, m, y, x, O, $, P) {
    if (!this.props.children)
      return null;
    const T = Array.isArray(this.props.children) ? this.props.children.filter((M) => M) : [this.props.children], _ = {
      canvasTimeStart: i,
      canvasTimeEnd: a,
      canvasWidth: u,
      visibleTimeStart: x,
      visibleTimeEnd: O,
      dimensionItems: f,
      items: this.props.items,
      groups: this.props.groups,
      keys: this.props.keys,
      groupHeights: v,
      groupTops: m,
      selected: this.getSelected(),
      height: y,
      minUnit: $,
      timeSteps: P
    };
    return se.Children.map(T, (M) => this.isTimelineHeader(M) ? null : se.cloneElement(M, _));
  }
  getSelected() {
    return this.state.selectedItem && !this.props.selected ? [this.state.selectedItem] : this.props.selected || [];
  }
  hasSelectedItem() {
    return Array.isArray(this.props.selected) ? this.props.selected.length > 0 : !!this.state.selectedItem;
  }
  isItemSelected(i) {
    return this.getSelected().some((u) => u === i);
  }
  render() {
    const { items: i, groups: a, sidebarWidth: u, rightSidebarWidth: f, timeSteps: v, traditionalZoom: m, buffer: y } = this.props, { draggingItem: x, resizingItem: O, width: $, visibleTimeStart: P, visibleTimeEnd: T, canvasTimeStart: _, canvasTimeEnd: M } = this.state;
    let { dimensionItems: C, height: z, groupHeights: N, groupTops: G } = this.state;
    const Q = T - P, te = Re($, y), re = kt(Q, $, v);
    if (!!x || !!O) {
      const be = qe(i, a, te, this.state.canvasTimeStart, this.state.canvasTimeEnd, this.props.keys, this.props.lineHeight, this.props.itemHeightRatio, this.props.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder);
      C = be.dimensionItems, z = be.height, N = be.groupHeights, G = be.groupTops;
    }
    const S = {
      height: `${z}px`
    };
    return U(dd, { visibleTimeStart: P, visibleTimeEnd: T, canvasTimeStart: _, canvasTimeEnd: M, canvasWidth: te, showPeriod: this.showPeriod, timelineUnit: re, timelineWidth: this.state.width, children: U($d, { children: U(Bd, { registerScroll: this.handleHeaderRef, timeSteps: v, leftSidebarWidth: this.props.sidebarWidth, rightSidebarWidth: this.props.rightSidebarWidth, children: Ve("div", { style: this.props.style, ref: this.container, className: `react-calendar-timeline ${this.props.className}`, children: [this.renderHeaders(), Ve("div", { style: S, className: "rct-outer", children: [u > 0 ? this.sidebar(z, N) : null, U(xd, { scrollRef: this.getScrollElementRef, width: $, height: z, onZoom: this.changeZoom, onWheelZoom: this.handleWheelZoom, traditionalZoom: !!m, onScroll: this.onScroll, children: Ve(Fd, { children: [this.columns(_, M, te, re, v, z), this.rows(te, N, a), this.items({
      canvasTimeStart: _,
      canvasTimeEnd: M,
      canvasWidth: te,
      dimensionItems: C,
      groupTops: G
    }), this.childrenWithProps(_, M, te, C, N, G, z, P, T, re, v)] }) }), f > 0 ? this.rightSidebar(z, N) : null] })] }) }) }) });
  }
}
Object.defineProperty(oo, "setDayjsLocale", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Me.locale
});
Object.defineProperty(oo, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    sidebarWidth: 150,
    rightSidebarWidth: 0,
    dragSnap: 1e3 * 60 * 15,
    // 15min
    minResizeWidth: 20,
    lineHeight: 30,
    itemHeightRatio: 0.65,
    buffer: 3,
    minZoom: 60 * 60 * 1e3,
    // 1 hour
    maxZoom: 5 * 365.24 * 86400 * 1e3,
    // 5 years
    clickTolerance: 3,
    // how many pixels can we drag for it to be still considered a click?
    canChangeGroup: !0,
    canMove: !0,
    canResize: "right",
    useResizeHandle: !1,
    canSelect: !0,
    stackItems: !1,
    traditionalZoom: !1,
    horizontalLineClassNamesForGroup: null,
    onItemMove: null,
    onItemResize: null,
    onItemClick: null,
    onItemSelect: null,
    onItemDeselect: null,
    onItemDrag: null,
    onCanvasClick: null,
    onItemDoubleClick: null,
    onItemContextMenu: null,
    onZoom: null,
    verticalLineClassNamesForTime: null,
    moveResizeValidator: null,
    dayBackground: null,
    defaultTimeStart: null,
    defaultTimeEnd: null,
    itemTouchSendsClick: !1,
    style: {},
    className: "",
    keys: Yd,
    timeSteps: Gd,
    headerRef: () => {
    },
    scrollRef: () => {
    },
    // if you pass in visibleTimeStart and visibleTimeEnd, you must also pass onTimeChange(visibleTimeStart, visibleTimeEnd),
    // which needs to update the props visibleTimeStart and visibleTimeEnd to the ones passed
    visibleTimeStart: null,
    visibleTimeEnd: null,
    onTimeChange: function(s, i, a) {
      a(s, i);
    },
    // called when the canvas area of the calendar changes
    onBoundsChange: null,
    children: null,
    selected: null
  }
});
const Sf = (s) => s.children || null;
class so extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "getMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    const { unsubscribe: i, getMarker: a } = this.props.subscribeMarker({
      type: Fe.Today,
      renderer: this.props.children,
      interval: this.props.interval
    });
    this.unsubscribe = i, this.getMarker = a;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  componentDidUpdate(i) {
    if (i.interval !== this.props.interval && this.getMarker) {
      const a = this.getMarker();
      this.props.updateMarker({
        ...a,
        interval: this.props.interval
      });
    }
  }
  render() {
    return null;
  }
}
Object.defineProperty(so, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    interval: 1e3 * 10
    // default to ten seconds
  }
});
const pf = (s) => U(Zt, { children: ({ subscribeMarker: i, updateMarker: a }) => U(so, { subscribeMarker: i, updateMarker: a, ...s }) });
pf.displayName = "TodayMarkerWrapper";
class hf extends xe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "getMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidUpdate(i) {
    if (i.date !== this.props.date && this.getMarker) {
      const a = this.getMarker();
      this.props.updateMarker({ ...a, date: this.props.date });
    }
  }
  componentDidMount() {
    const { unsubscribe: i, getMarker: a } = this.props.subscribeMarker({
      type: Fe.Custom,
      renderer: this.props.children,
      date: this.props.date
    });
    this.unsubscribe = i, this.getMarker = a;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  render() {
    return null;
  }
}
const df = (s) => U(Zt, { children: ({ subscribeMarker: i, updateMarker: a }) => U(hf, { subscribeMarker: i, updateMarker: a, ...s }) });
df.displayName = "CustomMarkerWrapper";
class ff extends xe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    const { unsubscribe: i } = this.props.subscribeMarker({
      type: Fe.Cursor,
      renderer: this.props.children
    });
    this.unsubscribe = i;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  render() {
    return null;
  }
}
const vf = (s) => U(Zt, { children: ({ subscribeMarker: i }) => U(ff, { subscribeMarker: i, ...s }) });
vf.displayName = "CursorMarkerWrapper";
export {
  vf as CursorMarker,
  tf as CustomHeader,
  df as CustomMarker,
  Ti as DateHeader,
  wd as GroupRow,
  md as RowItems,
  zt as SidebarHeader,
  oo as Timeline,
  $r as TimelineHeaders,
  Sf as TimelineMarkers,
  pf as TodayMarker,
  bf as calendarUtils,
  oo as default
};
//# sourceMappingURL=react-calendar-timeline.es.js.map
