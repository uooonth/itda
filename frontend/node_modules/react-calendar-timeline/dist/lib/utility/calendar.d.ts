import { Dayjs } from 'dayjs';
import { Dimension, ItemDimension } from '../types/dimension';
import { GroupedItem, GroupOrders, GroupStack, Id, TimelineGroupBase, TimelineItemBase, TimelineKeys, TimelineTimeSteps } from '../types/main';
import { ReactCalendarTimelineProps, ReactCalendarTimelineState } from '../Timeline';
/**
 * Calculate the ms / pixel ratio of the timeline state
 * @param {number} canvasTimeStart
 * @param {number} canvasTimeEnd
 * @param {number} canvasWidth
 * @returns {number}
 */
export declare function coordinateToTimeRatio(canvasTimeStart: number, canvasTimeEnd: number, canvasWidth: number): number;
/**
 * For a given time, calculate the pixel position given timeline state
 * (timeline width in px, canvas time range)
 * @param {number} canvasTimeStart
 * @param {number} canvasTimeEnd
 * @param {number} canvasWidth
 * @param {number} time
 * @returns {number}
 */
export declare function calculateXPositionForTime(canvasTimeStart: number, canvasTimeEnd: number, canvasWidth: number, time: number): number;
/**
 * For a given x position (leftOffset) in pixels, calculate time based on
 * timeline state (timeline width in px, canvas time range)
 * @param {number} canvasTimeStart
 * @param {number} canvasTimeEnd
 * @param {number} canvasWidth
 * @param {number} leftOffset
 * @returns {number}
 */
export declare function calculateTimeForXPosition(canvasTimeStart: number, canvasTimeEnd: number, canvasWidth: number, leftOffset: number): number;
export declare function iterateTimes(start: number, end: number, unit: keyof TimelineTimeSteps, timeSteps: TimelineTimeSteps, callback: (time: Dayjs, nextTime: Dayjs) => void): void;
/** determine the current rendered time unit based on timeline time span
 *
 * zoom: (in milliseconds) difference between time start and time end of timeline canvas
 * width: (in pixels) pixel width of timeline canvas
 * timeSteps: map of timeDividers with number to indicate step of each divider
 */
export declare const minCellWidth = 17;
export declare function getMinUnit(zoom: number, width: number, timeSteps: TimelineTimeSteps): "year";
export type SelectUnits = 'second' | 'minute' | 'hour' | 'day' | 'month' | 'year';
export type SelectUnitsRes = Exclude<SelectUnits, 'second'>;
export declare const NEXT_UNITS: Record<SelectUnits, SelectUnitsRes>;
export declare function getNextUnit(unit: SelectUnits): SelectUnitsRes;
/**
 * get the new start and new end time of item that is being
 * dragged or resized
 * @param {*} itemTimeStart original item time in milliseconds
 * @param {*} itemTimeEnd original item time in milliseconds
 * @param {*} dragTime new start time if item is dragged in milliseconds
 * @param {*} isDragging is item being dragged
 * @param {*} isResizing is item being resized
 * @param {`right` or `left`} resizingEdge resize edge
 * @param {*} resizeTime new resize time in milliseconds
 */
export declare function calculateInteractionNewTimes({ itemTimeStart, itemTimeEnd, dragTime, isDragging, isResizing, resizingEdge, resizeTime, }: {
    itemTimeStart: number;
    itemTimeEnd: number;
    dragTime: number | null;
    isDragging: boolean;
    isResizing: boolean;
    resizingEdge: 'left' | 'right' | null;
    resizeTime: number | null;
}): [number, number];
export declare function calculateDimensions({ itemTimeStart, itemTimeEnd, canvasTimeStart, canvasTimeEnd, canvasWidth, }: {
    itemTimeStart: number;
    itemTimeEnd: number;
    canvasTimeStart: number;
    canvasTimeEnd: number;
    canvasWidth: number;
}): Partial<Dimension>;
/**
 * Get the order of groups based on their keys
 * @param {*} groups array of groups
 * @param {*} keys the keys object
 * @returns Ordered hash of objects with their array index and group
 */
export declare function getGroupOrders(groups: TimelineGroupBase[], keys: TimelineKeys): GroupOrders;
/**
 * Adds items relevant to each group to the result of getGroupOrders
 * @param {*} items list of all items
 * @param {*} groupOrders the result of getGroupOrders
 */
export declare function getGroupedItems(items: ItemDimension[], groupOrders: GroupOrders): Record<number, GroupedItem>;
export declare function getVisibleItems<CustomItem extends TimelineItemBase<any> = TimelineItemBase<number>>(items: CustomItem[], canvasTimeStart: number, canvasTimeEnd: number, keys: TimelineKeys): CustomItem[];
export declare function collision(a: Dimension, b: Dimension, collisionPadding?: number): boolean;
/**
 * Calculate the position of a given item for a group that
 * is being stacked
 */
export declare function groupStack(lineHeight: number, item: ItemDimension, group: ItemDimension[], groupHeight: number, groupTop: number, itemIndex: number): GroupStack;
export declare function groupNoStack(lineHeight: number, item: ItemDimension, groupHeight: number, groupTop: number): GroupStack;
/**
 * Stack all groups
 * @param itemsDimensions
 * @param {*} groupOrders the groupOrders object
 * @param {*} lineHeight
 * @param {*} stackItems should items be stacked?
 */
export declare function stackAll(itemsDimensions: ItemDimension[], groupOrders: GroupOrders, lineHeight: number, stackItems: boolean): {
    height: number;
    groupHeights: number[];
    groupTops: number[];
};
/**
 *
 * @param {*} itemsDimensions
 * @param {*} isGroupStacked
 * @param {*} lineHeight
 * @param {*} groupTop
 */
export declare function stackGroup(itemsDimensions: ItemDimension[], isGroupStacked: boolean, lineHeight: number, groupTop: number): {
    groupHeight: number;
    verticalMargin: number;
};
/**
 * Stack the items that will be visible
 * within the canvas area
 * @param {item[]} items
 * @param {group[]} groups
 * @param {number} canvasWidth
 * @param {number} canvasTimeStart
 * @param {number} canvasTimeEnd
 * @param {*} keys
 * @param {number} lineHeight
 * @param {number} itemHeightRatio
 * @param {boolean} stackItems
 * @param {*} draggingItem
 * @param {*} resizingItem
 * @param {number} dragTime
 * @param {left or right} resizingEdge
 * @param {number} resizeTime
 * @param {number} newGroupOrder
 */
export declare function stackTimelineItems<CustomItem extends TimelineItemBase<any> = TimelineItemBase<number>, CustomGroup extends TimelineGroupBase = TimelineGroupBase>(items: CustomItem[], groups: CustomGroup[], canvasWidth: number, canvasTimeStart: number, canvasTimeEnd: number, keys: TimelineKeys, lineHeight: number, itemHeightRatio: number, stackItems: boolean, draggingItem: Id | null | undefined, resizingItem: Id | null | undefined, dragTime: number | null, resizingEdge: 'left' | 'right' | null, resizeTime: number | null, newGroupOrder: number): {
    dimensionItems: ItemDimension[];
    height: number;
    groupHeights: number[];
    groupTops: number[];
};
/**
 * get canvas width from visible width
 * @param {*} width
 * @param {*} buffer
 */
export declare function getCanvasWidth(width: number, buffer: number): number;
/**
 * get item's position, dimensions and collisions
 * @param {*} item
 * @param {*} keys
 * @param {*} canvasTimeStart
 * @param {*} canvasTimeEnd
 * @param {*} canvasWidth
 * @param {*} groupOrders
 * @param {*} lineHeight
 * @param {*} itemHeightRatio
 */
export declare function getItemDimensions<CustomItem extends TimelineItemBase<any>>({ item, keys, canvasTimeStart, canvasTimeEnd, canvasWidth, groupOrders, lineHeight, itemHeightRatio, }: {
    item: CustomItem;
    keys: TimelineKeys;
    canvasTimeStart: number;
    canvasTimeEnd: number;
    canvasWidth: number;
    groupOrders: GroupOrders;
    lineHeight: number;
    itemHeightRatio: number;
}): ItemDimension | undefined;
/**
 * get new item with changed  `itemTimeStart` , `itemTimeEnd` and `itemGroupKey` according to user interaction
 * user interaction is dragging an item and resize left and right
 * @param {*} item
 * @param {*} keys
 * @param {*} draggingItem
 * @param {*} resizingItem
 * @param {*} dragTime
 * @param {*} resizingEdge
 * @param {*} resizeTime
 * @param {*} groups
 * @param {*} newGroupOrder
 */
export declare function getItemWithInteractions<CustomItem extends TimelineItemBase<any>, CustomGroup extends TimelineGroupBase = TimelineGroupBase>({ item, keys, draggingItem, resizingItem, dragTime, resizingEdge, resizeTime, groups, newGroupOrder, }: {
    item: CustomItem;
    keys: TimelineKeys;
    draggingItem: Id | null | undefined;
    resizingItem: Id | null | undefined;
    dragTime: number | null;
    resizingEdge: 'left' | 'right' | null;
    resizeTime: number | null;
    groups: CustomGroup[];
    newGroupOrder: number;
}): CustomItem;
/**
 * get canvas start and end time from visible start and end time
 * @param {number} visibleTimeStart
 * @param {number} visibleTimeEnd
 * @param buffer
 */
export declare function getCanvasBoundariesFromVisibleTime(visibleTimeStart: number, visibleTimeEnd: number, buffer: number): number[];
/**
 * Get the the canvas area for a given visible time
 * Will shift the start/end of the canvas if the visible time
 * does not fit within the existing
 * @param {number} visibleTimeStart
 * @param {number} visibleTimeEnd
 * @param {boolean} forceUpdateDimensions
 * @param {*} items
 * @param {*} groups
 * @param {*} props
 * @param {*} state
 */
export declare function calculateScrollCanvas<P extends ReactCalendarTimelineProps<any, any>, S extends ReactCalendarTimelineState<any, any>>(visibleTimeStart: number, visibleTimeEnd: number, forceUpdateDimensions: boolean, items: any, groups: any, props: P, state: S): S;
